<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 07 Sep 2015 00:53:55 +0800</pubDate>
    <lastBuildDate>Mon, 07 Sep 2015 00:53:55 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>编程语言实现模式</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img4.douban.com/mpic/s7661036.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很久之前已经把这本书看过一遍了，但是一直没有实践过!于是，拿出来再复习一遍，顺便记录笔记。关于这本书有几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ANTLR贯穿全书：作者是&lt;strong&gt;Terence Parr&lt;/strong&gt;，这点也就不奇怪了&lt;/li&gt;
  &lt;li&gt;ANTLR生成的代码是LL(K)的&lt;/li&gt;
  &lt;li&gt;偏重实践，原理很少，想看原理要去看&lt;a href=&quot;http://img3.douban.com/mpic/s3392161.jpg&quot;&gt;龙书&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，你应该知道一个编译的过程大概分成哪几部分以及为什么这样划分!废话少说，来看这本书的内容。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;解析模式&lt;/h2&gt;

&lt;p&gt;词法分析和语法分析很多地方都是相同的，生成的对应的解析器结构为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class G extends Parser {
    // 类型定义
    // 合适的构造函数
    // 规则对应的方法
}
&lt;/pre&gt;

&lt;p&gt;在一个规则中包含很多子规则时，根据向前看符号来决定使用哪个的代码可以用if-else来实现：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
if(向前看到alt1){
    // 匹配alt1
} else if(向前看到alt2){
    // 匹配alt1
}....
&lt;/pre&gt;

&lt;p&gt;这里当然也可以用switch来实现。通常规则上都有一些操作符来增强规则，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;(T)?：T可有可无&lt;/li&gt;
  &lt;li&gt;(T)+：多个T&lt;/li&gt;
  &lt;li&gt;(T)*：零个或多个T&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它们的代码描述如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// (T)?
if(向前看到T){ match(T);}
// (T)+
do{
    match(T);
} while(向前看到T)
// (T)*
while(向前看到T){
    match(T);
}
&lt;/pre&gt;

&lt;p&gt;通常来将利用好上面三个操作大部分的规则都可以搞定!词法分析相对语法分析了来说简单很多，Lexer会提供&lt;strong&gt;nextToken()&lt;/strong&gt;来供Parser使用来不断地获取TOKEN：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public Token nextToken(){
    while(lookahead-char != EOF) {
        switch(lookahead-char){
            case 空白字符: { consume(); continue; }
            case 字符后面可能是T1: return T1();
            case 字符后面可能是T2: return T2();
			// ...
            default:
                出错;
        }
    }
    return EOF;
}
&lt;/pre&gt;

&lt;p&gt;直观上来看用switch进行预测，也可以说是构造了一个状态机吧，其中&lt;strong&gt;consume()&lt;/strong&gt;方法自增下标并将下一个字符当做向前看字符（消费字符）。&lt;/p&gt;

&lt;p&gt;在仅使用一个向前看符来进行语法分析时，也就是LL(1)，对于下面语法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;list : ‘[’ elements ‘]’;
elements : element (‘,’ element);
element : NAME | list;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;生成的Paser如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class ListParser extends Parser {
    public void list(){
        match(ListLexer.LBRACK); // 匹配并消耗词法单元
        elements();
        match(ListLexer.RBRACK);
    }
    public void elements(){
        element();
        while(lookahead.type == ListLexer.COMMA) {
            match(ListLexer.COMMA);
            element();
        }
    }
    public void element(){
        if(lookahead.type == ListLexer.NAME) match(ListLexer.NAME);
        else if(lookahead.type == ListLexer.LBRACK) list();
        else throw new Error(&quot;语法错误&quot;);
    }
}
&lt;/pre&gt;

&lt;p&gt;很简单的语法用LL(1)是没有问题的，对于稍微复杂一点的其预测能力差就暴露出来了，怎么办？当然是多拿几个进行预测!可以构造环形缓冲区来存放用来预测的TOKEN，另外增加两个方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;LA&lt;/strong&gt;：返回第k个向前看词法单元的类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LT&lt;/strong&gt;：返回第k个词法单元&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么文法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;element : NAME ‘=’ NAME
        : NAME
        : list
        ;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对应的程序描述就变为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void element(){
    if(LA(1) == LookaheadLexer.NAME &amp;amp;&amp;amp; LA(2) == LookaheadLexer.EQUALS) {
        match(LookaheadLexer.NAME);
        match(LookaheadLexer.EQUALS);
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.NAME) {
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.LBACK) {
        list();
    } else {
        throw new Error(&quot;语法错误!&quot;);
    }
}
&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析输入&lt;/h2&gt;

</description>
        <pubDate>Sun, 06 Sep 2015 00:00:00 +0800</pubDate>
        <link>/dsl/2015/09/06/Language-Implementation-Patterns.html</link>
        <guid isPermaLink="true">/dsl/2015/09/06/Language-Implementation-Patterns.html</guid>
        
        
        <category>dsl</category>
        
      </item>
    
      <item>
        <title>JavaScript模块化及SEA.JS的使用</title>
        <description>&lt;p&gt;最近因为缺前端，不得已要自学一下，囧~ 偶然在看到阮一峰很久之前关于模块化的文章：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&quot;&gt;模块的写法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html&quot;&gt;AMD规范&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/11/require_js.html&quot;&gt;require.js的用法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看完之后用来下玉伯的sea.js，感觉比较给力。&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;WHY&lt;/h2&gt;

&lt;p&gt;工程中前端开发的代码量早已与后端代码量差不了太多，如果将所有代码放到单个文件中是个头疼的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局变量互相影响&lt;/li&gt;
  &lt;li&gt;JS文件变大影响加载速度&lt;/li&gt;
  &lt;li&gt;结构混乱&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是比较悲剧：在JavaScript中并没有提供类、模块等封装的方法，那么就需要我们想办法利用现有的东西来做模块化。2009年Ryan Dahl创建了&lt;strong&gt;node.js&lt;/strong&gt;项目，将javascript用于服务器端编程，这标志”Javascript模块化编程”正式诞生。&lt;/p&gt;

&lt;h2 id=&quot;how&quot;&gt;HOW&lt;/h2&gt;

&lt;p&gt;为了避免上面的缺点以及为了不暴露私有成员，通常用&lt;a href=&quot;http://blog.csdn.net/qq838419230/article/details/8030078&quot;&gt;立即执行函数&lt;/a&gt;来搞定模块化的定义模块：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var module1 = (function(){
    var _count = 0;
    var m1 = function(){
        //...
    };
    var m2 = function(){
        //...
    };
    return {
        m1 : m1, m2 : m2
    };
})();
&lt;/pre&gt;

&lt;p&gt;大家定义出来的模块可能五花八门，如果都用统一的形式来定义那就可以很方便的引用了。目前常用规范有两种：&lt;strong&gt;CommonJS&lt;/strong&gt;和&lt;strong&gt;AMD&lt;/strong&gt;，node.js的模块系统就是参照CommonJS来实现的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var math = require('math');// 全局的require方法用来加载模块
math.add(2,3);
&lt;/pre&gt;

&lt;p&gt;其中math.add(2,3)要等到require完成之后才能执行，也就是说这是一个&lt;strong&gt;同步&lt;/strong&gt;的过程，在网络不好的环境中浏览器就会进入假死状态，体验极差，为了解决这个问题我们来看&lt;strong&gt;异步&lt;/strong&gt;的AMD规范(require.js)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
require(['math'], function (math) {// require([module], callback);
    math.add(2, 3);
});
&lt;/pre&gt;

&lt;p&gt;参数module是要加载模块的列表，callback则是加载成功之后回调函数。AMD规范中模块的写法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// math.js
define(function (){
    var add = function (x,y){
        return x+y;
    };
    return { add: add };
});
&lt;/pre&gt;

&lt;p&gt;另外可以用require.js来加载非规范AMD模块、文本、图片等，感觉略强大。&lt;/p&gt;

&lt;h2 id=&quot;seajs&quot;&gt;SEA.JS&lt;/h2&gt;

&lt;p&gt;CMD是sea.js使用的规范(所以这个术语貌似只有国人知道)，模块定义如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
define(function(require, exports, module) {
    var a = require('./a');
    a.doSomething();
    var b = require('./b');
    b.doSomething();
});
&lt;/pre&gt;

&lt;p&gt;是不是和AMD很像？通过&lt;strong&gt;require&lt;/strong&gt;在需要的时候引入依赖，通过&lt;strong&gt;exports&lt;/strong&gt;来暴露接口。AMD和CMD的区别可以看&lt;a href=&quot;http://www.zhihu.com/question/20351507/answer/14859415&quot;&gt;这里&lt;/a&gt;，还有&lt;a href=&quot;http://blog.chinaunix.net/uid-26672038-id-4112229.html&quot;&gt;这里&lt;/a&gt;。sea.js中常用的API有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/262&quot;&gt;seajs.config&lt;/a&gt;：配制&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/260&quot;&gt;seajs.use&lt;/a&gt;：在页面上加载模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;define&lt;/a&gt;：定义模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/259&quot;&gt;require&lt;/a&gt;：获取指定模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;require.async&lt;/a&gt;：在模块内部异步加载一个或多个模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;exports&lt;/a&gt;：在模块内部对外提供接口&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;module.exports&lt;/a&gt;：在模块内部对外提供接口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些API已经定义的足够简单，因此，例子就忽略了（你可以看&lt;a href=&quot;http://&quot;&gt;这里&lt;/a&gt;）。。。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;简单看下来，感觉很受用！不过…模块化的趋势貌似是&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/intro&quot;&gt;ECMAScript 6&lt;/a&gt;，ES6的目标是让JavaScript可以用来编写大型、复杂的应用程序，成为企业级开发语言！&lt;/p&gt;

&lt;p&gt;不过…&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;浏览器的支持程度&lt;/a&gt;比较堪忧。。。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/05/JavaScript-Sea.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/05/JavaScript-Sea.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>junit</title>
        <description>&lt;p&gt;打算定期看一个开源代码，听之前同事的建议于是从junit开始：&lt;/p&gt;

&lt;p&gt;TestRunner加载和运行测试，入口类。
TestDecorator对Test进行包装。
TestSetup对Test进行包装，增加初始化、清理接口。&lt;/p&gt;

&lt;p&gt;TestListener监听器，在发生对应的动作的时候进行调用：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public interface TestListener {
    public void addError(Test test, Throwable t);
    public void addFailure(Test test, AssertionFailedError t);
    public void endTest(Test test);
    public void startTest(Test test);
}
&lt;/pre&gt;

&lt;p&gt;TestSuite是TestCase的组合：
ActiveTestSuite创建一个新的线程来执行：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestSuite {
    private Vector&lt;test&gt; fTests = new Vector&lt;test&gt;(10);
}



TestResult
&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestResult{
    protected List&lt;testfailure&gt; fFailures;
    protected List&lt;testfailure&gt; fErrors;
    protected List&lt;testlistener&gt; fListeners;
}



TestCase
&lt;pre class=&quot;prettyprint&quot;&gt;
public void runBare() throws Throwable {
    setUp(); // 初始化
    try {
        runTest(); // 通过反射调用方法
    } finally {
        tearDown(); // 清理
    }
}
&lt;/pre&gt;
&lt;/testlistener&gt;&lt;/testfailure&gt;&lt;/testfailure&gt;&lt;/pre&gt;&lt;/test&gt;&lt;/test&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 02 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/02/Junit.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/02/Junit.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>页面配置</title>
        <description>&lt;p&gt;用MVC框架来开发WEB页面已经是非常成熟的一个事情，那为什么还需要用配置的方式来做页面？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不需要应用发布、重启即可生效&lt;/li&gt;
  &lt;li&gt;可以跨应用重复使用模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在做的比较完善的情况下，产品跟你说一个需求，可能等他回到座位上的时候你已经做好了。当然并不是所有的页面都可以用配置来做，不然配置的方式会巨复杂无比：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;页面布局足够简单&lt;/li&gt;
  &lt;li&gt;组件足够通用，能够重复利用&lt;/li&gt;
  &lt;li&gt;数量足够多&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;报表是一个非常典型的场景，大家可能对&lt;a href=&quot;http://www.umeng.com/apps/4100008dd65107258db11ef4/reports/realtime_summary&quot;&gt;报表&lt;/a&gt;这样的页面见到不是特别多，其实在运营后台、仓库管理系统页面非常非常非常多，如果配置能做够灵活，那么这部分的工作量就都可以省下来了。&lt;/p&gt;

&lt;p&gt;那么，要实现一个页面配置需要解决哪些问题？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;布局&lt;/li&gt;
  &lt;li&gt;组件重复使用&lt;/li&gt;
  &lt;li&gt;交互&lt;/li&gt;
  &lt;li&gt;预览&lt;/li&gt;
  &lt;li&gt;业务应用接入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面依次来看：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;布局&lt;/h2&gt;

&lt;p&gt;经典的布局解决方案是栅格系统（bootstrap），其中的角色包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;container&lt;/li&gt;
  &lt;li&gt;row&lt;/li&gt;
  &lt;li&gt;cloumn&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比较牛逼的是可以嵌套，用到的技巧可以看&lt;a href=&quot;http://segmentfault.com/a/1190000000743553&quot;&gt;这里&lt;/a&gt;，这样我们用这种方式实现比较复杂的表头的时候还是比较容易的! 让开发去写一大堆的class、div来做页面现在比较头大，那么现在的办法是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用简洁的语法把页面需要展示的东西表达清楚，然后将其翻译成HTML+JS。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自己YY的一个语法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@layout
    @layout
        @CompA // 条件
        @CompB // 条件
    @CompC // 查询
    @CompD // 导出
@CompE // 列表展示
@CompF // 分页
&lt;/pre&gt;

&lt;p&gt;通过缩进来控制层次（或者归属）关系，通过@layout来统一控制一组组件的排列展示。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组件的重复利用&lt;/h2&gt;

&lt;p&gt;能够复用的组件可以是：展示+数据，在重复利用时只需要将其引入那么基本上什么都不用管了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@import:easydt/warehouse_list // 引入仓库列表组件
&lt;/pre&gt;

&lt;p&gt;引入之后展示就没有问题了，只需要考虑该组件如何与页面上其他的组件互动。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;交互&lt;/h2&gt;

&lt;p&gt;我们要做的是一个动态的页面，静态页面的解决方案现在已经很多了，相比较动态页面要复杂很多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;响应用户操作&lt;/li&gt;
  &lt;li&gt;组件之间交互&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户的响应还比较简单，对于不同的控件可以预先实现不同的事件，在事件发生时触发对应的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@CompA
    @on(click)
        alert(&quot;用户点击了按钮&quot;)
&lt;/pre&gt;

&lt;p&gt;组件之间的交互有两种实现方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;暴露接口供其他组件调用&lt;/li&gt;
  &lt;li&gt;事件驱动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式在MFC、Swing等编写的时候基本上都属于这种，感觉写起来太消耗脑细胞! 而且HTML的页面上各部分的交互数据居多，那么可以参考Actor模型来设计：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@channel(param)

@CompA(to = &quot;param&quot;)
@CompB(to = &quot;param&quot;)
@CompC(to = &quot;param&quot;)

@CompD(from = &quot;param&quot;)
    @on(click) // 响应点击事件
        // do sth.
&lt;/pre&gt;

&lt;p&gt;在查询条件A、B、C发生变化时将结果发送消息给D，然后在D本地将其保存起来方便后面使用（比如发送请求）。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;预览&lt;/h2&gt;

&lt;p&gt;在一个独立的页面配置应用上配置完成之后预览时，需要的数据要到业务应用中获取，用ajax的话就遇到了跨域问题。两种解决办法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有的接口使用JSONP格式&lt;/li&gt;
  &lt;li&gt;在业务系统中提供一个页面专门用来做预览&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用JSONP的主要缺点就是只能用GET方式，也就是说：&lt;strong&gt;GET的限制JSONP全都有&lt;/strong&gt;。第二种方法则有点像开个后门，直接看到的效果和在应用中看到的效果已经是一致的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;业务应用接入&lt;/h2&gt;

&lt;p&gt;接入的方式是由配置的产出的结果有关系的，现在有两种产出的方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提供JSON接口来输出展示需要的数据&lt;/li&gt;
  &lt;li&gt;根据配置动态生成JS文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式比较直观，做起来也很简单，业务方执行的流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开发写个页面将CODE设置进去&lt;/li&gt;
  &lt;li&gt;渲染HTML页面，然后运行JS根据CODE去获取展示所需的数据&lt;/li&gt;
  &lt;li&gt;渲染页面&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该方式有个小小的问题：&lt;strong&gt;在根据CODE获取页面时页面会出现空白&lt;/strong&gt;。用第二种方式将生成的JS引入对应的页面即可，具体页面长什么样子都在该JS文件中保存。这样做的好处是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以在JS文件中定义更加复杂的操作&lt;/li&gt;
  &lt;li&gt;JS代码在浏览器做缓存，从第二次操作开始就不需要请求页面展示的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外在产出JS时基本上就没有搞不定的事情了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;其实这个还没开始做，想法也在UPDATING，做完再来总结:)&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Aug 2015 00:00:00 +0800</pubDate>
        <link>/dsl/2015/08/28/Easydt-Page-Solution.html</link>
        <guid isPermaLink="true">/dsl/2015/08/28/Easydt-Page-Solution.html</guid>
        
        
        <category>dsl</category>
        
      </item>
    
      <item>
        <title>Java并发编程实战</title>
        <description>&lt;p&gt;看完之后感觉Doug Lea写的书都是精品，不过有些地方翻译的确实不怎么样…&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;线程&lt;/h2&gt;

&lt;p&gt;线程比进程更轻，更易于共享数据，关于Java中的线程要了解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程安全&lt;/li&gt;
  &lt;li&gt;可见性&lt;/li&gt;
  &lt;li&gt;中断&lt;/li&gt;
  &lt;li&gt;关闭钩子&lt;/li&gt;
  &lt;li&gt;守护线程&lt;/li&gt;
  &lt;li&gt;ThreadLocal&lt;/li&gt;
  &lt;li&gt;线程的开销&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很长一段时间对线程安全的定义比较迷糊，下面这个定义感觉是比较准确的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式，该类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;或者更简单地描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;结果与调度的方式无关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看似简单但坑却不少，比如多线程中可见性这种反直觉的东西：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
private static boolean ready;
private static int number;
static class ReaderThread extends Thread {
	public void run() {
    	while(!ready){
        	Thread.yield();
        }
        System.out.println(number);
    }
}
public static void main(String[] args){
	new ReaderThread().start();
    number = 42;
    ready = true;
}
&lt;/pre&gt;

&lt;p&gt;这里程序可能持续运行下去，因为ReaderThread可能永远看不到ready的值；程序也可能输出0，因为ReadyThread可能只看到写入ready的值：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在没有同步的情况下编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;开启线程只需要一个start，而想让它停下来就没那么简单了，因为stop已经不建议再使用，原因是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在任意位置抛出ThreadDeath&lt;/li&gt;
  &lt;li&gt;释放锁&lt;/li&gt;
  &lt;li&gt;关闭时需要同步，如果run是同步的那就永远都无法关闭&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;取而代之的是中断，但是中断并不代表停止，而是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;调用interrupt并不意味着立即停止目标线程的执行，而只是传递请求中断的消息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是比较靠谱的是在很多库中已经对中断做了处理：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在调用join、sleep、wai等阻塞返回后会抛出异常并擦除中断状态&lt;/li&gt;
  &lt;li&gt;在IO操作上阻塞时也会抛出异常并关闭流&lt;/li&gt;
  &lt;li&gt;在java.nio.channel.Selector上等待时也会立即返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果没有上面这些情况的话，调用中断不会对线程的执行造成半毛钱影响，如果你需要你的线程去响应中断，需要在合适的地方增加代码去判断并处理。&lt;/p&gt;

&lt;p&gt;想让线程按照我们的意愿停止已经很麻烦了，但是如果它运行的时候还抛出莫名其妙的异常就更加恼火了，不过幸好还有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface UncaughtExceptionHandler {
	void uncaughtException(Thread t, Throwable e);
}
&lt;/pre&gt;

&lt;p&gt;有时候我们需要在程序运行完成的时候做一些扫尾的工作，可以用关闭钩子来实现：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Runtime.getRuntime().addShutdownHook(new Thread(){
	public void run(){
    	// your code
    }
})
&lt;/pre&gt;

&lt;p&gt;只有JVM是正常结束的时候才会运行钩子，被暴力kill掉的时候就没机会执行了。既然讲到JVM的退出刚好可以看下Daemon和正常线程的区别：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM将退出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类似垃圾回收这些线程就得设置成守护线程，不能让他们影响了JVM的正常退出。在开启多线程的时候ThreadLocal真是一个神器，可以让很多信息的传递变得非常简单，具体可以看&lt;a href=&quot;http://wsztrush.github.io/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，线程不仅在效率还是体验方面都带来了巨大的提升，单并非多多益善，增加线程也同时会增加一些开销：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;上下文切换&lt;/li&gt;
  &lt;li&gt;内存同步（这个影响很小）&lt;/li&gt;
  &lt;li&gt;阻塞（竞争的同步可能需要操作系统的介入）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在大家已经很少new Thread().start();这么玩了，大部分都会用线程池来管理，下面接着看：&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;线程池&lt;/h2&gt;

&lt;p&gt;创建新线程也是有开销了，所以可以将线程缓存下来重复利用，在使用线程池时需要注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阀值&lt;/li&gt;
  &lt;li&gt;饱和策略&lt;/li&gt;
  &lt;li&gt;ThreadFactory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;平时用到的大部分线程池的底层都是ThreadPoolExecutor，在初始化时有几个关键的阀值需要注意：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;阀值&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;corePoolSize&lt;/td&gt;
      &lt;td&gt;在execute时如果当先线程数小于该值则直接创建新线程来运行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;maximumPoolSize&lt;/td&gt;
      &lt;td&gt;最大线程数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;keepAliveTime&lt;/td&gt;
      &lt;td&gt;Worker取任务的等待时长，超时后Worker就退出了&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果在execute的时候线程池已经满了，同时任务队列也满了，那么此时任务怎么办？这时候就饱和策略就要上场了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
&lt;/pre&gt;

&lt;p&gt;同时提供四种实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AbortPolicy：抛异常&lt;/li&gt;
  &lt;li&gt;CallerRunsPolicy：退回到调用者线程处理任务&lt;/li&gt;
  &lt;li&gt;DiscardOldestPolicy：抛弃最老任务&lt;/li&gt;
  &lt;li&gt;DiscardPolicy：抛弃&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后可以通过ThreadFactory来设置线程池中线程的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interfact ThreadFactory{
    Thread newThread(Runnable r);
}
&lt;/pre&gt;

&lt;p&gt;在execute时如果需要创建新的线程就会调用该方法。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;锁&lt;/h2&gt;

&lt;p&gt;多个线程同时跑为了保证结果的准确锁是少不了的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁的实现&lt;/li&gt;
  &lt;li&gt;死锁&lt;/li&gt;
  &lt;li&gt;活锁&lt;/li&gt;
  &lt;li&gt;减少锁竞争&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常用的锁有两种实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;synchronized&lt;/li&gt;
  &lt;li&gt;concurrent&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在之前concurrent要比synchronized快很多，但这个已经是很久之前的事情了，在synchronized的实现中通过偏向锁、轻量级锁优化了性能，而concurrent则是Doug Lea的作品。&lt;/p&gt;

&lt;p&gt;相比较来说各有优劣：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;synchronized缺点是不够灵活，但是你不需要费心释放锁；而concurrent使用很灵活，可以分别在不同的地方加锁、解锁，但是如果忘记解锁就悲剧了，一般用try-finally来做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外concurrent中实现了各种策略的锁：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;锁&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ReentrantLock&lt;/td&gt;
      &lt;td&gt;可重入独占锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ReentrantReadWriteLock&lt;/td&gt;
      &lt;td&gt;可重入读写锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Condition&lt;/td&gt;
      &lt;td&gt;条件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CountDownLatch&lt;/td&gt;
      &lt;td&gt;向下递减，到0时线程被唤醒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CyclicBarrier&lt;/td&gt;
      &lt;td&gt;有指定书目的线程await之后，一起开始执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FutureTask&lt;/td&gt;
      &lt;td&gt;先提交任务，在get时阻塞&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Semaphore&lt;/td&gt;
      &lt;td&gt;信号量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其实concurrent中核心是AQS框架，它将等待队列等操作都进行了封装，你只需要实现下面四个方法即可实现需要的锁：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;tryAcquire&lt;/li&gt;
  &lt;li&gt;tryAcquireShared&lt;/li&gt;
  &lt;li&gt;tryRelease&lt;/li&gt;
  &lt;li&gt;tryReleaseShared&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;锁用的比较多的时候就容易产生死锁，一般原因分为下面几类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁顺序死锁&lt;/li&gt;
  &lt;li&gt;资源死锁&lt;/li&gt;
  &lt;li&gt;线程饥饿死锁：在同一个线程池中执行有互相依赖的任务时需要注意&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以用&lt;strong&gt;jstack –l pid&lt;/strong&gt;来检测死锁。既然看到到了死锁，那就顺便看一下活锁：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不停地取出第一个任务，但是每次都会失败。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实活锁看起来就是代码写的太挫了…用锁的时候除了导致程序的活跃性问题，还可能导致性能问题，减少锁开销的一般方法为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;缩小同步的范围，快进快出&lt;/li&gt;
  &lt;li&gt;减少锁的粒度&lt;/li&gt;
  &lt;li&gt;锁分段&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用锁一定要慎重。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;多线程编程中还需要看看&lt;strong&gt;非阻塞算法&lt;/strong&gt;、&lt;strong&gt;Java内存模型&lt;/strong&gt;，而真正在写代码的时候能写好确实是一件非常不容易的事情，通常需要通过很多代码的磨练总结在使用各个工具时候的一些基本原则，才能慢慢顺手一些。&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Aug 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Java-Concurrency-In-Practice.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Java-Concurrency-In-Practice.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>代码简洁之道</title>
        <description>
</description>
        <pubDate>Wed, 19 Aug 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Clean-Code.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Clean-Code.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>通用设计法则</title>
        <description>&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;法则&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;80/20法则&lt;/td&gt;
      &lt;td&gt;集中精力在关键功能上（用户80%的时间在20%的功能上）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;无障碍操作&lt;/td&gt;
      &lt;td&gt;易读性、易操作性、简易性、包容性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;引导手册&lt;/td&gt;
      &lt;td&gt;说明型和比较型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;美即适用效应&lt;/td&gt;
      &lt;td&gt;美的设计能促进人们形成正面积极的态度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;功能可见性&lt;/td&gt;
      &lt;td&gt;门把手的例子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;对齐&lt;/td&gt;
      &lt;td&gt;统一性、整体性和相关性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;拟人形&lt;/td&gt;
      &lt;td&gt;吸引注意力和建立感情联结&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;原型&lt;/td&gt;
      &lt;td&gt;原型可以影响人们无意识的认知和根本的喜好&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;面积对齐&lt;/td&gt;
      &lt;td&gt;相当于是重心对齐&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;魅力偏见&lt;/td&gt;
      &lt;td&gt;人们认为有魅力的人更聪明、能干&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;娃娃脸偏见&lt;/td&gt;
      &lt;td&gt;天真无邪、诚实无助&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;亲近生命效应&lt;/td&gt;
      &lt;td&gt;减轻压力、提高专注度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;大教堂效应&lt;/td&gt;
      &lt;td&gt;高屋有助想象，低屋有助细节&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;意元集组&lt;/td&gt;
      &lt;td&gt;信息分模块以便于吸收&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;条件反射&lt;/td&gt;
      &lt;td&gt;把刺激物跟身体或情感的无意识反应联结起来&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;意向整合&lt;/td&gt;
      &lt;td&gt;把一组各自独立的元素视为一个整体图案&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;认知失调&lt;/td&gt;
      &lt;td&gt;在态度、思想、信念中寻找一致性（创造失调来进行引导）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;颜色&lt;/td&gt;
      &lt;td&gt;数量、组合、饱和度、特征&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;共同命运&lt;/td&gt;
      &lt;td&gt;往同一个方向移动的元素会让人感觉他们之间的关联性更强&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;比较&lt;/td&gt;
      &lt;td&gt;苹果与苹果比、单一背景比较、基准比较&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;确认&lt;/td&gt;
      &lt;td&gt;重要或无法返回的操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;一致性&lt;/td&gt;
      &lt;td&gt;系统相似的部分用一致性的方法表现&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;恒常性&lt;/td&gt;
      &lt;td&gt;相同的东西从不同角度看起来可能是一样的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;约束&lt;/td&gt;
      &lt;td&gt;实体约束和心理约束，约束减少错误&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;曲线偏见&lt;/td&gt;
      &lt;td&gt;棱角有助吸引注意力和创新，曲线有助于正面情绪和美学印象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;控制&lt;/td&gt;
      &lt;td&gt;控制程度应该和熟练程度相关&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;整合&lt;/td&gt;
      &lt;td&gt;能够提供与大环境最接近的效果往往最佳，也最容易取得成功&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;成本效益&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;防卫空间&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;深度处理&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;集体式设计&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;偏好路径&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;开发周期&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;入口&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;错误&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;预期效应&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;曝光效应&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;面子主义比例&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;安全系数&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;反馈循环&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;斐波拉契数列&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;正负形关系&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;费茨定律&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;五帽架&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Sun, 09 Aug 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/09/Universal-Principles-Of-Design.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/09/Universal-Principles-Of-Design.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>libsvm使用总结</title>
        <description>&lt;p&gt;##&lt;/p&gt;

</description>
        <pubDate>Thu, 06 Aug 2015 00:00:00 +0800</pubDate>
        <link>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2015/08/06/Libsvm.html</link>
        <guid isPermaLink="true">/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/2015/08/06/Libsvm.html</guid>
        
        
        <category>机器学习</category>
        
      </item>
    
      <item>
        <title>编译原理（一）</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s3392161.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;词法分析&lt;/h2&gt;

&lt;p&gt;编译器的目的是根据源码生成可以执行的文件，想一步到位完全不靠谱，可以先进行分词处理，那么这就是词法分析要完成的工作了！&lt;/p&gt;

&lt;p&gt;用正则表达是来描述词法规则是比较简单的，而用状态机进行匹配则是比较迅速的，那么比较重要的就是在他们之间的互相转换：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;概念&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;NFA&lt;/td&gt;
      &lt;td&gt;不确定自动机，从当前状态根据字符转移的时候，下一个状态是不确定的&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DFA&lt;/td&gt;
      &lt;td&gt;确定自动机，状态转移时下一个状态时确定的&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;来看一个NFA的例子，对于&lt;strong&gt;(a|b)*abb&lt;/strong&gt;这样的词，对应的NFA为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在遍历的过程中顺便更新状态就可以了，用代码来描述一下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
S = &amp;epsilon;-closure(s0); // 注意：这里的S是个集合
c = nextChar();
while(c != eof){
    S = &amp;epsilon;-closure(move(S,c));// 状态转移+空转移
    c = nextChar();
}
if(S &amp;cap; F != &amp;empty;) return &quot;yes&quot;;
eles return &quot;no&quot;;
&lt;/pre&gt;

&lt;p&gt;看起来NFA的模拟方式效率并不高，而且代码写起来也有点小复杂，而DFA则完全不一样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
s = s0;
c = nextChar();
while(c != eof){
    s = move(s, c);
    c = nextChar();
}
if(s在F中) return &quot;yes&quot;;
else return &quot;false&quot;;
&lt;/pre&gt;

&lt;p&gt;是不是简单了很多？但是也更显然，NFA与正则之间的关系更加直观，那么先来看从正则到NFA的转换：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用这种方式从&lt;strong&gt;(a|b)*a&lt;/strong&gt;得到的NFA为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然DFA相对于NFA来说是有优势的，那么如果有一个方法能将NFA转换为DFA，那么可以一劳永逸。这里&lt;strong&gt;子集构造法&lt;/strong&gt;还是相当的直观的的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
一开始，&amp;epsilon;-closure(s0)是Dstates中唯一状态，且它未加标记;
while(在Dstates中一个未加标记状态T){
    给T加上标记;
    for(每个输入符号a){
        U = &amp;epsilon;-closure(move(T,a));
        if(U不在Dstates中)
            将U加入到Dstates中，且不加标记;
        Dtran[T,a] = U;
    }
}
&lt;/pre&gt;

&lt;p&gt;其中的：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ε-closure(s)&lt;/td&gt;
      &lt;td&gt;能够从NFA的状态s开始只通过ε转换到达的NFA状态集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ε-closure(T)&lt;/td&gt;
      &lt;td&gt;能够从T中某个NFA状态s开始只通过ε转换到达的NFA状态集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;move(T,a)&lt;/td&gt;
      &lt;td&gt;能够从T中某个状态s出发通过标号a的转换到达的NFA状态的集合&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那么现在就有一条路径了：&lt;strong&gt;正则-&amp;gt;NFA-&amp;gt;DFA&lt;/strong&gt;也太累了，有没有&lt;strong&gt;正则-&amp;gt;DFA&lt;/strong&gt;这样一条通路？答案是肯定的，首先根据正则构造出抽象语法树：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
初始化Dstates,使之只包含未标记的状态firstpos(n0),其中n0是r(#)的抽象语法树的根节点;
while(Dstates中存在未标记的状态S){
    标记S;
    for(每个输入符号a){
        令U为S中和a对应的所有位置p的followpos(p)的并集;
        for(U不在Dstates中)
            将U作为未标记的状态加入到Dstates中;
        Dtran[S,a] = U;
    }
}
&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;定义&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;nullable(n)&lt;/td&gt;
      &lt;td&gt;节点n的子表达式的语言中包含ε&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;firstpos(n)&lt;/td&gt;
      &lt;td&gt;以节点n为根的子表达式中第一个符号的位置的集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lastpos(n)&lt;/td&gt;
      &lt;td&gt;以节点n为根的子表达式中最后一个符号的位置的集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;followpos(p)&lt;/td&gt;
      &lt;td&gt;可能出现在位置p后面的位置的集合&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其实背后的底层原理与从NFA到DFA还是比较相似的，只不过是用不同的构造方式来做。DFA确实要比NFA好处理一些，但并不是说生成DFA之后就没事了，其中的状态数可以压缩：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据接收、非接收状态分为两组；&lt;/li&gt;
  &lt;li&gt;遍历分组、字符，如果同一组内的状态根据该字符到达了不同的组，那么将继续将当前的分组进行分割；&lt;/li&gt;
  &lt;li&gt;重复执行步骤2直到没有变化；&lt;/li&gt;
  &lt;li&gt;每个分组中选择一个代表状态，重新构造DFA，最小化完成；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以证明&lt;strong&gt;最小化状态&lt;/strong&gt;数的DFA唯一性，然而最小化的过程更加容易让我们去理解状态机的本质。来个最小化状态数的例子：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;语法分析&lt;/h2&gt;

&lt;p&gt;语法分析器从词法分析器得到TOKEN流，&lt;strong&gt;生成语法分析树&lt;/strong&gt;或者&lt;strong&gt;抽象语法树&lt;/strong&gt;，方便进一步地处理。预发处理的规则通常是用&lt;strong&gt;上下文无关文法&lt;/strong&gt;来描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;E → E+T|T // 从E+T可以推导出E，也可以从T推导出E
T → T*F|F
F → (E)|id&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于一个TOKEN流，语法分析器的目的是就是把这些规则“套”上去，从而知道输入的内容是什么样的结构，而输出可能是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;左边是分析语法树，右边是抽象语法树，比较而言抽象语法树更简单一些，而且便利起来更加容易。如果通过一个语法在推导某个式子的时候可以得到两个不同的语法树，那么说明这种语法是有二义性的，比如&lt;strong&gt;if E1 then if E2 then S1 else S2&lt;/strong&gt;中的else就不知道应该对应哪个if，那么进行修改：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;消除二义性好像没有什么万能的方法，但是消除左递归却是有的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
按照某个顺序将非终结符号排序为A1、A2....
for(从1到n的每个i){
    for(从1到i-1的每个j){
        将每个形如Ai&amp;rarr;Aj&amp;upsih;的产生式替换为产生式组Ai&amp;rarr;&amp;delta;1&amp;upsih;|&amp;delta;2&amp;upsih;|...
        其中Aj&amp;rarr;&amp;delta;1|&amp;delta;2|....是所有Aj的产生式
    }
    消除Aj产生式之间的立即左递归
}
&lt;/pre&gt;

&lt;p&gt;是不是有点像拓扑排序？有了这些规则那么就需要写程序来按照其描述的逻辑进行处理，说白了就是用程序的结构去模拟预发的结构：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
void A(){
    选择A的一个产生式，A&amp;rarr;X1X2X3...
    for(i = 1 to k){
        if(Xi是一个非终结符号)
            调用过程Xi();
        else if(Xi等于当前输入符号a)
            读入下一个输入符号
        else
            /* 发现错误，需要回溯 */
    }
}
&lt;/pre&gt;

&lt;p&gt;典型的&lt;strong&gt;自顶向下&lt;/strong&gt;分析的方法，用递归来实现很容易与语法规则对应起来，但是在出现错误的时候就退回重试显示效率低下的处理方式。在知道下一个TOKEN是什么的情况下就知道用那个产生式，那么就不需要那么多无谓的尝试了，这就是&lt;strong&gt;LL(1)&lt;/strong&gt;的想法，需要两个集合：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;集合&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FIREST(α)&lt;/td&gt;
      &lt;td&gt;可以由α推导得到的串的终结符的集合&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FOLLOW(A)&lt;/td&gt;
      &lt;td&gt;在某些句型中紧跟在A右边的终结符号的集合&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那么之后在终结符号A处使用FOLLOW(A)中的产生式来进行处理即可，这时候非递归的写法也是非常简单的。其实构造FIRST和FOLLOW的过程还是挺简单的，不再赘述。&lt;/p&gt;

&lt;p&gt;下面接着来看&lt;strong&gt;自底向上&lt;/strong&gt;的分析过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这种方式中我们并不是从“根”出发的，而是在看到能处理的部分就把它处理掉，可以用栈来实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;比较麻烦的是，我们不知道当前有哪些是可以处理的，按道理来说每次在需要的时候去遍历产生式并递归来做也是可以搞定的，但是不免会有很多的遍历是重复劳动，那么就需要预处理了。对于表达式&lt;strong&gt;A→XYZ&lt;/strong&gt;，如果考虑位置的话有四种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A→.XYZ&lt;/li&gt;
  &lt;li&gt;A→X.YZ&lt;/li&gt;
  &lt;li&gt;A→XY.Z&lt;/li&gt;
  &lt;li&gt;A→XYZ.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们将这些称为项，由一个语法的产生式对应的过个产生式中有一些是等价的，将他们放在同一个集合（项集）中，比如对于语法 ：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;E’→E&lt;/li&gt;
  &lt;li&gt;E→E+T|T&lt;/li&gt;
  &lt;li&gt;T→T*F|F&lt;/li&gt;
  &lt;li&gt;F→(E)|id&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成项集之后，在遇到一个TOKEN的情况下就知道下个项集是什么了，这样我们根据上面的语法就得到了一个状态图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;项集闭包的构造方法比较简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
SetOfItems CLOSURE(I){
    J = I;
    repeat:
        for(J中的每个项A→α.Bβ)
            for(G的每个产生式B→γ)
                if(项B→.γ不在J中)
                    将B→.γ加入J中;
    until 在某一轮中没有新项被加入到J中;
    return J;
}
&lt;/pre&gt;

&lt;p&gt;有了状态的定义，那么接下来需要定义状态之间的转换：&lt;strong&gt;GOTO(I,X)&lt;/strong&gt;表示了形如A→α.Xβ所在的项集到A→αX.β的转换，构造方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
void items(G'){
    C = {CLOSURE([S'→.S])};
    repeat
        for(C中的每个项集I)
            for(每个文法符号X)
                if(GOTO(I,X)非空且不在C中)
                    将GOTO(I,X)加入C中;
    until 在某一轮中没有新的项集被加入到C中;
}
&lt;/pre&gt;

&lt;p&gt;有了上面这些，我们可以开始构造一个&lt;strong&gt;SLR(1)&lt;/strong&gt;语法分析表了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果[A→α.aβ]在Ii中并且GOTO(Ii,a)=Ij，那么将ACTION[i,a]设置为“&lt;strong&gt;移入j&lt;/strong&gt;”;&lt;/li&gt;
  &lt;li&gt;如果[A→α.]在Ii中，那么对于FOLLOW(A)中所有的a，将ACTION[i,a]设置为规约“&lt;strong&gt;规约A→α&lt;/strong&gt;”;&lt;/li&gt;
  &lt;li&gt;如果[S’→S.]在Ii中，那么将ACTION[i,$]设置为“&lt;strong&gt;接受&lt;/strong&gt;”;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在分析程序中用一个栈来记录当前看到的状态，然后根据ACTION来进行操作即可。&lt;/p&gt;

&lt;p&gt;在LR(0)中能规约的时候就规约，这样做很不科学，但是在有冲突的时候好像没有别的方法，只能“向前看”。&lt;strong&gt;规范LR&lt;/strong&gt;充分地利用了向前看符号，利用一个很大的项集来工作，每个项的格式如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;形式为[A→α.Bβ,a]，前半部分不变，后半部分为向前看符号&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;构造方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
SetOfItems CLOSURE(I){
    repeat
        for(I中的每个项[A→α.Bβ,a])
            for(FIRST(βa)中的每个终结符号b)
                将[B→.γ,b]加入到集合I中
    until 不能向I中加入更多的项
    return I;
}
SetOfItems GOTO(I,X){
    将J初始化为空集;
    for(I中的每个项[A→α.Xβ,a])
        将项[A→αX.β,a]加入到集合J中
    return CLOSURE(J);
}
void items(G'){
    将C初始化为{CLOSURE}({[S'→.S,$]});
    repeat
        for(C中的每个项集I)
            for(每个文法符号X)
                if(GOTO(I,X)非空且不在C中)
                    将GOTO(I,X)加入到C中;
    until 不再有新的项集加入到C中;
}
&lt;/pre&gt;

&lt;p&gt;对于文法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;S’→S&lt;/li&gt;
  &lt;li&gt;S→C C&lt;/li&gt;
  &lt;li&gt;C→c C | d&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;得到的规范LR项集的状态图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时构造分析表的方法如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果[A→α.aβ，b]在Ii中且GOTO(Ii,a)=Ij，那么将ACTION[i,a]设置为“移入j”;&lt;/li&gt;
  &lt;li&gt;如果[A→α.,a]在Ii中且A≠S’，那么将ACTION[i,a]设置为“规约A→α.”;&lt;/li&gt;
  &lt;li&gt;如果[S’→S,$]在Ii中，那么将ACTION[i,$]设置为“接受”;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方式和SLR的运行方式类似，不再赘述！&lt;/p&gt;

&lt;p&gt;向前看LR(&lt;strong&gt;LALR&lt;/strong&gt;)基于LR(0)项集族，和基于LR(1)项的典型语法分析器相比，状态要少很多，通过想LR(0)项中小心地引入向前看符号，我们使用LALR方法处理的文法比使用SLR处理的文法更多，同时构造得到的语法分析表并不比SLR语法分析表大，通常情况下LALR方法是最合适的选择。&lt;/p&gt;

&lt;p&gt;可以将LALR看做是将LR(1)中有相同核心项的项集合并，那么按照这种思路就可以从LR(1)构造得到LALR的分析表和GOTO，但是耗费空间巨大，基本思想为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将LR(1)中相同核心项集合并，在新的项集族上计算GOTO，进而生成分析表。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总共有三种冲突：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;规约-规约&lt;/li&gt;
  &lt;li&gt;规约-移入（不可能出现）&lt;/li&gt;
  &lt;li&gt;移入-移入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后跟上面一样在合并完的结果上构造语法分析表，如果出现冲突则说明该文法不是LALR(1)的。从LR(1)合并得到LALR(1)需要较大的内存，另一种高效的思路是从LR(0)添加向前看符号，添加途径有两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;自发&lt;/li&gt;
  &lt;li&gt;传播&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第二种方式会将源头所有的向前看符号都“传播”给目标，这里有一个简单的办法来区分自发和传播：令#为一个不在当前文法中的符号，对于LR(0)项集I的内核K以及一个文法符号X：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
for(K中的每个项A→α.β){
    J:=CLOSURE({[A→α.β,#]});
    if([B→ϒ.Xδ,a]在J中，并且a不等于#)
        断定GOTO(I,X)中的项B→ϒ.Xδ的向前看符号a是自发生的
    if([B→ϒ.Xδ,#]在J中)
        断定向前看符号从I中的项A→α.β传播到了GOTO(I,X)中的项B→ϒX.δ上
}
&lt;/pre&gt;

&lt;p&gt;下面来看构造LALR(1)项集族内核的计算方法(输入增广文法G)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;构造G的LR(0)项集族的内核&lt;/li&gt;
  &lt;li&gt;对每个内核和文法符号通过上面方法计算自发、传播&lt;/li&gt;
  &lt;li&gt;初始化表格，表中给出每个内核项的向前看符(最初每个项的向前看符只有自发产生的符号)&lt;/li&gt;
  &lt;li&gt;在扫描中根据传播的关系，从源头复制向前看符集合到目标项，不停地扫描知道没有新的向前看符号被传播为止&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于下面文法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;S’→S
S→L=R|R
L→*R|id
R→L&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;得到的向前看符号传播和向前看符号的计算结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Compiler-12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到目前为止我们总是在构建ACTION出现冲突的时候说：这不是XXX文法。但是反过来想一下其实二义文法在描述的时候还是非常简单的，我们可以通过一些额外的手段来消除二义（在ANTLR中非常明显）。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;到这里基本上可以随意搞Lexer和Parser了，可以看&lt;a href=&quot;http://book.douban.com/subject/10482195/&quot;&gt;编程语言实现模式来&lt;/a&gt;来熟悉一下实际的代码是什么样的（可惜这本书只有LL的）!&lt;/p&gt;
</description>
        <pubDate>Sat, 01 Aug 2015 00:00:00 +0800</pubDate>
        <link>/dsl/2015/08/01/Compiler-Theory.html</link>
        <guid isPermaLink="true">/dsl/2015/08/01/Compiler-Theory.html</guid>
        
        
        <category>dsl</category>
        
      </item>
    
      <item>
        <title>Jstorm</title>
        <description>&lt;p&gt;实际上做过的大部分的系统很难算是分布式系统，处理的流程一般是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将请求随机交给一台机器；&lt;/li&gt;
  &lt;li&gt;在这台机器上面进行处理，如果处理量比较大就开多线程；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在一台机器上面去开多线程处理感觉又回到了古老的单机作战的时代，扩展和性能都是有上限的，那么能不能将一个任务交给不同的机器来协同完成？&lt;/p&gt;

&lt;p&gt;数据处理方面根据不同的场景大致可以分为下面两种场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;离线分析&lt;/strong&gt;：特点是查询单一、数据加工过程也单一，用Hadoop来解决；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;在线分析&lt;/strong&gt;：特点是查询随机，玩的就是索引，那么QPS必然不会很高，而且需要的都是好机器，可以用阿里云的ADS来解决；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看是天下太平，但真正用的时候还是会有问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;像ADS这样的产品，可以在一份静态的数据上面方便地进行各种查询，但是新增、更新操作特别频繁的情况下，索引的重构可能会存在瓶颈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实时性也是数据处理的一个目标，记得之前在压测的时候在Solr实时更新索引上死得很惨，所以需要考虑更加有效、低成本地解决方式。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;集群架构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;nimbus&lt;/strong&gt;：分发任务、任务、监控集群运行状态；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;supervisor&lt;/strong&gt;：监听nimbus的指令，接受分发代码、任务并执行；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;worker&lt;/strong&gt;：真正执行的进程；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;task&lt;/strong&gt;：任务；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;executor&lt;/strong&gt;：一个线程，用来轮询task中的接口；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在jstorm中运行的程序就是一个&lt;strong&gt;topology&lt;/strong&gt;，说白了就是一个jar包，可以在nimbus节点使用命名把jar包提交给集群，那么这个jar包中的程序的结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;spout&lt;/strong&gt;：源头；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;bolt&lt;/strong&gt;：处理器；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;tuple&lt;/strong&gt;：数据；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：任务分发、启动的流程可以看&lt;a href=&quot;http://xumingming.sinaapp.com/647/twitter-storm-code-analysis-topology-execution/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在分布式系统中数据都准确性是最难的，通常在检查消息消费失败的时候重试。而在Jstorm里面中就更为复杂，一个消息从spout发给bolt，而一个bolt可能发给多个bolt，这样就构成了一棵树形结构，在jstorm中用&lt;strong&gt;acker&lt;/strong&gt;机制来检测消息是否失败：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显然这是一个随机算法，但是发生错误的概率非常小！但是，如果真的出错那就蛋疼了，做个开关或者接口让程序开发者来自己实现acker不好么？&lt;/p&gt;

&lt;p&gt;在并发编程中经常要碰到去处理资源竞争，处理的方式基本上两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁&lt;/li&gt;
  &lt;li&gt;根据所需要的资源进行分组&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用第2种方式，将不同的任务分发给不同的节点来处理，这样就可以减少很多的竞争、简化处理的代码、容易提高性能，在jstorm提供了丰富&lt;strong&gt;grouping&lt;/strong&gt;方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;随机分组&lt;/li&gt;
  &lt;li&gt;根据某个字段分组&lt;/li&gt;
  &lt;li&gt;广播&lt;/li&gt;
  &lt;li&gt;直接分组&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说到消息分组，可能看起来是在&lt;strong&gt;emit&lt;/strong&gt;的时候就直接发出去了，但事实上并不是这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建tuple；&lt;/li&gt;
  &lt;li&gt;worker将目标taskId+tuple放到待发送队列；&lt;/li&gt;
  &lt;li&gt;由一个单独的线程来负责将消息发送给对应的任务处理；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外在jstorm中提供了一些更高级的抽象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CoordinatedBolt&lt;/li&gt;
  &lt;li&gt;Transactional Topology&lt;/li&gt;
  &lt;li&gt;DRPC&lt;/li&gt;
  &lt;li&gt;Trident&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了做到&lt;strong&gt;处理且仅处理一次&lt;/strong&gt;的目的，并且不能牺牲掉并发性，那么Transactional Topology的做法是将一个batch的计算分为两个阶段来完成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;processing&lt;/strong&gt;：多个batch并行处理；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;commit&lt;/strong&gt;：一个一个地提交，batch之间保持强有序；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而Trident则是一个更方便、可靠的接口~&lt;/p&gt;

&lt;p&gt;附jstorm中常用参数设置：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.message.timeout.secs&lt;/td&gt;
      &lt;td&gt;超时时间，如果超时则认为失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.max.task.parallelism&lt;/td&gt;
      &lt;td&gt;最大并行度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.state.synchronization.timeout.secs&lt;/td&gt;
      &lt;td&gt;组件同步状态源的最大超时时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.max.spout.pending&lt;/td&gt;
      &lt;td&gt;缓存spout发送的tuple数，超出会阻塞&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.executor.receive.buffer.size&lt;/td&gt;
      &lt;td&gt;executor线程的接收队列大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.executor.send.buffer.size&lt;/td&gt;
      &lt;td&gt;executor线程的发送队列大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.receiver.buffer.size&lt;/td&gt;
      &lt;td&gt;worker接收线程缓存消息的大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.transfer.buffer.size&lt;/td&gt;
      &lt;td&gt;worker进程中向外发送消息的缓存大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;storm.messaging.netty.max_wait_ms&lt;/td&gt;
      &lt;td&gt;最大等待时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;storm.messaging.netty.min_wait_ms&lt;/td&gt;
      &lt;td&gt;最小等待时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.ackers&lt;/td&gt;
      &lt;td&gt;ackaer任务数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;drpc&quot;&gt;DRPC&lt;/h2&gt;

&lt;p&gt;互联网中用户的操作通常是轻量级的，插一下数据库、更新一下缓存就搞定了，但是对于仓库管理这种系统很多操作比较重，有些任务可能需要遍历数据库中的表才能完成，而Distributed RPC可能是提高性能、降低风险的一个途径。&lt;/p&gt;

&lt;p&gt;用Jstorm来搞DRPC的过程如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
DRPCClient client = new DRPCClient(&quot;drpc-host&quot;, 3772);
String result = client.execute(&quot;reach&quot;, &quot;http://twitter.com&quot;);
&lt;/pre&gt;

&lt;p&gt;客户端给DRPC服务器发送要执行的方法名称以及参数，实现了这个函数的topology使用DRPCSpout从DRPC服务器接收函数调用流。每个函数调用被DRPC服务器标记了一个唯一的id。这个topology然后计算结果，在topology的最后一个叫做ReturnResults的bolt会将调用的结果发送给DRPC服务器。&lt;/p&gt;

&lt;p&gt;之前想过可能用一些更简单的方法来试下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在spout的节点提供一个rpc服务；&lt;/li&gt;
  &lt;li&gt;在调用这个服务的时候发送消息给bolt，然后在bolt中完成任务的分发及处理；&lt;/li&gt;
  &lt;li&gt;在spout中统计是否所有的消息都成功消费；&lt;/li&gt;
  &lt;li&gt;返回数据；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样弄会有一些问题，但是感觉没有强依赖于jstorm，而仅仅是用它的消息分发机制就可以了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据流式处理&lt;/h2&gt;

&lt;p&gt;在流式处理的过程中，每次面对的都是单个的记录，而事实上统计都是有状态的，那么：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以把状态保存在本地；&lt;/li&gt;
  &lt;li&gt;可以把状态保存在hbase、ldb等外部的存储；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;保存在本地的内存中速度会很快，也没有序列化等开销，而且通常流处理中时效性要求是比价强的，过去很久的数据基本上就不会再次处理。所以：流玩的好不好，就看本地缓存用的好不好了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;很多语言从一开始就在考虑如何简单地去实现并发编程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;erlang&lt;/li&gt;
  &lt;li&gt;golang&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而我们这些作为老Java程序猿只能是自己去东拼西凑地搞出一个来简化分布式系统中的开发成本。现在考虑下来jstorm应该是个不错的选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;运行一个固定结构的topology；&lt;/li&gt;
  &lt;li&gt;在topology上面可以动态地加载、编译我们要执行的脚本；&lt;/li&gt;
  &lt;li&gt;在spout、bolt中调用脚本中的方法；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样也许我们可以更低的成本来享受分布式带来的好处~~&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/31/Jstorm.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/31/Jstorm.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
