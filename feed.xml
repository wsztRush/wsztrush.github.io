<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 14 Jun 2015 21:20:13 +0800</pubDate>
    <lastBuildDate>Sun, 14 Jun 2015 21:20:13 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>VIM</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/VIM-LOGO.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很早之前就知道VIM很厉害，不过作为一个Java攻城狮，用起来实在是不方便，完全没有Eclipse或者IDEA写代码顺畅，比如代码提示等（怀疑自己配置有问题-.-!）。最近对golang非常感兴趣，然而默认的IDE实在是太丑了，所以决心把VIM捡起来。&lt;/p&gt;

&lt;p&gt;周围用Emacs的同事越来越多，但是简单用了几次，总觉得不怎么顺手，也就不了了之。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;插件管理器&lt;/h2&gt;

&lt;p&gt;相比现代编辑器，VIM缺乏默认的插件管理功能，之前在配置时不停地从网上收集插件，然后粘贴到对应的目录下。这个过程相当地考验耐心，以及人品。&lt;/p&gt;

&lt;p&gt;最近无意间发现了一个插件管理工具：&lt;strong&gt;vundle&lt;/strong&gt;。玩了一下感觉还不错，首先从github上下载:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后修改&lt;strong&gt;vimrc&lt;/strong&gt;文件：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
set nocompatible &quot;关闭兼容模式
filetype off &quot;
set rtp+=~/.vim/bundle/Vundle.vim &quot; 写自己安装的目录
call vundle#begin() &quot;

Bundle 'gmarik/Vundle.vim' &quot; 插件列表
&quot; ... 插件列表

call vundle#end() &quot;
filetype plugin indent on
&lt;/pre&gt;

&lt;p&gt;如果是&lt;strong&gt;vim-scripts&lt;/strong&gt;下面的插件直接写名字就好了，否则为&lt;strong&gt;用户名/插件&lt;/strong&gt;的格式，使用时用到的几个命令如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleList&lt;/td&gt;
      &lt;td&gt;列举出列表中(.vimrc中)配置的所有插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall&lt;/td&gt;
      &lt;td&gt;安装列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall!&lt;/td&gt;
      &lt;td&gt;更新列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch foo&lt;/td&gt;
      &lt;td&gt;查找foo插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch! foo&lt;/td&gt;
      &lt;td&gt;刷新foo插件缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean!&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;写代码之前&lt;/h2&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Golang入门</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;环境搭建&lt;/h2&gt;

&lt;p&gt;因为我仅仅打算在ubuntu上面进行golang的开发，所以其他的系统后面用过了再来补充！配置来说相当容易：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载golang的包解压安装，如果官网上的访问不到就到&lt;a href=&quot;http://www.golangtc.com/&quot;&gt;golang中国&lt;/a&gt;找个版本下载&lt;/li&gt;
  &lt;li&gt;在/etc/profile中配置&lt;strong&gt;PATH&lt;/strong&gt;、&lt;strong&gt;GOROOT&lt;/strong&gt;、&lt;strong&gt;GOPATH&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;配置你的IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面就开始GOLANG的学习。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基础语法&lt;/h2&gt;

&lt;p&gt;按照惯例，来看Hello World代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
package main

import &quot;fmt&quot;

func main(){
    fmt.Println(&quot;Hello World&quot;);
}
&lt;/pre&gt;

&lt;p&gt;使用&lt;strong&gt;go run hello.go&lt;/strong&gt;即可执行，也可以使用&lt;strong&gt;go build hello.go&lt;/strong&gt;打包完成之后在运行，所有的命令作用如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;build&lt;/td&gt;
      &lt;td&gt;用于测试编译&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clean&lt;/td&gt;
      &lt;td&gt;移除当前源码包里面编译生成的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;env&lt;/td&gt;
      &lt;td&gt;环境变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fix&lt;/td&gt;
      &lt;td&gt;修复以前老版本的代码到新版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fmt&lt;/td&gt;
      &lt;td&gt;代码格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;generate&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get&lt;/td&gt;
      &lt;td&gt;动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;install&lt;/td&gt;
      &lt;td&gt;生成结果文件(可执行文件或者.a包)，把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;list&lt;/td&gt;
      &lt;td&gt;列出当前全部安装的package&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;run&lt;/td&gt;
      &lt;td&gt;编译并运行Go程序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tool&lt;/td&gt;
      &lt;td&gt;运行对应的工具类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;version&lt;/td&gt;
      &lt;td&gt;版本号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;码代码最基本的是变量和常量，在Go中的定义方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var a string = &quot;initial&quot;  /* 变量 */
const s string = &quot;initial&quot; /* 常量 */
&lt;/pre&gt;

&lt;p&gt;另外一些基本的控制结构也基本一致，简单来看就是省略了不少的括号：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// FOR
for i &amp;lt;= 3
for i := 1; i &amp;lt;= 3; i++
for
// IF
if 8%4 == 0
if num := 9; num &amp;lt; 0
// SWITCH
switch time.Now().Weekday() {
    case time.Saturday, time.Sunday:
    default:
}
&lt;/pre&gt;

&lt;p&gt;Go中的集合用起来感觉跟Python中的有点像：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// ARRAY:数组
var a [5]int
b := [5]int{1, 2, 3, 4, 5}
var c [2][3]int

// SLICES:跟数组很像，不过区间操作非常方便
s := make([]string, 10)
l := s[2:5]
l := s[2:]
l := s[:5]

// RANGE:更方便地遍历，数组的话返回下标和值，MAP返回KEY、VALUE
for _,num := nums {
    sum += num;
}

// MAP:这个没什么好说的
m := make(map[string]int)
m[&quot;a&quot;] = 1
m[&quot;b&quot;] = 2
&lt;/pre&gt;

&lt;p&gt;在Go中定义方法也是比较奇葩的语法，用过的其他语言大部分把返回值写在前面，而它是写在后面，不过应该也没有谁优谁劣，而且在Go中方法可以返回多个值(尤其是在后面会用来返回错误)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func vals() (int, int) {// 普通函数：a, b := vals()
    return 1, 2;
}
func sum(nums ...int) {// 可变参数：sum(1, 2)   sum(1, 2, 3)
}
func zeroptr(iptr *int) {// 参数类型为指针
    *iptr = 0
}
func intSeq() func() int {// 闭包
    i := 0
    return func() int {
        i += 1
        return i
    }
}
&lt;/pre&gt;

&lt;p&gt;在Go中所有的面向对象就是&lt;strong&gt;struct&lt;/strong&gt;了，是不是感觉有点简单？或者有点low？另外在Go中定义了一个奇葩的&lt;strong&gt;interface&lt;/strong&gt;，感觉有点像是一个方法的集合：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
type method interface {
    output();
}

type person struct {
    name string
    age  int
}

func (p *person) output(){// 定义方法，再次吐槽：是不是跟Python很像
    fmt.Println(p.name, p.age);
}

func f(m method) { // 为不同对象定义相同的方法，用这个来实现泛型的话，额~~
	fmt.Println(m);
    m.output();
}

func f1(arg int) (int, error) {
    return -1, errors.New(&quot;i can't work！&quot;); // 返回错误
}

// 调用方法
fmt.Println(person{&quot;Bob&quot;, 20})
fmt.Println(person{name: &quot;Alice&quot;, age: 30})
&lt;/pre&gt;

&lt;p&gt;在Go中比较吸引人的应该就是&lt;strong&gt;goroutines&lt;/strong&gt;，面向并发的语言自然要最大程度的简化对应的代码才算合格。在Go中任意一个方法都可以使用&lt;strong&gt;go&lt;/strong&gt;这个关键字来当做一个协程进行处理：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;go func(“abc”)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仅仅这样是不够的，在Go中又提供了&lt;strong&gt;channel&lt;/strong&gt;用来做消息传递，这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;消息传递&lt;/li&gt;
  &lt;li&gt;共享内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种方式在Go里面就凑齐了，另外&lt;strong&gt;select&lt;/strong&gt;也大大简化了IO时候的操作，代码减了多少并不重要，关键是代码与其含义更加地贴近：&lt;/p&gt;

&lt;pre class=&quot;preetyprint&quot;&gt;
messages := make(chan string)
messages := make(chan string, 2)

messages &amp;lt;- &quot;buffered&quot; // 写入
msg := &amp;lt;-messages // 读取

select {
    case msg := &amp;lt;-messages:
        fmt.Println(&quot;received message&quot;, msg)
    default:// 这样就不会阻塞了
        fmt.Println(&quot;no message received&quot;)
}
&lt;/pre&gt;

&lt;p&gt;总是感觉select与switch很像，不仅仅是写法上面，另外连TimeOut的写法能很简单、粗暴地搞定：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
select {
    case res := &amp;lt;-c1:
        fmt.Println(res)
    case &amp;lt;-time.After(time.Second * 1):
        fmt.Println(&quot;timeout 1&quot;)
    }
&lt;/pre&gt;

&lt;p&gt;用这种方式能设置延迟，在需要重复的场景下可以用&lt;strong&gt;ticker := time.NewTicker(time.Millisecond * 500)&lt;/strong&gt;来解决。&lt;/p&gt;

&lt;p&gt;在Go语言中不支持传统的try-catch-finally这种异常机制，因为Go的设计者认为可能程序员经常会滥用，所以在大部分的情况都通过返回多个值、其中一个为&lt;strong&gt;ERROR&lt;/strong&gt;的办法来处理，只有在真正异常的情况下才使用Go的Exception机制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;defer&lt;/strong&gt;：为函数添加结束时执行的语句&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;panic&lt;/strong&gt;：非常严重的不可恢复的错误&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;recover&lt;/strong&gt;：从错误中恢复&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&quot;preetyprint&quot;&gt;
func f() (result int) {// 返回值为1，只有defer执行后才有效
    defer func() {
        result++
    }()
    return 0;
}
panic(&quot;problem&quot;);// 在这个地方程序就挂掉了

func a(){
    panic(&quot;a---error&quot;);
}
func b(){
    panic(&quot;b---error&quot;);
}
func(){
    def func(){
        if r:= recover(); r != nil {
            log.Printf(&quot;caught: %v&quot;, r);
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;用recover的方法有点像缩水版的try-catch，简单把Go的语法过了一遍，总体的感觉就是简单、面向工程开发，没有很多的废话，也没有太多学术上很有用、工程上用的不多的细节。基本语法的例子都可以在&lt;a href=&quot;https://gobyexample.com/&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;工程开发&lt;/h2&gt;

</description>
        <pubDate>Tue, 09 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Spring</title>
        <description>&lt;p&gt;如今作为一个Java程序员，如果没用过Spring的话基本上没法混了~ 这里就不再啰嗦如何如何从EJB走到了Spring(毕竟咱也没经历过那些个艰难的时代)，直接来看它带给我们哪些东西：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;IoC&lt;/li&gt;
  &lt;li&gt;Aop&lt;/li&gt;
  &lt;li&gt;SpringMVC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面分几个部分很粗地描述一下Spring~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;控制反转&lt;/h2&gt;

&lt;p&gt;要看控制反转，那么我们先看看没有反转的时候是什么样子的，当自己的服务依赖于别人的实现时，在其使用之前选择合适的服务实现对其进行初始化：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    private XXService xxService;
    public MyService(){
        this.xxService = new XXServiceImpl();/* 利用合适的实现进行初始化 */
    }
    // ...
}
&lt;/pre&gt;

&lt;p&gt;程序可以正常运行，但是当你有几十个类中使用了XXService，而某一天发现XXServiceImpl是有BUG的，你想换个实现类，那就傻逼了~~&lt;/p&gt;

&lt;p&gt;用IoC最原始的配置方式就可以将这个问题引刃而解：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean id=&quot;myService&quot; class=&quot;com.test.MyService&quot;&amp;gt;
    &amp;lt;property name=&quot;xxService&quot; ref=&quot;xxService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;xxService&quot; class=&quot;com.test.XXServiceImpl&quot;/&amp;gt;&amp;lt;!-- 改这里 --&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在配置文件中搞定他们之间的依赖关系，在使用前，需要用&lt;strong&gt;BeanFactory&lt;/strong&gt;来构建其中的Bean，在需要时，调用&lt;strong&gt;getBean&lt;/strong&gt;取得实例，然后就可以继续后面的操作了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
BeanFactory factory = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
MyService myService = (MyService)factory.getBean(&quot;myService&quot;);
&lt;/pre&gt;

&lt;p&gt;可能“顽固派”会说：干嘛要怎么麻烦，把你要使用的类包装一下再交给MyService使用就可以了啊！确实可以解决问题，但是思路决定出路，这种解决方法确实解决了上面的问题，但是下面&lt;strong&gt;ApplicationContext&lt;/strong&gt;的登场，使得这种依赖管理变得异常简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    @Resource /* 利用注解完成注入 */
    private XXService xxService;
    // ...
}
@Component(&quot;xxService&quot;) /* 声明一个Bean */
public class XXServiceImpl{
    // ...
}
&lt;/pre&gt;

&lt;p&gt;一直感觉注解在Java中的作用就是将配置信息植入到代码文件里面，现在在依赖管理中注解再一次发挥了巨大的威力。到这里基本上满足大部分的需求了，但是Spring提供的功能可能远超过了你需要的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BeanFactoryAware：获取BeanFactory实例&lt;/li&gt;
  &lt;li&gt;BeanPostProcessor：在afterPropertiesSet的方法前后执行&lt;/li&gt;
  &lt;li&gt;InitializingBean：完成一些初始化动作&lt;/li&gt;
  &lt;li&gt;BeanFactoryPostProcessor:处理Bean的定义，也就是BeanDefinition&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有很多其他的扩展点，下面重点看下Bean的生命周期：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Spring-Bean生命周期.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外IoC里面有很多的细节点，逐步整理中：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;byType/byName&lt;/td&gt;
      &lt;td&gt;根据类型/名字注入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;scope(singleton/prototype)&lt;/td&gt;
      &lt;td&gt;单例还是每次都生成一个新的Bean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;factory-bean/FactoryBean&lt;/td&gt;
      &lt;td&gt;工厂类型的Bean，getBean时会调用其getObject方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Resource&lt;/td&gt;
      &lt;td&gt;默认byName，找不到的时候就byType(指定name就只能byName了)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Autowire&lt;/td&gt;
      &lt;td&gt;默认byType，可以配合@Qualifier变为byName&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lazy-init&lt;/td&gt;
      &lt;td&gt;只对singleton的Bean起作用，效果是在getBean的时候才初始化&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;面向切面编程&lt;/h2&gt;

&lt;p&gt;面向切面编程(Aspect Oriented Programming)提供了另外一个角度来考虑程序结构，在介绍AOP的时候几乎都会介绍&lt;strong&gt;打日志&lt;/strong&gt;的需求，当然除此之外还有很多的场景，这里就不赘述。简单来说Spring的AOP提供了拦截一批方法的手段。&lt;/p&gt;

&lt;p&gt;其实我们自己也可以利用&lt;strong&gt;BeanFactoryPostProcessor&lt;/strong&gt;来实现类似的功能，但在Spring中AOP强大的地方是提供了很多种方便的配置方式。第一种是用XML的配置方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect id=&quot;logaop&quot; ref=&quot;allLogAdvice&quot;&amp;gt;&amp;lt;!--处理类 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.test.MyService.*(..))&quot; /&amp;gt;&amp;lt;!-- 方法 --&amp;gt;
        &amp;lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&amp;gt;&amp;lt;!-- 方式及调用方法 --&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;

&lt;p&gt;另外一种个人感觉比较好用的就是&lt;strong&gt;@Aspect&lt;/strong&gt;方式，这种方式把方法和它要拦截的方法放在一个地方，比较自然一点：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class MyAspect {
    @Pointcut(&quot;execution(* com.test.MyService.*(..))&quot;)
    private void aspectjMethod(){};

    @Before(&quot;service()&quot;)
    private void aroundMethod(){ /* code */ }
}
&lt;/pre&gt;

&lt;p&gt;在使用前需要配置&lt;strong&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/strong&gt;，第二种方式确实有一些进步，但是考虑注解之后，AOP的功能开始变得有点IMBA了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class LocalCacheAspect {
    @Pointcut(&quot;@annotation(localCache)&quot;)
    public void getLocalCacheAnnotation(LocalCache localCache) {}

    @Around(&quot;getLocalCacheAnnotation(localCache)&quot;)
    public Object handleCache(ProceedingJoinPoint joinPoint, LocalCache localCache) throws Throwable {
        /* code */
    }
}
&lt;/pre&gt;

&lt;p&gt;这样当你在Spring的某个方法上加注解&lt;strong&gt;@LocalCache&lt;/strong&gt;后，就可以被handleCache拦截了，在这里需要注意一下大小写。在具体实现的时候AOP利用了两种技术：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JDK动态代理&lt;/li&gt;
  &lt;li&gt;CGLIB字节码生成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想选择cglib需要配置文件中加上&lt;strong&gt;&amp;lt;aop:aspectj-autoproxy proxy-target-class=”true”/&amp;gt;&lt;/strong&gt;。
AOP中涉及到的细节整理如下(不断更新中)：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Pointcut&lt;/td&gt;
      &lt;td&gt;通常使用正则表达式来描述切入的点(拦截哪些方法)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Advice&lt;/td&gt;
      &lt;td&gt;在特定的Pointcut执行的动作：around、before、throws等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Joinpoint&lt;/td&gt;
      &lt;td&gt;具体运行时拦截到的信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;

&lt;p&gt;细想一下大部分的Java程序员应该都在直接或者间接的做页面开发，那么这里就涉及到分层的概念了，当然这里不会讲这些东西。在WEB应用作用，不能不提&lt;strong&gt;web.xml&lt;/strong&gt;,其中需要清楚&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;listener&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;servlet&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它们的作用以及运行机制，在通过SpringMVC来开发Web应用前，需要配置：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.htm&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/pre&gt;

&lt;p&gt;这样就把所有以&lt;strong&gt;.htm&lt;/strong&gt;结尾的请求都交给&lt;strong&gt;DispatcherServlet&lt;/strong&gt;进行具体的处理并返回，过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常用的&lt;strong&gt;handleMapping&lt;/strong&gt;的方式有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SimpleUrlHandlerMapping&lt;/li&gt;
  &lt;li&gt;DefaultAnnotationHandlerMapping&lt;/li&gt;
  &lt;li&gt;AnnotationMethodHandlerAdapter&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用注解的方式更直观一些，在代码中直接就可以明白你正在处理什么样的请求，最简单的一个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Controller
@RequestMapping(&quot;/helloAnnoController.html&quot;)
public class AnyTypeYouLikeController{
    @RequestMapping(method={RequestMethod.GET,RequestMethod.POST})
    public String processWebRequest(){
        return &quot;anno/helloAnnController&quot;;
    }
}
&lt;/pre&gt;

&lt;p&gt;PS：现在各种WEB框架非常多，关键是了解它们运行机制，在遇到问题的时候可以DEBUG去找到解决办法，对某个框架有哪些“奇技淫巧”就不说了，细节太多了···&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;数据访问&lt;/h2&gt;

&lt;p&gt;首先想想要想是的访问数据更方便，Spring应该做什么事情？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;统一的异常处理&lt;/li&gt;
  &lt;li&gt;将相同（类似）操作进行封装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果直接用JDBC来完成数据访问，大致如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    Connection connection = getDataSource().getConnection();
    Statement statement = connection.createStatement();
    // TODO 执行数据库操作
    statement.executeUpdate(&quot;sql...&quot;);
    statement.close();
}finally{
    statement.close();
    connection.close();
}
&lt;/pre&gt;

&lt;p&gt;显然在使用JDBC API处理数据的时候会有大量相似的代码，不仅增加了代码量，而且使得业务
逻辑不清晰、工程难维护。在Spring中用&lt;strong&gt;JdbcTemplate&lt;/strong&gt;通过模板方式来解决这些问题：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class JdbcTemplate {
    public Object execute(StatementCallback action) throws DataAccessException
    {
       // 将连接数据库等操作抽取出来
    }
}
&lt;/pre&gt;

&lt;p&gt;在JdbcTemplate中定义了很多queryXXX和updateXXX的方法，其本质上还是&lt;strong&gt;Callback&lt;/strong&gt;的方
式实现的，定义出来方便我们使用：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
JdbcTemplate jdbcTemplate = new JdbcTemplate();
jdbcTemplate.setDataSource(ds);
jdbcTemplate.execute(new StatementCallback(){
    public Object doInStatement(Statement stmt) throws SQLException {
        stmt.execute(&quot;your sql&quot;);
        return ret;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样编码起来方便了很多，但是接着会想如果我们把SQL写到单独的文件里面，这样剥离开应该
会更好一下吧，这样就有了各种ORM，比如&lt;strong&gt;iBatis&lt;/strong&gt;和&lt;strong&gt;Hibernate&lt;/strong&gt;，在iBatis中用SqlMapClient
来访问数据，通常访问的方式有三种：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
//1、基于SqlMapCLient的自动提交事务型简单数据访问
Map parameters = new HashMap();
parameters.put(&quot;param1&quot;, value);
// ..
Object ret = sqlMap.queryForObject(&quot;sql_id&quot;, parameters);
// 2、基于SqlMapClient的非自动提交事务型数据访问
try{
    sqlMap.startTransaction();
    sqlMap.update(&quot;....&quot;);
    sqlMap.commitTransaction();
} finally {
    sqlMap.endTransaction();
}
// 3、基于SqlMapSession的数据访问
SqlMapSession session = null;
try{
    session = sqlMap.openSession();
    session.startTransaction();
    session.update(&quot;...&quot;);
    session.commitTransaction();
} finally {
    session.endTransaction();
}
&lt;/pre&gt;

&lt;p&gt;因为Spring在集成iBatis的时候要考虑将事务控制也纳入进来，所以使用基于SqlMapSession
的数据访问方式对iBatis进行集成，这种方式更灵活，可以将iBatis内部直接指定的数据源和事
务管理器等转由外部提供（IoC），&lt;strong&gt;SqlMapClientTemplate&lt;/strong&gt;是Spring为iBatis的数据访问操
作提供的模板方法类：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class SqlMapClientTemplate {
    public Object execute(SqlMapClientCallback action) throws DataAccessException {
        // ...
    }
}
&lt;/pre&gt;

&lt;p&gt;SqlMapClientCallback可以完成任何基于iBatis的数据访问操作，比如要向一个数据库批量提
交更新数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
protected void batchInsert(final List beans) {
    sqlMapClientTemplate.execute(new SqlMapClientCallback() {
        public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
            executor.startBatch();
            Interator iter = beans.iterator();
            while(iter.hasNext()) {
                Bean bean = (Bean) iter.next();
                executor.insert(&quot;insert_name&quot;, bean);
            }
            executor.executeBatch();
            return null;
        }
    });
}
&lt;/pre&gt;

&lt;p&gt;最后来看事务处理，局部事务的话用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    transaction = session.beginTransaction();
    // TODO 操作数据
    session.flush();
    transaction.commit();
} catch (Exception e){
    transaction.rollback(); // 回滚
} finally {
    session.close();
}
&lt;/pre&gt;

&lt;p&gt;因为JDBC的局部事务控制是由同一个Connection来完成的，所以要保证两个DAO的数据访问
方式处于一个事务中，我们就得保证他们使用的是同一个Connection，要做到这一点，通常采
用称为connection-passing的方式，即为同一个事务中的各个DAO的数据访问传递当前事务对
应的同一个Connection。&lt;/p&gt;

&lt;p&gt;我们可以直接使用PlatformTransactionManager，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
definition.setXXX();
definition.setXXX();
TransactionStatus status = transactionManager.getTransaction(definition);
try {
    // TODO 业务逻辑
} catch (Exception e) {
    transactionManager.roolback(status);
}
transactionManager.commit(status);
&lt;/pre&gt;

&lt;p&gt;可以看到上面有很多重复的操作，接着用TransactionTemplate对事务的管理进行模板化。而
基于申明式的事务有四种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ProxyFactory + TransactionInterceptor&lt;/li&gt;
  &lt;li&gt;TransactionProxyFactoryBean&lt;/li&gt;
  &lt;li&gt;BeanNameAutoProxyCreator&lt;/li&gt;
  &lt;li&gt;Spring 2.x申明事务配置方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然也可以通过注解&lt;strong&gt;@Transactional&lt;/strong&gt;来申明事务。&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Guava</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;

&lt;h2 id=&quot;section-2&quot;&gt;学习&lt;/h2&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

</description>
        <pubDate>Sat, 30 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java枚举</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;在JDK 1.5之前通常用final来定义各种常量，现在新加了枚举类型，最简单的用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED,
    GREEN
}
&lt;/pre&gt;

&lt;p&gt;还可以像普通的类那样自己定义属性和方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED(&quot;red&quot;),
    GREEN(&quot;green&quot;);
    String name;

    Color(String name) {
        this.name = name;
    }

    public String toString(){
        return name;
    }
}
&lt;/pre&gt;

&lt;p&gt;甚至enum还可以去实现接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color implements Comparable&amp;lt;Color&amp;gt; {
    RED,
    GREEN;
}
&lt;/pre&gt;

&lt;p&gt;在使用的时候，枚举可以用来比较：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
if(c == Color.GREEN){
    // ...
}
&lt;/pre&gt;

&lt;p&gt;也可以用来switch：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
switch (c) {
    case RED:
    case GREEN:
}
&lt;/pre&gt;

&lt;p&gt;而且你可以很方便的变量一个枚举类型中所有的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
for (Color c : Color.values()) {
    System.out.println(c);
}
&lt;/pre&gt;

&lt;p&gt;甚至在你只知道枚举的变量名的时候也能拿到对应的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
System.out.println(Color.valueOf(&quot;RED&quot;));
&lt;/pre&gt;

&lt;p&gt;看下来，枚举在定义常量上面做了不少友好的封装。&lt;/p&gt;

&lt;h2 id=&quot;vs&quot;&gt;枚举VS常量&lt;/h2&gt;

&lt;p&gt;首先不同的枚举类是不同的类型，而你用final static修饰的一般都是int等基本类型，这样很难做类型检查，这算是Enum比较大的一个优势的优势，在写代码的时候不会传错参数：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void check(Color c){

}
&lt;/pre&gt;

&lt;p&gt;当你传入其他类型参数时会编译出错。&lt;/p&gt;

&lt;h2 id=&quot;enum&quot;&gt;enum到底是什么&lt;/h2&gt;

&lt;p&gt;在编译之后会有一个Color.class文件，使用javap查看：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
final class Color extends java.lang.Enum implements java.lang.Comparable{
    public static final Color RED;
    public static final Color GREEN;
    public static Color[] values();
    public static Color valueOf(java.lang.String);
    static {};
}
&lt;/pre&gt;

&lt;p&gt;该类继承自&lt;strong&gt;java.lang.Enum&lt;/strong&gt;，然后通过&lt;strong&gt;javap -c Color&lt;/strong&gt;来看初始化的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static {};
  Code:
   0:   new     #4; //class Color
   3:   dup
   4:   ldc     #7; //String RED
   6:   iconst_0
   7:   invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   10:  putstatic       #9; //Field RED:LColor;
   13:  new     #4; //class Color
   16:  dup
   17:  ldc     #10; //String GREEN
   19:  iconst_1
   20:  invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   23:  putstatic       #11; //Field GREEN:LColor;
   26:  iconst_2
   27:  anewarray       #4; //class Color
   30:  dup
   31:  iconst_0
   32:  getstatic       #9; //Field RED:LColor;
   35:  aastore
   36:  dup
   37:  iconst_1
   38:  getstatic       #11; //Field GREEN:LColor;
   41:  aastore
   42:  putstatic       #1; //Field $VALUES:[LColor;
   45:  return
&lt;/pre&gt;

&lt;p&gt;这里大家可能会对枚举switch有疑问，我们写代码来看下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void func(Color c){
        switch(c){
            case RED:
            case GREEN:
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;然后用javap -c查看，得到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void func(Color);
  Code:
   0:   getstatic       #2; //Field Test$1.$SwitchMap$Color:[I
   3:   aload_1
   4:   invokevirtual   #3; //Method Color.ordinal:()I
   7:   iaload
   8:   lookupswitch{ //2
                1: 36;
                2: 36;
                default: 36 }
   36:  return
}
&lt;/pre&gt;

&lt;p&gt;可以看到这里switch的其实还是enum类中的ordinal（int），和之前我们对switch的认识是一致的。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 May 2015 04:34:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的ThreadLocal</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;多个线程在调用同一个方法的时候，会有并发问题，解决这种问题最简单的办法就是将数据保存在Thread的自己的结构中，也就是ThreadLocal的作用了。用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class JavaBean {
    static ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;Integer&amp;gt;();

    public void prepare() {
        threadLocal.set(0);
    }

    public void work() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            int val = threadLocal.get();
            val++;
            threadLocal.set(val);
        }
        System.out.println(threadLocal.get());
    }
}

class Worker extends Thread {
    JavaBean bean;

    public Worker(JavaBean bean) {
        this.bean = bean;
    }

    public void run() {
        bean.prepare();
        bean.work();
    }
}

public class ThreadLocalDemo {
    public static void main(String[] args) {
        JavaBean bean = new JavaBean();
        for (int i = 0; i &amp;lt; 100; i++) {
            new Worker(bean).start();
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;从输出中可以看到，多个线程操作同一个threadLocal时，结果并不会出错。&lt;/p&gt;

&lt;p&gt;可以将ThreadLocal看做是对&lt;strong&gt;Thread.threadLocals&lt;/strong&gt;的封装，况且在程序中也是不能直接访问到Thread.threadLocals。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;下面简单看ThreadLocal的原理，在Thread中保存了一个Map，类型可以认为是&lt;strong&gt;Map&amp;lt;ThreadLocal, T&amp;gt;&lt;/strong&gt;，其中T是要保存数据的类型。当要从中取出数据时，调用的流程如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Thread.currentThread().threadLocals.getEntry(threadLocal).value
&lt;/pre&gt;

&lt;p&gt;这样，不同的线程在执行的时候在同一个threadLocal上获取到的是不同的数据，线程之间的隔离性是通过”各自保存不同的Map”来实现的，而看到的threadLocal对象其实是&lt;strong&gt;KEY&lt;/strong&gt;，在操作前get到的是&lt;strong&gt;VALUE&lt;/strong&gt;。其实自己动手做一个线程安全的数据保存的解决方法也是这个思路。&lt;/p&gt;

&lt;p&gt;在ThreadLocalMap中使用的并不是普通的引用保存数据，而是使用&lt;strong&gt;WeakReference&lt;/strong&gt;来做：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;gt; {
    Object value;
    Entry(ThreadLocal k, Object v) {
        super(k);
        value = v;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样如果ThreadLocal被释放了，那么ThreadLocalMap中的Entry也会被释放，不至于造成内存泄露。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java对象占用了多少空间？</title>
        <description>&lt;p&gt;在Java中没有sizeof运算符，所以没办法知道一个对象到底占用了多大的空间，但是在分配对象的时候会有一些基本的规则，我们根据这些规则大致能判断出来对象大小。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;对象头&lt;/h2&gt;

&lt;p&gt;对象的头部至少有两个WORD，如果是数组的话，那么三个WORD，内容如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的HashCode，锁信息等&lt;/li&gt;
  &lt;li&gt;到对象类型数据的指针&lt;/li&gt;
  &lt;li&gt;数组的长度（如果是数组的话）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;规则&lt;/h2&gt;

&lt;p&gt;首先，任何对象都是8字节对齐，属性按照[long,double]、[int,float]、[char,short]、[byte,boolean]、reference的顺序存放，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    byte a;
    int b;
    boolean c;
    long d;
    Object e;
}
&lt;/pre&gt;

&lt;p&gt;如果这个对象的属性按照顺序存放的话，要占用的空间为：head(8) + a(1) + padding(3) + b(4) + c(1) + padding(7) + d(8) + e(4) + padding(4) = 40。但是按照这个规则得到：head(8) + d(8) + b(4) + a(1) + c(1) + padding(2) + e(4) + padding(4) = 32。可以看到节省了不少空间。&lt;/p&gt;

&lt;p&gt;在涉及继承关系的时候有一个最基本的规则：首先存放父类中的成员，接着才是子类中的成员，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    long a;
    int b;
    int c;
}
class B extends A {
    long d;
}
&lt;/pre&gt;

&lt;p&gt;这样存放的顺序及占用空间如下：head(8) + a(8) + b(4) + c(4) + d(8) = 32。那如果父类中的属性不够八个字节怎么办？这样就有了新的一条规则：父类中最后一个成员与子类的第一个成员的间隔如果不够4个字节，此时需要扩展到4个字节的基本单位，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    byte b;
}
&lt;/pre&gt;

&lt;p&gt;那么此时占用的空间如下：head(8) + a(1) + padding(3) + b(1) + padding(3) = 16。显然这种方式比较浪费空间，那么就有了：如果子类的第一个成员是double或者long，并且父类并没有用完8个字节，JVM会破坏规将较小的数据填充到该空间，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    long b;
    short c;
    byte d;
}
&lt;/pre&gt;

&lt;p&gt;此时占用的空间如下：head(8) + a(1) + padding(3) + c(2) + d(1) + padding(1) + b(8) = 24。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的泛型</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;什么是泛型&lt;/h2&gt;

&lt;p&gt;泛型是JDK 1.5中引入的特性，允许在定义类、接口、方法的时候使用类型参数，声明的类型参数在使用时用具体的类型替换。从好的方面来看，泛型的引入可以在编译时刻就发现很多明显的错误。从不好的方面，为了保证与旧有版本的兼容性，Java泛型的实现上存在一些不优雅的地方。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;最常见的使用场景是泛型类或者接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
interface TestInterface&amp;lt;T&amp;gt; {
}
class TestClass&amp;lt;T&amp;gt; {
    T data;
}
&lt;/pre&gt;

&lt;p&gt;看以看到泛型的好处能节省我们的代码量，当&lt;strong&gt;data&lt;/strong&gt;的类型变化的时候，我们不需要去写不同的接口或者类。当然有时候你需要指定多个类型，那么可以：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&amp;lt;K, V, OTHER&amp;gt; {
    K     key;
    V     value;
    OTHER other;
}
&lt;/pre&gt;

&lt;p&gt;有时候我们希望只支持Number类型，那么可以：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&amp;lt;T extends Number&amp;gt; {
    T data;
}
&lt;/pre&gt;

&lt;p&gt;当然，泛型也可以用在方法上，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public &amp;lt;T&amp;gt; T doSth(T a){
    return a;
}
&lt;/pre&gt;

&lt;p&gt;你可能会比较好奇如果同时在方法和类上面使用泛型的话会出现什么情况：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&amp;lt;T&amp;gt; {
    T data;
    @SuppressWarnings(&quot;hiding&quot;)
    public &amp;lt;T&amp;gt; T doSth(T a) {
        return a;
    }

    public static void main(String[] args) {
        Test&amp;lt;String&amp;gt; t = new Test&amp;lt;String&amp;gt;();
        System.out.println(t.doSth(123));
        t.data = &quot;123&quot;;
    }
}
&lt;/pre&gt;

&lt;p&gt;结论是方法上的用方法的，其他的用类上的，如果方法上没有，方法用类上的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;多想一点&lt;/h2&gt;

&lt;p&gt;现在想一下泛型具体是如何实现的，用&lt;strong&gt;javap Test&lt;/strong&gt;看doSth的方法声明如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Object doSth(java.lang.Object);
&lt;/pre&gt;

&lt;p&gt;如果是受限的泛型，比如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&amp;lt;T extends Number&amp;gt; {
    public T doSth(T a) {
        return a;
    }
}
&lt;/pre&gt;

&lt;p&gt;那么得到的结果则是：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Number doSth(java.lang.Number);
&lt;/pre&gt;

&lt;p&gt;如果限制类型有两个（比如&amp;lt;T extends Comparable &amp;amp; Serializable&amp;gt;）则生成的字节码中选用第一个（Comparable）。Java中的泛型是伪泛型，在运行期间，所有的泛型信息都会被擦除。也就是说在生成的Java字节码中没有包含泛型中的类型信息。那么在重载的时候会有什么影响，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void doSth(List&amp;lt;Integer&amp;gt; list) { }
    public void doSth(List&amp;lt;String&amp;gt; list) { }
}
&lt;/pre&gt;

&lt;p&gt;现在应该会猜到：&lt;strong&gt;因为类型擦除，这个类是不能被编译通过的。&lt;/strong&gt;那么下面这段代码呢？&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public Integer doSth(List&amp;lt;Integer&amp;gt; list) { return null; }
    public String doSth(List&amp;lt;String&amp;gt; list) { return null; }
}
&lt;/pre&gt;

&lt;p&gt;编译通过了。这貌似与我们之前对重载的认识不相同：函数之间的区分是依据参数和方法名，返回值并不参与。上面这段代码中常在不是根据返回值来判断的，但是增加不同类型的返回值是的这两个方法能够共存在同一个Class文件中：
&amp;gt; 重载要求方法有不同的方法签名，而返回值并不在方法签名中。但是在Class文件格式中，只要描述符不是完全一致的方法就可以共存，也就是说：返回值也能影响方法能不能共存在同一个Class中。
可以通过javap -s Test看到方法签名。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;获取泛型的类型&lt;/h2&gt;

&lt;p&gt;首先来看通过&lt;strong&gt;ParameterizedType&lt;/strong&gt;获取类型的方法，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public List&amp;lt;String&amp;gt; list;

    public static void main(String[] args) throws Exception {
        ParameterizedType pt = (ParameterizedType) Test.class.getField(&quot;list&quot;).getGenericType();
        System.out.println(pt.getActualTypeArguments()[0]);
    }
}
&lt;/pre&gt;

&lt;p&gt;其中getGenericType方法返回一个Type对象，如果是一个参数化类型，那么返回的Type会反映源码中使用的实际参数类型，实际的参数类型通过getActualTypeArguments获取。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Linux内存管理</title>
        <description>&lt;p&gt;现在的服务器大部分都是运行在Linux上面的，所以，作为一个程序员有必要简单地了解一下系统是如何运行的。对于内存部分需要知道：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;地址映射&lt;/li&gt;
  &lt;li&gt;内存管理的方式&lt;/li&gt;
  &lt;li&gt;缺页异常&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先来看一些基本的知识，在进程看来，内存分为内核态和用户态两部分，经典比例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-虚拟地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从用户态到内核态一般通过系统调用、中断来实现。用户态的内存被划分为不同的区域用于不同的目的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-用户区分段.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然内核态也不会无差别地使用，所以，其划分如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-内核地址空间划分.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面来仔细看这些内存是如何管理的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;地址&lt;/h2&gt;

&lt;p&gt;在Linux内部的地址的映射过程为&lt;strong&gt;逻辑地址&lt;/strong&gt;–&amp;gt;&lt;strong&gt;线性地址&lt;/strong&gt;–&amp;gt;&lt;strong&gt;物理地址&lt;/strong&gt;，物理地址最简单：地址总线中传输的数字信号，而线性地址和逻辑地址所表示的则是一种转换规则，线性地址规则如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-线性地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部分由MMU完成，其中涉及到主要的寄存器有CR0、CR3。机器指令中出现的是逻辑地址，逻辑地址规则如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-逻辑地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Linux中的逻辑地址等于线性地址，也就是说Inter为了兼容把事情搞得很复杂，Linux简化顺便偷个懒。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内存管理的方式&lt;/h2&gt;

&lt;p&gt;在系统boot的时候会去探测内存的大小和情况，在建立复杂的结构之前，需要用一个简单的方式来管理这些内存，这就是&lt;strong&gt;bootmem&lt;/strong&gt;，简单来说就是位图，不过其中也有一些优化的思路。&lt;/p&gt;

&lt;p&gt;bootmem再怎么优化，效率都不高，在要分配内存的时候毕竟是要去遍历，&lt;strong&gt;buddy&lt;/strong&gt;系统刚好能解决这个问题：在内部保存一些2的幂次大小的空闲内存片段，如果要分配3page，去4page的列表里面取一个，分配3个之后将剩下的1个放回去，内存释放的过程刚好是一个逆过程。用一个图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-伙伴系统.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到0、4、5、6、7都是正在使用的，那么，1、2被释放的时候，他们会合并吗？&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static inline unsigned long
__find_buddy_index(unsigned long page_idx, unsigned int order)
{
    return page_idx ^ (1 &amp;lt;&amp;lt; order);// 更新最高位，0～1互换
}
&lt;/pre&gt;

&lt;p&gt;从上面这段代码中可以看到，0、1是buddy，2、3是buddy，虽然1、2相邻，但他们不是。内存碎片是系统运行的大敌，伙伴系统机制可以在一定程度上防止碎片~~另外，我们可以通过cat /proc/buddyinfo获取到各order中的空闲的页面数。&lt;/p&gt;

&lt;p&gt;伙伴系统每次分配内存都是以页（4KB）为单位的，但系统运行的时候使用的绝大部分的数据结构都是很小的，为一个小对象分配4KB显然是不划算了。Linux中使用&lt;strong&gt;slab&lt;/strong&gt;来解决小对象的分配：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-SLAB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在运行时，slab向buddy“批发”一些内存，加工切块以后“散卖”出去。随着大规模多处理器系统和NUMA系统的广泛应用，slab终于暴露出不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复杂的队列管理&lt;/li&gt;
  &lt;li&gt;管理数据和队列存储开销较大&lt;/li&gt;
  &lt;li&gt;长时间运行partial队列可能会非常长&lt;/li&gt;
  &lt;li&gt;对NUMA支持非常复杂&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这些高手们开发了&lt;strong&gt;slub&lt;/strong&gt;：改造page结构来削减slab管理结构的开销、每个CPU都有一个本地活动的slab(kmem_cache_cpu)等。对于小型的嵌入式系统存在一个slab模拟层&lt;strong&gt;slob&lt;/strong&gt;，在这种系统中它更有优势。&lt;/p&gt;

&lt;p&gt;小内存的问题算是解决了，但还有一个大内存的问题：用伙伴系统分配10 x 4KB的数据时，会去16 x 4KB的空闲列表里面去找（这样得到的物理内存是连续的），但很有可能系统里面有内存，但是伙伴系统分配不出来，因为他们被分割成小的片段。那么，&lt;strong&gt;vmalloc&lt;/strong&gt;就是要用这些碎片来拼凑出一个大内存，相当于收集一些“边角料”，组装成一个成品后“出售”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-非连续内存.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前的内存都是直接映射的，第一次感觉到页式管理的存在:D 另外对于高端内存，提供了&lt;strong&gt;kmap&lt;/strong&gt;方法为page分配一个线性地址。&lt;/p&gt;

&lt;p&gt;进程由不同长度的段组成：代码段、动态库的代码、全局变量和动态产生数据的堆、栈等，在Linux中为每个进程管理了一套&lt;strong&gt;虚拟地址空间&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-进程虚拟内存.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在我们写代码malloc完以后，并没有马上占用那么大的物理内存，而仅仅是维护上面的虚拟地址空间而已，只有在真正需要的时候才分配物理内存，这就是&lt;strong&gt;COW&lt;/strong&gt;（COPY-ON-WRITE:写时复制）技术，而物理分配的过程就是最复杂的缺页异常处理环节了，下面来看!&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缺页异常&lt;/h2&gt;

&lt;p&gt;在实际需要某个虚拟内存区域的数据之前，和物理内存之间的映射关系不会建立。如果进程访问的虚拟地址空间部分尚未与页帧关联，处理器自动引发一个缺页异常。在内核处理缺页异常时可以拿到的信息如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cr2：访问到线性地址&lt;/li&gt;
  &lt;li&gt;err_code：异常发生时由控制单元压入栈中，表示发生异常的原因&lt;/li&gt;
  &lt;li&gt;regs：发生异常时寄存器的值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;处理的流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-缺页异常.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发生缺页异常的时候，可能因为不常使用而被swap到磁盘上了，swap相关的命令如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;swapon&lt;/td&gt;
      &lt;td&gt;开启swap&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;swapoff&lt;/td&gt;
      &lt;td&gt;关闭swap&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/sys/vm/swappiness&lt;/td&gt;
      &lt;td&gt;分值越大越积极使用swap，可以修改/etc/sysctl.conf中添加vm.swappiness=xx来修改&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果内存是mmap映射到内存中的，那么在读、写对应内存的时候也会产生缺页异常。&lt;/p&gt;
</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>歌德尔不完备定理</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;希尔伯特&lt;/strong&gt;是19世纪和20世纪初最具影响力的数学家之一，在严格化的大纷争中，他带领的形式主义派系技压群雄，得到许多当时有名望的数学家的支持。希尔伯特打算通过形式化的手段，将证明抽象成一堆符号的转换。令人惊奇的是这似乎真的可行！为此，希尔伯特希望能够证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，对任意的陈述，都能判断出真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，这一企图被&lt;strong&gt;哥德尔&lt;/strong&gt;的博士论文《论数学原理及有关系统中不可判定命题》无情击碎，不完备性定理揭示：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，存在命题，无法证明其真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这在当时的数学界掀起轩然大波，它不仅具有数学意义，还蕴含着深刻的哲学意义。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;证明&lt;/h2&gt;

&lt;p&gt;不能判断出真伪，自然就想到古老的悖论：&lt;strong&gt;这句话是假的&lt;/strong&gt;（说它真也不行，说它假也不行！）。1905年法国数学家&lt;strong&gt;理查德&lt;/strong&gt;在数学系统中构造出来这样的悖论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用语言描述自然数的性质；&lt;/li&gt;
  &lt;li&gt;将性质的描述语言映射到一个自然数；&lt;/li&gt;
  &lt;li&gt;如果自然数不符合对应的性质，则称其具有理查兹性，该自然数称为理查德数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理查兹性也是一个自然数的性质，对应的编号为N，那么N是理查德数吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理查德悖论&lt;/strong&gt;是有瑕疵的：自然数的性质应该是“能被2整除”、“大于100”等，而理查兹性质则把性质和描述性质的语言纠缠在一起了！&lt;/p&gt;

&lt;p&gt;罗素和一些人认为如果把对象语言和讨论对象语言的&lt;strong&gt;元语言&lt;/strong&gt;区分开来就能避免这种问题。希尔伯特用精确的形式语言构建的形式公理系统，已经严格区分了数学和元数学，建立起隔离墙，堵住了这个漏洞。哥德尔要想把&lt;strong&gt;这个公式是不可证明的&lt;/strong&gt;放在系统里，必须绕过这堵墙，用数学语言来描述即证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任何相容的形式系统，只要蕴含皮亚诺算术公理，就可以在其中构造在体系中不能被证明的命题，因此通过推演不能得到所有的真命题（即体系是不完备的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓&lt;strong&gt;相容&lt;/strong&gt;，就是不矛盾，所谓&lt;strong&gt;完备&lt;/strong&gt;，就是所有的真理都能被形式证明，所谓&lt;strong&gt;皮亚诺算术公理&lt;/strong&gt;是指意大利数学家&lt;strong&gt;皮亚诺&lt;/strong&gt;提出的关于自然数的五条公理系统：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1是自然数&lt;/li&gt;
  &lt;li&gt;每一个确定的自然数a都有一个确定的后继数a’&lt;/li&gt;
  &lt;li&gt;当且仅当b’=c’时有b=c&lt;/li&gt;
  &lt;li&gt;1不是任何自然数的后继数&lt;/li&gt;
  &lt;li&gt;任意关于自然数的命题，如果证明1是对的，并且假设n对的情况下n’也是对的，那么所有的自然数都是对的（数学归纳法）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据这五条公理系统可以建立起一阶算术系统。&lt;/p&gt;

&lt;p&gt;我们来看哥德尔的证明，首先他将命题映射成自然数，现在搞计算机的一看可能觉得用Unicode不就完了？但是这个论文比计算机早了很多年，可以了解一下&lt;strong&gt;哥德尔编码&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;G(F)：命题F(x)的哥德尔数。
P(x)：在系统中哥德尔数x对应的命题是可证明的。
SU(z)：对于F(x)有z=G(F)，设y是命题F(G(F))的哥德尔数，则有~P(y)成立。
p：SU(G(SU))。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当问到p是否为真的时候，我们其实就是在问&lt;strong&gt;不可证这个特性本身是不可证的吗？&lt;/strong&gt;这样就造成了矛盾（这是Wikipedia上面给出的）。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;意义&lt;/h2&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</link>
        <guid isPermaLink="true">/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</guid>
        
        
        <category>数学</category>
        
      </item>
    
  </channel>
</rss>
