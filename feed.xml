<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 30 May 2015 09:57:18 +0800</pubDate>
    <lastBuildDate>Sat, 30 May 2015 09:57:18 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Java枚举</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;在JDK 1.5之前通常用final来定义各种常量，现在新加了枚举类型，最简单的用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED,
    GREEN
}
&lt;/pre&gt;

&lt;p&gt;还可以像普通的类那样自己定义属性和方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED(&quot;red&quot;),
    GREEN(&quot;green&quot;);
    String name;

    Color(String name) {
        this.name = name;
    }

    public String toString(){
        return name;
    }
}
&lt;/pre&gt;

&lt;p&gt;甚至enum还可以去实现接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color implements Comparable&lt;color&gt; {
    RED,
    GREEN;
}


在使用的时候，枚举可以用来比较：

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
if(c == Color.GREEN){
    // ...
}
&lt;/pre&gt;

也可以用来switch：

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
switch (c) {
    case RED:
    case GREEN:
}
&lt;/pre&gt;

而且你可以很方便的变量一个枚举类型中所有的属性：

&lt;pre class=&quot;prettyprint&quot;&gt;
for (Color c : Color.values()) {
    System.out.println(c);
}
&lt;/pre&gt;

甚至在你只知道枚举的变量名的时候也能拿到对应的属性：

&lt;pre class=&quot;prettyprint&quot;&gt;
System.out.println(Color.valueOf(&quot;RED&quot;));
&lt;/pre&gt;

看下来，枚举在定义常量上面的作用还真大。

## 枚举VS常量

首先不同的枚举类是不同的类型，而你用final static修饰的一般都是int等基本类型，这样的常量不容易做到类型检查，这也算是一个枚举的优势：

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void check(Color c){

}
&lt;/pre&gt;

如果你想封装一种类型的常量类型检查的话（除非有现成的类），为什么不用enum？

## enum到底是什么

在编译之后会有一个Color.class文件，使用javap查看：

&lt;pre class=&quot;prettyprint&quot;&gt;
final class Color extends java.lang.Enum implements java.lang.Comparable{
    public static final Color RED;
    public static final Color GREEN;
    public static Color[] values();
    public static Color valueOf(java.lang.String);
    static {};
}
&lt;/pre&gt;

该类继承自**java.lang.Enum**，然后通过**javap -c Color**来看初始化的代码：

&lt;pre class=&quot;prettyprint&quot;&gt;
static {};
  Code:
   0:   new     #4; //class Color
   3:   dup
   4:   ldc     #7; //String RED
   6:   iconst_0
   7:   invokespecial   #8; //Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V
   10:  putstatic       #9; //Field RED:LColor;
   13:  new     #4; //class Color
   16:  dup
   17:  ldc     #10; //String GREEN
   19:  iconst_1
   20:  invokespecial   #8; //Method &quot;&lt;init&gt;&quot;:(Ljava/lang/String;I)V
   23:  putstatic       #11; //Field GREEN:LColor;
   26:  iconst_2
   27:  anewarray       #4; //class Color
   30:  dup
   31:  iconst_0
   32:  getstatic       #9; //Field RED:LColor;
   35:  aastore
   36:  dup
   37:  iconst_1
   38:  getstatic       #11; //Field GREEN:LColor;
   41:  aastore
   42:  putstatic       #1; //Field $VALUES:[LColor;
   45:  return


这里大家可能会对枚举switch有疑问，我们写代码来看下：

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void func(Color c){
        switch(c){
            case RED:
            case GREEN:
        }
    }
}
&lt;/pre&gt;

然后用javap -c查看，得到：

&lt;pre class=&quot;prettyprint&quot;&gt;
public void func(Color);
  Code:
   0:   getstatic       #2; //Field Test$1.$SwitchMap$Color:[I
   3:   aload_1
   4:   invokevirtual   #3; //Method Color.ordinal:()I
   7:   iaload
   8:   lookupswitch{ //2
                1: 36;
                2: 36;
                default: 36 }
   36:  return
}
&lt;/pre&gt;

可以看到这里switch的其实还是enum类中的ordinal（int），和之前我们对switch的认识是一致的。
&lt;/init&gt;&lt;/init&gt;&lt;/pre&gt;&lt;/color&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 15 May 2015 04:34:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的ThreadLocal</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;多个线程在调用同一个方法的时候，会有并发问题，解决这种问题最简单的办法就是将数据保存在Thread的自己的结构中，也就是ThreadLocal的作用了。用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class JavaBean {
    ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;Integer&amp;gt;();

    public void prepare() {
        threadLocal.set(0);
    }

    public void work() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            int val = threadLocal.get();
            val++;
            threadLocal.set(val);
        }
        System.out.println(threadLocal.get());
    }
}

class Worker extends Thread {
    JavaBean bean;

    public Worker(JavaBean bean) {
        this.bean = bean;
    }

    public void run() {
        bean.prepare();
        bean.work();
    }
}

public class ThreadLocalDemo {
    public static void main(String[] args) {
        JavaBean bean = new JavaBean();
        for (int i = 0; i &amp;lt; 100; i++) {
            new Worker(bean).start();
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;可以将ThreadLocal看做是对&lt;strong&gt;Thread.threadLocals&lt;/strong&gt;的封装，况且在程序中也是不能直接访问到Thread.threadLocals。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;下面简单看ThreadLocal的原理，在Thread中保存了一个Map，类型可以认为是&lt;strong&gt;Map&amp;lt;ThreadLocal, T&amp;gt;&lt;/strong&gt;，其中T是要保存数据的类型。当要从中取出数据时，调用的流程如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Thread.currentThread().threadLocals.getEntry(threadLocal).value
&lt;/pre&gt;

&lt;p&gt;这样，不同的线程在执行的时候在同一个threadLocal上获取到的是不同的数据，线程之间的隔离性是通过”各自保存不同的Map”来实现的。其实如果让你来做一个线程安全的数据保存的解决方法很可能也是这个思路。&lt;/p&gt;

&lt;p&gt;在ThreadLocalMap中使用的并不是普通的引用保存数据，而是使用WeakReference来做：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;gt; {
    Object value;
    Entry(ThreadLocal k, Object v) {
        super(k);
        value = v;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样如果ThreadLocal被释放了，那么ThreadLocalMap中的Entry也会被释放，不至于造成内存泄露。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java对象占用了多少空间？</title>
        <description>&lt;p&gt;在Java中没有sizeof运算符，所以没办法知道一个对象到底占用了多大的空间，但是在分配对象的时候会有一些基本的规则，我们根据这些规则大致能判断出来对象大小。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;对象头&lt;/h2&gt;

&lt;p&gt;对象的头部至少有两个WORD，如果是数组的话，那么三个WORD，内容如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的HashCode，锁信息等&lt;/li&gt;
  &lt;li&gt;到对象类型数据的指针&lt;/li&gt;
  &lt;li&gt;数组的长度（如果是数组的话）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;规则&lt;/h2&gt;

&lt;p&gt;首先，任何对象都是8字节对齐，属性按照[long,double]、[int,float]、[char,short]、[byte,boolean]、reference的顺序存放，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    byte a;
    int b;
    boolean c;
    long d;
    Object e;
}
&lt;/pre&gt;

&lt;p&gt;如果这个对象的属性按照顺序存放的话，要占用的空间为：head(8) + a(1) + padding(3) + b(4) + c(1) + padding(7) + d(8) + e(4) + padding(4) = 40。但是按照这个规则得到：head(8) + d(8) + b(4) + a(1) + c(1) + padding(2) + e(4) + padding(4) = 32。可以看到节省了不少空间。&lt;/p&gt;

&lt;p&gt;在涉及继承关系的时候有一个最基本的规则：首先存放父类中的成员，接着才是子类中的成员，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    long a;
    int b;
    int c;
}
class B extends A {
    long d;
}
&lt;/pre&gt;

&lt;p&gt;这样存放的顺序及占用空间如下：head(8) + a(8) + b(4) + c(4) + d(8) = 32。那如果父类中的属性不够八个字节怎么办？这样就有了新的一条规则：父类中最后一个成员与子类的第一个成员的间隔如果不够4个字节，此时需要扩展到4个字节的基本单位，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    byte b;
}
&lt;/pre&gt;

&lt;p&gt;那么此时占用的空间如下：head(8) + a(1) + padding(3) + b(1) + padding(3) = 16。显然这种方式比较浪费空间，那么就有了：如果子类的第一个成员是double或者long，并且父类并没有用完8个字节，JVM活破坏规将较小的数据填充到该空间，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    long b;
    short c;
    byte d;
}
&lt;/pre&gt;

&lt;p&gt;此时占用的空间如下：head(8) + a(1) + padding(3) + c(2) + d(1) + padding(1) + b(8) = 24。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的泛型</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;什么是泛型&lt;/h2&gt;

&lt;p&gt;泛型是JDK 1.5中引入的特性，允许在定义类、接口、方法的时候使用类型参数，声明的类型参数在使用时用具体的类型替换。从好的方面来看，泛型的引入可以在编译时刻就发现很多明显的错误。从不好的方面，为了保证与旧有版本的兼容性，Java泛型的实现上存在一些不优雅的地方。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;最常见的使用场景是泛型类或者接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
interface TestInterface&lt;t&gt; {
}
class TestClass&lt;t&gt; {
    T data;
}


看以看到泛型的好处能节省我们的代码量，当**data**的类型变化的时候，我们不需要去写不同的接口或者类。当然有时候你需要指定多个类型，那么可以：

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&amp;lt;K, V, OTHER&amp;gt; {
    K     key;
    V     value;
    OTHER other;
}
&lt;/pre&gt;

有时候我们希望只支持Number类型，那么可以：

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&lt;t extends=&quot;&quot; number=&quot;&quot;&gt; {
    T data;
}


当然，泛型也可以用在方法上，举个例子：

&lt;pre class=&quot;prettyprint&quot;&gt;
public &lt;t&gt; T doSth(T a){
    return a;
}


你可能会比较好奇如果同时在方法和类上面使用泛型的话会出现什么情况：

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&lt;t&gt; {
    T data;
    @SuppressWarnings(&quot;hiding&quot;)
    public &lt;t&gt; T doSth(T a) {
        return a;
    }

    public static void main(String[] args) {
        Test&lt;string&gt; t = new Test&lt;string&gt;();
        System.out.println(t.doSth(123));
        t.data = &quot;123&quot;;
    }
}


结论是方法上的用方法的，其他的用类上的，如果方法上没有，方法用类上的。

## 多想一点

现在想一下泛型具体是如何实现的，用**javap Test**看doSth的方法声明如下：

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Object doSth(java.lang.Object);
&lt;/pre&gt;

如果是受限的泛型，比如：

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&lt;t extends=&quot;&quot; number=&quot;&quot;&gt; {
    public T doSth(T a) {
        return a;
    }
}


那么得到的结果则是：

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Number doSth(java.lang.Number);
&lt;/pre&gt;

如果限制类型有两个（比如\&amp;lt;T extends Comparable &amp;amp; Serializable\&amp;gt;）则生成的字节码中选用第一个（Comparable）。Java中的泛型是伪泛型，在运行期间，所有的泛型信息都会被擦除。也就是说在生成的Java字节码中没有包含泛型中的类型信息。那么在重载的时候会有什么影响，举个例子：

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void doSth(List&lt;integer&gt; list) { }
    public void doSth(List&lt;string&gt; list) { }
}


现在应该会猜到：**因为类型擦除，这个类是不能被编译通过的。**那么下面这段代码呢？

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public Integer doSth(List&lt;integer&gt; list) { return null; }
    public String doSth(List&lt;string&gt; list) { return null; }
}


编译通过了。这貌似与我们之前对重载的认识不相同：函数之间的区分是依据参数和方法名，返回值并不参与。上面这段代码中常在不是根据返回值来判断的，但是增加不同类型的返回值是的这两个方法能够共存在同一个Class文件中：
&amp;gt; 重载要求方法有不同的方法签名，而返回值并不在方法签名中。但是在Class文件格式中，只要描述符不是完全一致的方法就可以共存，也就是说：返回值也能影响方法能不能共存在同一个Class中。
可以通过javap -s Test看到方法签名。

## 获取泛型的类型

首先来看通过**ParameterizedType**获取类型的方法，如下：

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public List&lt;string&gt; list;

    public static void main(String[] args) throws Exception {
        ParameterizedType pt = (ParameterizedType) Test.class.getField(&quot;list&quot;).getGenericType();
        System.out.println(pt.getActualTypeArguments()[0]);
    }
}


其中getGenericType方法返回一个Type对象，如果是一个参数化类型，那么返回的Type会反映源码中使用的实际参数类型，实际的参数类型通过getActualTypeArguments获取。
&lt;/string&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/integer&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/integer&gt;&lt;/pre&gt;&lt;/t&gt;&lt;/pre&gt;&lt;/string&gt;&lt;/string&gt;&lt;/t&gt;&lt;/t&gt;&lt;/pre&gt;&lt;/t&gt;&lt;/pre&gt;&lt;/t&gt;&lt;/pre&gt;&lt;/t&gt;&lt;/t&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Linux内存管理</title>
        <description>
</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>歌德尔不完备定理</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;希尔伯特&lt;/strong&gt;是19世纪和20世纪初最具影响力的数学家之一，在严格化的大纷争中，他带领的形式主义派系技压群雄，得到许多当时有名望的数学家的支持。希尔伯特打算通过形式化的手段，将证明抽象成一堆符号的转换。令人惊奇的是这似乎真的可行！为此，希尔伯特希望能够证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，对任意的陈述，都能判断出真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，这一企图被&lt;strong&gt;哥德尔&lt;/strong&gt;的博士论文《论数学原理及有关系统中不可判定命题》无情击碎，不完备性定理揭示：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，存在命题，无法证明其真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这在当时的数学界掀起轩然大波，它不仅具有数学意义，还蕴含着深刻的哲学意义。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;证明&lt;/h2&gt;

&lt;p&gt;不能判断出真伪，自然就想到古老的悖论：&lt;strong&gt;这句话是假的&lt;/strong&gt;（说它真也不行，说它假也不行！）。1905年法国数学家&lt;strong&gt;理查德&lt;/strong&gt;在数学系统中构造出来这样的悖论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用语言描述自然数的性质；&lt;/li&gt;
  &lt;li&gt;将性质的描述语言映射到一个自然数；&lt;/li&gt;
  &lt;li&gt;如果自然数不符合对应的性质，则称其具有理查兹性，该自然数称为理查德数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理查兹性也是一个自然数的性质，对应的编号为N，那么N是理查德数吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理查德悖论&lt;/strong&gt;是有瑕疵的：自然数的性质应该是“能被2整除”、“大于100”等，而理查兹性质则把性质和描述性质的语言纠缠在一起了！&lt;/p&gt;

&lt;p&gt;罗素和一些人认为如果把对象语言和讨论对象语言的&lt;strong&gt;元语言&lt;/strong&gt;区分开来就能避免这种问题。希尔伯特用精确的形式语言构建的形式公理系统，已经严格区分了数学和元数学，建立起隔离墙，堵住了这个漏洞。哥德尔要想把&lt;strong&gt;这个公式是不可证明的&lt;/strong&gt;放在系统里，必须绕过这堵墙，用数学语言来描述即证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任何相容的形式系统，只要蕴含皮亚诺算术公理，就可以在其中构造在体系中不能被证明的命题，因此通过推演不能得到所有的真命题（即体系是不完备的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓&lt;strong&gt;相容&lt;/strong&gt;，就是不矛盾，所谓&lt;strong&gt;完备&lt;/strong&gt;，就是所有的真理都能被形式证明，所谓&lt;strong&gt;皮亚诺算术公理&lt;/strong&gt;是指意大利数学家&lt;strong&gt;皮亚诺&lt;/strong&gt;提出的关于自然数的五条公理系统：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1是自然数&lt;/li&gt;
  &lt;li&gt;每一个确定的自然数a都有一个确定的后继数a’&lt;/li&gt;
  &lt;li&gt;当且仅当b’=c’时有b=c&lt;/li&gt;
  &lt;li&gt;1不是任何自然数的后继数&lt;/li&gt;
  &lt;li&gt;任意关于自然数的命题，如果证明1是对的，并且假设n对的情况下n’也是对的，那么所有的自然数都是对的（数学归纳法）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据这五条公理系统可以建立起一阶算术系统。&lt;/p&gt;

&lt;p&gt;我们来看哥德尔的证明，首先他将命题映射成自然数，现在搞计算机的一看可能觉得用Unicode不就完了？但是这个论文比计算机早了很多年，可以了解一下&lt;strong&gt;哥德尔编码&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;G(F)：命题F(x)的哥德尔数。
P(x)：在系统中哥德尔数x对应的命题是可证明的。
SU(z)：对于F(x)有z=G(F)，设y是命题F(G(F))的哥德尔数，则有~P(y)成立。
p：SU(G(SU))。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当问到p是否为真的时候，我们其实就是在问&lt;strong&gt;不可证这个特性本身是不可证的吗？&lt;/strong&gt;这样就造成了矛盾（这是Wikipedia上面给出的）。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;意义&lt;/h2&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</link>
        <guid isPermaLink="true">/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</guid>
        
        
        <category>数学</category>
        
      </item>
    
      <item>
        <title>2015/5~2015/7</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;计划&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;工作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;拣选单执行情况实时计算完成&lt;/li&gt;
  &lt;li&gt;大宝监控方案设计&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;生活&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一周最少五天晨跑(2KM)&lt;/li&gt;
  &lt;li&gt;五月份每周一次10KM晨跑，六月份每周一次半马(21KM)&lt;/li&gt;
  &lt;li&gt;结婚&lt;/li&gt;
  &lt;li&gt;找个避暑的地方玩一把&lt;/li&gt;
  &lt;li&gt;放弃DOTA &amp;gt;_&amp;lt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;读书&amp;amp;学习&lt;/h3&gt;

&lt;p&gt;读一些开阔视野但是不需要深入思考的书：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s1331728.jpg&quot; alt=&quot;费马大定理&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s3010562.jpg&quot; alt=&quot;哥德尔证明&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s10685385.jpg&quot; alt=&quot;自控力&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s1055134.jpg&quot; alt=&quot;晚清七十年&quot; /&gt;&lt;/p&gt;

&lt;p&gt;精读并实践进而转化成自己的技能的书：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s7661036.jpg&quot; alt=&quot;编程语言实现模式&quot; /&gt;
&lt;img src=&quot;http://img5.douban.com/mpic/s24436529.jpg&quot; alt=&quot;The Definitive ANTLR 4 Reference&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;完成情况&lt;/h2&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/13/15-5-6.html</link>
        <guid isPermaLink="true">/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/13/15-5-6.html</guid>
        
        
        <category>里程碑</category>
        
      </item>
    
      <item>
        <title>Java 解惑</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s1491187.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这本书给我们列举了很多Java编程中容易产生迷惑的地方，先看几个例子：&lt;/p&gt;

&lt;p&gt;1、在刚开始学编程的时候都会遇到swap操作，开始作为一个新手老老实实地用另外一个变量tmp来存，偶然看到用异或来实现感觉好牛逼，不过这种方式在Java上行不通：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
int x = 1;
int y = 2;
x ^= y ^= x ^= y;
System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y);
&lt;/pre&gt;

&lt;p&gt;出乎意料地是这段代码执行的结果是x = 0 y = 1，而不是希望的x = 2 y = 1，接下来从字节码（javap -c）中找答案：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
   0:   iconst_1
   1:   istore_1
   2:   iconst_2
   3:   istore_2
   4:   iload_1
   5:   iload_2
   6:   iload_1
   7:   iload_2
   8:   ixor
   9:   dup
   10:  istore_1
   11:  ixor
   12:  dup
   13:  istore_2
   14:  ixor
   15:  istore_1
&lt;/pre&gt;
&lt;p&gt;原来执行过程竟然是这样的，为了更清晰给一个图来看栈帧的变化：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Java解惑-Stack.png&quot; alt=&quot;栈帧的变化&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Java语言规范描述中：操作符的操作数是从左到右求值的，对于x^=expr的表达式，x的值是在计算expr之前被提取的，那么因此也就有了上面这个结果。&lt;/p&gt;

&lt;p&gt;2、在做ACM的时候经常会用到位操作，但是被下面这个代码还是惊了一下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
int i = 0;
while (-1 &amp;lt;&amp;lt; i != 0)
    i++;
System.out.println(i);// 没输出，死循环啦。
&lt;/pre&gt;

&lt;p&gt;对于-1直观的想法是在i=32的时候&lt;strong&gt;-1&amp;lt;&amp;lt;i==0&lt;/strong&gt;，因为左移了32位嘛，随便什么数都成0了。&lt;/p&gt;

&lt;p&gt;原因很简单：对于太大的数位操作会取模，比如int来说移位数为&lt;strong&gt;i&amp;amp;31&lt;/strong&gt;，对于long来说移位数为&lt;strong&gt;i&amp;amp;63&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;3、对于初始化顺序大家应该都是知道的，但是当看到下面这段代码输出9900的时候还是得仔细看一下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestMain {
    static {
        initializeIfNecessary();
    }
    private static int sum;

    public static int getSum() {
        initializeIfNecessary();
        return sum;
    }

    private static boolean initialized = false;// 这里会设置成false。

    private static synchronized void initializeIfNecessary() {
        if (!initialized) {
            for (int i = 0; i &amp;lt; 100; i++)
                sum += i;
            initialized = true;
        }
    }

    public static void main(String[] args) {
        System.out.println(TestMain.getSum());
    }
}
&lt;/pre&gt;
&lt;p&gt;在加载的时候会先分配内存，然后依次执行static，而其顺序和申明的顺序一致，那么这个结果自然就明白了。&lt;/p&gt;

&lt;p&gt;4、第一眼看去这段代码重写的equals，而且非常正确，但是输出却是&lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class Name {
	private String first, last;
	public Name(String first, String last) {
		this.first = first;
		this.last = last;
	}
	public boolean equals(Object o) {
		if (!(o instanceof Name))
			return false;
		Name n = (Name)o;
		return n.first.equals(first) &amp;amp;&amp;amp; n.last.equals(last);
	}
	public static void main(String[] args) {
		Set s = new HashSet();
		s.add(new Name(&quot;Mickey&quot;, &quot;Mouse&quot;));
		System.out.println(
		s.contains(new Name(&quot;Mickey&quot;, &quot;Mouse&quot;)));
	}
}
&lt;/pre&gt;
&lt;p&gt;这就是没有仔细思考的结果，想一下&lt;strong&gt;HashSet.contains()&lt;/strong&gt;的运行机制就会焕然大悟：肯定是先比较hashCode，相同的情况下才调用equals。所以：&lt;strong&gt;无论何时，只要你覆盖了equals方法，就同时必须覆盖hashCode方法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;5、对于这段代码可能会直观的顺着代码写的顺序去执行，但是非常容易忽略掉一点&lt;strong&gt;static是类初始化的一部分&lt;/strong&gt;，当执行到t.join()的时候貌似主线程在等待t执行完成，但是此时主线程也在等待自己执行完成，所以&lt;strong&gt;死锁&lt;/strong&gt;了。。。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class Lazy {
	private static boolean initialized = false;
	static {
	Thread t = new Thread(new Runnable() {
		public void run() {
			initialized = true;
		}
	});
	t.start();
		try{
			t.join();
		}catch (InterruptedException e){
			throw new AssertionError(e);
		}
	}
	public static void main(String[] args){
		System.out.println(initialized);
	}
}
&lt;/pre&gt;

&lt;p&gt;当然书中的例子并不只上面几个（一共有95个），总体来看有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;小心溢出以及浮点精度&lt;/li&gt;
  &lt;li&gt;NaN是个奇葩&lt;/li&gt;
  &lt;li&gt;继承中的各种陷阱，比如：
    &lt;ul&gt;
      &lt;li&gt;覆写：完全相同的方法。&lt;/li&gt;
      &lt;li&gt;隐藏：完全相同，但是为private。&lt;/li&gt;
      &lt;li&gt;重载：参数类型不同。&lt;/li&gt;
      &lt;li&gt;遮蔽：外面相同名字的变量被里面的变量遮蔽。&lt;/li&gt;
      &lt;li&gt;遮掩：用变量名和类名冲突。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;泛型擦除术&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;不可否认看完这本书的很多例子能帮助我们写出更高质量的代码（比如覆写equels不覆写hashCode），不过很多例子（尤其是继承）编写很多年的工程代码都不会遇到。&lt;/p&gt;

&lt;p&gt;看完这本书最大的收获就是对Java有了更深的理解。另外，像位移这种反直觉的设计真的好吗？&lt;/p&gt;
</description>
        <pubDate>Mon, 11 May 2015 15:22:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/11/Java-Puzzlers.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/11/Java-Puzzlers.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>CGlib</title>
        <description>&lt;p&gt;在学习Spring的时候接触到CGlib，是一个强大的Code生成类库！可以在运行期扩展Java接口，其底层是ASM框架。当然可以直接使用ASM，不过门槛较高。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;代理&lt;/h2&gt;

&lt;p&gt;首先来看JDK中原生的代理实现，首先实现&lt;strong&gt;InvocationHandler&lt;/strong&gt;接口，相当于目标方法的代理：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	System.out.println(&quot;------------------before------------------&quot;);
	Object result = method.invoke(target, args); // 调用方法
	System.out.println(&quot;-------------------after------------------&quot;);
	return result;
}
&lt;/pre&gt;

&lt;p&gt;然后创建代理对象：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
	target.getClass().getInterfaces(), // 要实现的接口
	this); // InvocationHandler的实现
&lt;/pre&gt;

&lt;p&gt;JDK的代理最大的限制在于必须实现接口，而CGlib则并没有设置这个限制，而&lt;strong&gt;MethodInterceptor&lt;/strong&gt;的用法与InvocationHandler几乎相同：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class MyMethodInterceptor implements MethodInterceptor {
	public Object intercept(Object targe, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
		System.out.println(&quot;BEFORE&quot;);
		Object result = methodProxy.invokeSuper(targe, args);
		System.out.println(&quot;AFTER&quot;);
		return result;
	}
	public Object createProxy() {
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(MyService.class);
		enhancer.setCallback(this);
		return enhancer.create();
	}
}
&lt;/pre&gt;

&lt;p&gt;当&lt;strong&gt;Enhancer.setCallbacks&lt;/strong&gt;设置了多个代理类怎么办呢？可以通过&lt;strong&gt;CallbackFilter&lt;/strong&gt;来指定其执行顺序：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface CallbackFilter {
	int accept(Method method);// 返回方法对应的下标
}
&lt;/pre&gt;

&lt;p&gt;总感觉accept这个方法名起得太失败- -!再来看一个&lt;strong&gt;LazyLoader&lt;/strong&gt;的例子，不明觉厉啊：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestLazyLoader {
	static class MyBean {
	}
	static class My {
		MyBean myBean = (MyBean) Enhancer.create(MyBean.class, new MyLazy());
	}
	static class MyLazy implements LazyLoader {
		public Object loadObject() throws Exception {
			System.out.println(&quot;开始延迟加载!&quot;);
			return new MyBean();
		}
	}
	public static void main(String[] args) {
		My my = new My();
		System.out.println(my.myBean);// 如果没有这一句，就不会有任何输出
	}
}
&lt;/pre&gt;

&lt;p&gt;感觉有点不可思议，用什么方法才能拦截获取属性这个操作？再仔细想一下，应该不是这样！在System.out.println()执行的时候会调用对象的toString方法，赶紧用&lt;strong&gt;javap -verbose xxx&lt;/strong&gt;来看生成的字节码，发现：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public final java.lang.String toString();
  Code:
   Stack=2, Locals=1, Args_size=1
   0:   aload_0
   1:   dup
   2:   invokevirtual   #30; //Method CGLIB$LOAD_PRIVATE_0:()Ljava/lang/Object;
   5:   invokevirtual   #38; //Method java/lang/Object.toString:()Ljava/lang/String;
   8:   areturn
&lt;/pre&gt;

&lt;p&gt;果然如此:D。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;多继承&lt;/h2&gt;

&lt;p&gt;在Java中都是单继承的，当然CGlib也没办法打破这个限制，用多继承来描述&lt;strong&gt;Mixin&lt;/strong&gt;貌似并不合适，但现在也没想到其他更好的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void main(String[] args) {
	Mixin mixin = Mixin.create(new Class[] { Inter1.class, Inter2.class },
	new Object[] {
		new Inter1() {
			public void fun1(String arg0) {
				System.out.println(&quot;Inter1 - &quot; + arg0);
			}
		},
		new Inter2() {
			public void fun1(String arg0) {
				System.out.println(&quot;Inter2 - &quot; + arg0);
			}
			public void fun2(int arg0) {
				System.out.println(&quot;Inter2 - &quot; + arg0);
			}
		},
	});
	Inter1 inter1 = (Inter1) mixin;
	inter1.fun1(&quot;hello&quot;);// Inter1 - hello
	Inter2 inter2 = (Inter2) mixin;
	inter2.fun1(&quot;world&quot;);// Inter1 - world
	inter2.fun2(999);// Inter2 - 999
}
&lt;/pre&gt;

&lt;p&gt;在多个类中有多个相同的方法时，总是前面的覆盖后面的，在底层具体的实现中应该是循环多次继承来实现多重继承的效果。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;工具类&lt;/h2&gt;

&lt;p&gt;在业务代码中总会涉及到各种DO、BO、DTO等等，并需要经常在他们之间转化，CGlib提供了BeanCopier用来自动完成相同属性名称的映射：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class A {
	private int a = 1;
	private int b = 2;
	/** Setter And Getter */
}
static class B {
	private int a = 3;
	private int c = 4;
	/** Setter And Getter */
}
public static void main(String[] args) {
	BeanCopier beanCopier = BeanCopier.create(A.class, B.class, false);
	A a = new A();
	B b = new B();
	beanCopier.copy(a, b, null);// 从a拷贝到b
	System.out.println(a.a + &quot; &quot; + a.b); // 1 2
	System.out.println(b.a + &quot; &quot; + b.c); // 1 4
}
&lt;/pre&gt;

&lt;p&gt;当类型不匹配的时候需要用&lt;strong&gt;Converter&lt;/strong&gt;进行转换：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface Converter {
	/**
	* @param value 源对象属性
	* @param targetClass 目标对象属性类
	* @param setterName 目标对象setter方法名
	* @return 转换后的结果
	*/
	java.lang.Object convert(Object value, Class targetClass, Object setterName);
}
&lt;/pre&gt;

&lt;p&gt;另外和Bean相关的还有其他几个类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;BeanGenerator&lt;/strong&gt;：根据Map动态生成BeanClass。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BeanMap&lt;/strong&gt;：将Bean转换成一个Map。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BulkBean&lt;/strong&gt;：更方便地操作属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CGlib提供了&lt;strong&gt;FastClass&lt;/strong&gt;来方便地进行反射操作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/wsztrush/cglib-demo&quot;&gt;这里&lt;/a&gt;有我写的一些测试DEMO。最后，其他操作字节码的工具还有：javassist，BCEL，ASM等。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 May 2015 15:22:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/11/Cglib.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/11/Cglib.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>REWORK</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s4502451.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一次听说这本说是在看陈皓在公司做的一次演讲，里面提到：&lt;strong&gt;条件受限是好事&lt;/strong&gt;。工作的久了，很多事情早在这边书之前就有所感悟，下面是几个印象深刻的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;哪里来的从错误中学习；&lt;/li&gt;
  &lt;li&gt;工作狂；&lt;/li&gt;
  &lt;li&gt;“没时间”不是借口；&lt;/li&gt;
  &lt;li&gt;条件受限是好事；&lt;/li&gt;
  &lt;li&gt;会议有毒；&lt;/li&gt;
  &lt;li&gt;给竞争力做减法；&lt;/li&gt;
  &lt;li&gt;养成对客户说“不”的习惯；&lt;/li&gt;
  &lt;li&gt;普及知识，赢得竞争；&lt;/li&gt;
  &lt;li&gt;主动掌控负面新闻；&lt;/li&gt;
  &lt;li&gt;文化不是由谁创造的；&lt;/li&gt;
  &lt;li&gt;灵感稍纵即逝；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际的工作中常常会有很多问题被忽略掉，而往往它们就是效率最大的敌人。要变得更好？那么将学到的东西慢慢地融入到平时的行为中！&lt;/p&gt;
</description>
        <pubDate>Fri, 08 May 2015 21:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/08/Rework.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/08/Rework.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
  </channel>
</rss>
