<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 13 May 2015 22:21:17 +0800</pubDate>
    <lastBuildDate>Wed, 13 May 2015 22:21:17 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Linux内存管理</title>
        <description>
</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>歌德尔不完备定理</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;希尔伯特&lt;/strong&gt;是19世纪和20世纪初最具影响力的数学家之一，在严格化的大纷争中，他带领的形式主义派系技压群雄，得到许多当时有名望的数学家的支持。希尔伯特打算通过形式化的手段，将证明抽象成一堆符号的转换。令人惊奇的是这似乎真的可行！为此，希尔伯特希望能够证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，对任意的陈述，都能判断出真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，这一企图被&lt;strong&gt;哥德尔&lt;/strong&gt;的博士论文《论数学原理及有关系统中不可判定命题》无情击碎，不完备性定理揭示：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，存在命题，无法证明其真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这在当时的数学界掀起轩然大波，它不仅具有数学意义，还蕴含着深刻的哲学意义。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;证明&lt;/h2&gt;

&lt;p&gt;不能判断出真伪，自然就想到古老的悖论：&lt;strong&gt;这句话是假的&lt;/strong&gt;（说它真也不行，说它假也不行！）。1905年法国数学家&lt;strong&gt;理查德&lt;/strong&gt;在数学系统中构造出来这样的悖论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用语言描述自然数的性质；&lt;/li&gt;
  &lt;li&gt;将性质的描述语言映射到一个自然数；&lt;/li&gt;
  &lt;li&gt;如果自然数不符合对应的性质，则称其具有理查兹性，该自然数称为理查德数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理查兹性也是一个自然数的性质，对应的编号为N，那么N是理查德数吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理查德悖论&lt;/strong&gt;是有瑕疵的：自然数的性质应该是“能被2整除”、“大于100”等，而理查兹性质则把性质和描述性质的语言纠缠在一起了！&lt;/p&gt;

&lt;p&gt;罗素和一些人认为如果把对象语言和讨论对象语言的&lt;strong&gt;元语言&lt;/strong&gt;区分开来就能避免这种问题。希尔伯特用精确的形式语言构建的形式公理系统，已经严格区分了数学和元数学，建立起隔离墙，堵住了这个漏洞。哥德尔要想把&lt;strong&gt;这个公式是不可证明的&lt;/strong&gt;放在系统里，必须绕过这堵墙，用数学语言来描述即证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任何相容的形式系统，只要蕴含皮亚诺算术公理，就可以在其中构造在体系中不能被证明的命题，因此通过推演不能得到所有的真命题（即体系是不完备的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓&lt;strong&gt;相容&lt;/strong&gt;，就是不矛盾，所谓&lt;strong&gt;完备&lt;/strong&gt;，就是所有的真理都能被形式证明，所谓&lt;strong&gt;皮亚诺算术公理&lt;/strong&gt;是指意大利数学家&lt;strong&gt;皮亚诺&lt;/strong&gt;提出的关于自然数的五条公理系统：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1是自然数&lt;/li&gt;
  &lt;li&gt;每一个确定的自然数a都有一个确定的后继数a’&lt;/li&gt;
  &lt;li&gt;当且仅当b’=c’时有b=c&lt;/li&gt;
  &lt;li&gt;1不是任何自然数的后继数&lt;/li&gt;
  &lt;li&gt;任意关于自然数的命题，如果证明1是对的，并且假设n对的情况下n’也是对的，那么所有的自然数都是对的（数学归纳法）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据这五条公理系统可以建立起一阶算术系统。&lt;/p&gt;

&lt;p&gt;我们来看哥德尔的证明，首先他将命题映射成自然数，现在搞计算机的一看可能觉得用Unicode不就完了？但是这个论文比计算机早了很多年，可以了解一下&lt;strong&gt;哥德尔编码&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;G(F)：命题F(x)的哥德尔数。
P(x)：在系统中哥德尔数x对应的命题是可证明的。
SU(z)：对于F(x)有z=G(F)，设y是命题F(G(F))的哥德尔数，则有~P(y)成立。
p：SU(G(SU))。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当问到p是否为真的时候，我们其实就是在问&lt;strong&gt;不可证这个特性本身是不可证的吗？&lt;/strong&gt;这样就造成了矛盾（这是Wikipedia上面给出的）。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;意义&lt;/h2&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</link>
        <guid isPermaLink="true">/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</guid>
        
        
        <category>数学</category>
        
      </item>
    
      <item>
        <title>2015/5~2015/7</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;计划&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;工作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;拣选单执行情况实时计算完成&lt;/li&gt;
  &lt;li&gt;大宝监控方案设计&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;生活&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一周最少五天晨跑(2KM)&lt;/li&gt;
  &lt;li&gt;五月份每周一次10KM晨跑，六月份每周一次半马(21KM)&lt;/li&gt;
  &lt;li&gt;结婚&lt;/li&gt;
  &lt;li&gt;找个避暑的地方玩一把&lt;/li&gt;
  &lt;li&gt;放弃DOTA &amp;gt;_&amp;lt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;读书&amp;amp;学习&lt;/h3&gt;

&lt;p&gt;读一些开阔视野但是不需要深入思考的书：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s1331728.jpg&quot; alt=&quot;费马大定理&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s3010562.jpg&quot; alt=&quot;哥德尔证明&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s10685385.jpg&quot; alt=&quot;自控力&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s1055134.jpg&quot; alt=&quot;晚清七十年&quot; /&gt;&lt;/p&gt;

&lt;p&gt;精读并实践进而转化成自己的技能的书：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s7661036.jpg&quot; alt=&quot;编程语言实现模式&quot; /&gt;
&lt;img src=&quot;http://img5.douban.com/mpic/s24436529.jpg&quot; alt=&quot;The Definitive ANTLR 4 Reference&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;完成情况&lt;/h2&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/13/15-5-6.html</link>
        <guid isPermaLink="true">/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/13/15-5-6.html</guid>
        
        
        <category>里程碑</category>
        
      </item>
    
      <item>
        <title>Java 解惑</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s1491187.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这本书给我们列举了很多Java编程中容易产生迷惑的地方，先看几个例子：&lt;/p&gt;

&lt;p&gt;1、在刚开始学编程的时候都会遇到swap操作，开始作为一个新手老老实实地用另外一个变量tmp来存，偶然看到用异或来实现感觉好牛逼，不过这种方式在Java上行不通：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
int x = 1;
int y = 2;
x ^= y ^= x ^= y;
System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y);
&lt;/pre&gt;

&lt;p&gt;出乎意料地是这段代码执行的结果是x = 0 y = 1，而不是希望的x = 2 y = 1，接下来从字节码（javap -c）中找答案：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
   0:   iconst_1
   1:   istore_1
   2:   iconst_2
   3:   istore_2
   4:   iload_1
   5:   iload_2
   6:   iload_1
   7:   iload_2
   8:   ixor
   9:   dup
   10:  istore_1
   11:  ixor
   12:  dup
   13:  istore_2
   14:  ixor
   15:  istore_1
&lt;/pre&gt;
&lt;p&gt;原来执行过程竟然是这样的，为了更清晰给一个图来看栈帧的变化：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Java解惑-Stack.png&quot; alt=&quot;栈帧的变化&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Java语言规范描述中：操作符的操作数是从左到右求值的，对于x^=expr的表达式，x的值是在计算expr之前被提取的，那么因此也就有了上面这个结果。&lt;/p&gt;

&lt;p&gt;2、在做ACM的时候经常会用到位操作，但是被下面这个代码还是惊了一下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
int i = 0;
while (-1 &amp;lt;&amp;lt; i != 0)
    i++;
System.out.println(i);// 没输出，死循环啦。
&lt;/pre&gt;

&lt;p&gt;对于-1直观的想法是在i=32的时候&lt;strong&gt;-1&amp;lt;&amp;lt;i==0&lt;/strong&gt;，因为左移了32位嘛，随便什么数都成0了。&lt;/p&gt;

&lt;p&gt;原因很简单：对于太大的数位操作会取模，比如int来说移位数为&lt;strong&gt;i&amp;amp;31&lt;/strong&gt;，对于long来说移位数为&lt;strong&gt;i&amp;amp;63&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;3、对于初始化顺序大家应该都是知道的，但是当看到下面这段代码输出9900的时候还是得仔细看一下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestMain {
    static {
        initializeIfNecessary();
    }
    private static int sum;

    public static int getSum() {
        initializeIfNecessary();
        return sum;
    }

    private static boolean initialized = false;// 这里会设置成false。

    private static synchronized void initializeIfNecessary() {
        if (!initialized) {
            for (int i = 0; i &amp;lt; 100; i++)
                sum += i;
            initialized = true;
        }
    }

    public static void main(String[] args) {
        System.out.println(TestMain.getSum());
    }
}
&lt;/pre&gt;
&lt;p&gt;在加载的时候会先分配内存，然后依次执行static，而其顺序和申明的顺序一致，那么这个结果自然就明白了。&lt;/p&gt;

&lt;p&gt;4、第一眼看去这段代码重写的equals，而且非常正确，但是输出却是&lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class Name {
	private String first, last;
	public Name(String first, String last) {
		this.first = first;
		this.last = last;
	}
	public boolean equals(Object o) {
		if (!(o instanceof Name))
			return false;
		Name n = (Name)o;
		return n.first.equals(first) &amp;amp;&amp;amp; n.last.equals(last);
	}
	public static void main(String[] args) {
		Set s = new HashSet();
		s.add(new Name(&quot;Mickey&quot;, &quot;Mouse&quot;));
		System.out.println(
		s.contains(new Name(&quot;Mickey&quot;, &quot;Mouse&quot;)));
	}
}
&lt;/pre&gt;
&lt;p&gt;这就是没有仔细思考的结果，想一下&lt;strong&gt;HashSet.contains()&lt;/strong&gt;的运行机制就会焕然大悟：肯定是先比较hashCode，相同的情况下才调用equals。所以：&lt;strong&gt;无论何时，只要你覆盖了equals方法，就同时必须覆盖hashCode方法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;5、对于这段代码可能会直观的顺着代码写的顺序去执行，但是非常容易忽略掉一点&lt;strong&gt;static是类初始化的一部分&lt;/strong&gt;，当执行到t.join()的时候貌似主线程在等待t执行完成，但是此时主线程也在等待自己执行完成，所以&lt;strong&gt;死锁&lt;/strong&gt;了。。。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class Lazy {
	private static boolean initialized = false;
	static {
	Thread t = new Thread(new Runnable() {
		public void run() {
			initialized = true;
		}
	});
	t.start();
		try{
			t.join();
		}catch (InterruptedException e){
			throw new AssertionError(e);
		}
	}
	public static void main(String[] args){
		System.out.println(initialized);
	}
}
&lt;/pre&gt;

&lt;p&gt;当然书中的例子并不只上面几个（一共有95个），总体来看有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;小心溢出以及浮点精度&lt;/li&gt;
  &lt;li&gt;NaN是个奇葩&lt;/li&gt;
  &lt;li&gt;继承中的各种陷阱，比如：
    &lt;ul&gt;
      &lt;li&gt;覆写：完全相同的方法。&lt;/li&gt;
      &lt;li&gt;隐藏：完全相同，但是为private。&lt;/li&gt;
      &lt;li&gt;重载：参数类型不同。&lt;/li&gt;
      &lt;li&gt;遮蔽：外面相同名字的变量被里面的变量遮蔽。&lt;/li&gt;
      &lt;li&gt;遮掩：用变量名和类名冲突。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;泛型擦除术&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;不可否认看完这本书的很多例子能帮助我们写出更高质量的代码（比如覆写equels不覆写hashCode），不过很多例子（尤其是继承）编写很多年的工程代码都不会遇到。&lt;/p&gt;

&lt;p&gt;看完这本书最大的收获就是对Java有了更深的理解。另外，像位移这种反直觉的设计真的好吗？&lt;/p&gt;
</description>
        <pubDate>Mon, 11 May 2015 15:22:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/11/Java-Puzzlers.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/11/Java-Puzzlers.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>CGlib</title>
        <description>&lt;p&gt;在学习Spring的时候接触到CGlib，是一个强大的Code生成类库！可以在运行期扩展Java接口，其底层是ASM框架。当然可以直接使用ASM，不过门槛较高。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;代理&lt;/h2&gt;

&lt;p&gt;首先来看JDK中原生的代理实现，首先实现&lt;strong&gt;InvocationHandler&lt;/strong&gt;接口，相当于目标方法的代理：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
	System.out.println(&quot;------------------before------------------&quot;);
	Object result = method.invoke(target, args); // 调用方法
	System.out.println(&quot;-------------------after------------------&quot;);
	return result;
}
&lt;/pre&gt;

&lt;p&gt;然后创建代理对象：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
	target.getClass().getInterfaces(), // 要实现的接口
	this); // InvocationHandler的实现
&lt;/pre&gt;

&lt;p&gt;JDK的代理最大的限制在于必须实现接口，而CGlib则并没有设置这个限制，而&lt;strong&gt;MethodInterceptor&lt;/strong&gt;的用法与InvocationHandler几乎相同：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class MyMethodInterceptor implements MethodInterceptor {
	public Object intercept(Object targe, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
		System.out.println(&quot;BEFORE&quot;);
		Object result = methodProxy.invokeSuper(targe, args);
		System.out.println(&quot;AFTER&quot;);
		return result;
	}
	public Object createProxy() {
		Enhancer enhancer = new Enhancer();
		enhancer.setSuperclass(MyService.class);
		enhancer.setCallback(this);
		return enhancer.create();
	}
}
&lt;/pre&gt;

&lt;p&gt;当&lt;strong&gt;Enhancer.setCallbacks&lt;/strong&gt;设置了多个代理类怎么办呢？可以通过&lt;strong&gt;CallbackFilter&lt;/strong&gt;来指定其执行顺序：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface CallbackFilter {
	int accept(Method method);// 返回方法对应的下标
}
&lt;/pre&gt;

&lt;p&gt;总感觉accept这个方法名起得太失败- -!再来看一个&lt;strong&gt;LazyLoader&lt;/strong&gt;的例子，不明觉厉啊：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestLazyLoader {
	static class MyBean {
	}
	static class My {
		MyBean myBean = (MyBean) Enhancer.create(MyBean.class, new MyLazy());
	}
	static class MyLazy implements LazyLoader {
		public Object loadObject() throws Exception {
			System.out.println(&quot;开始延迟加载!&quot;);
			return new MyBean();
		}
	}
	public static void main(String[] args) {
		My my = new My();
		System.out.println(my.myBean);// 如果没有这一句，就不会有任何输出
	}
}
&lt;/pre&gt;

&lt;p&gt;感觉有点不可思议，用什么方法才能拦截获取属性这个操作？再仔细想一下，应该不是这样！在System.out.println()执行的时候会调用对象的toString方法，赶紧用&lt;strong&gt;javap -verbose xxx&lt;/strong&gt;来看生成的字节码，发现：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public final java.lang.String toString();
  Code:
   Stack=2, Locals=1, Args_size=1
   0:   aload_0
   1:   dup
   2:   invokevirtual   #30; //Method CGLIB$LOAD_PRIVATE_0:()Ljava/lang/Object;
   5:   invokevirtual   #38; //Method java/lang/Object.toString:()Ljava/lang/String;
   8:   areturn
&lt;/pre&gt;

&lt;p&gt;果然如此:D。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;多继承&lt;/h2&gt;

&lt;p&gt;在Java中都是单继承的，当然CGlib也没办法打破这个限制，用多继承来描述&lt;strong&gt;Mixin&lt;/strong&gt;貌似并不合适，但现在也没想到其他更好的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void main(String[] args) {
	Mixin mixin = Mixin.create(new Class[] { Inter1.class, Inter2.class },
	new Object[] {
		new Inter1() {
			public void fun1(String arg0) {
				System.out.println(&quot;Inter1 - &quot; + arg0);
			}
		},
		new Inter2() {
			public void fun1(String arg0) {
				System.out.println(&quot;Inter2 - &quot; + arg0);
			}
			public void fun2(int arg0) {
				System.out.println(&quot;Inter2 - &quot; + arg0);
			}
		},
	});
	Inter1 inter1 = (Inter1) mixin;
	inter1.fun1(&quot;hello&quot;);// Inter1 - hello
	Inter2 inter2 = (Inter2) mixin;
	inter2.fun1(&quot;world&quot;);// Inter1 - world
	inter2.fun2(999);// Inter2 - 999
}
&lt;/pre&gt;

&lt;p&gt;在多个类中有多个相同的方法时，总是前面的覆盖后面的，在底层具体的实现中应该是循环多次继承来实现多重继承的效果。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;工具类&lt;/h2&gt;

&lt;p&gt;在业务代码中总会涉及到各种DO、BO、DTO等等，并需要经常在他们之间转化，CGlib提供了BeanCopier用来自动完成相同属性名称的映射：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class A {
	private int a = 1;
	private int b = 2;
	/** Setter And Getter */
}
static class B {
	private int a = 3;
	private int c = 4;
	/** Setter And Getter */
}
public static void main(String[] args) {
	BeanCopier beanCopier = BeanCopier.create(A.class, B.class, false);
	A a = new A();
	B b = new B();
	beanCopier.copy(a, b, null);// 从a拷贝到b
	System.out.println(a.a + &quot; &quot; + a.b); // 1 2
	System.out.println(b.a + &quot; &quot; + b.c); // 1 4
}
&lt;/pre&gt;

&lt;p&gt;当类型不匹配的时候需要用&lt;strong&gt;Converter&lt;/strong&gt;进行转换：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface Converter {
	/**
	* @param value 源对象属性
	* @param targetClass 目标对象属性类
	* @param setterName 目标对象setter方法名
	* @return 转换后的结果
	*/
	java.lang.Object convert(Object value, Class targetClass, Object setterName);
}
&lt;/pre&gt;

&lt;p&gt;另外和Bean相关的还有其他几个类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;BeanGenerator&lt;/strong&gt;：根据Map动态生成BeanClass。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BeanMap&lt;/strong&gt;：将Bean转换成一个Map。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;BulkBean&lt;/strong&gt;：更方便地操作属性。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CGlib提供了&lt;strong&gt;FastClass&lt;/strong&gt;来方便地进行反射操作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/wsztrush/cglib-demo&quot;&gt;这里&lt;/a&gt;有我写的一些测试DEMO。最后，其他操作字节码的工具还有：javassist，BCEL，ASM等。&lt;/p&gt;
</description>
        <pubDate>Mon, 11 May 2015 15:22:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/11/Cglib.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/11/Cglib.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>REWORK</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s4502451.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一次听说这本说是在看陈皓在公司做的一次演讲，里面提到：&lt;strong&gt;条件受限是好事&lt;/strong&gt;。工作的久了，很多事情早在这边书之前就有所感悟，下面是几个印象深刻的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;哪里来的从错误中学习；&lt;/li&gt;
  &lt;li&gt;工作狂；&lt;/li&gt;
  &lt;li&gt;“没时间”不是借口；&lt;/li&gt;
  &lt;li&gt;条件受限是好事；&lt;/li&gt;
  &lt;li&gt;会议有毒；&lt;/li&gt;
  &lt;li&gt;给竞争力做减法；&lt;/li&gt;
  &lt;li&gt;养成对客户说“不”的习惯；&lt;/li&gt;
  &lt;li&gt;普及知识，赢得竞争；&lt;/li&gt;
  &lt;li&gt;主动掌控负面新闻；&lt;/li&gt;
  &lt;li&gt;文化不是由谁创造的；&lt;/li&gt;
  &lt;li&gt;灵感稍纵即逝；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际的工作中常常会有很多问题被忽略掉，而往往它们就是效率最大的敌人。要变得更好？那么将学到的东西慢慢地融入到平时的行为中！&lt;/p&gt;
</description>
        <pubDate>Fri, 08 May 2015 21:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/08/Rework.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/08/Rework.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>JVM之基础</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;之前老大让做一些外包面试，我的问题很简单：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;介绍一下工作中解决过比较有意思的问题。&lt;/li&gt;
  &lt;li&gt;HashMap使用中需要注意的点。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个问题主要是想了解一下对方项目经验的含金量，第二个问题则是测试下是否知道一些细节，比如HashMap是线程不安全的、用HashMap来做缓存的话可能导致内存泄露等，自我感觉问题设计的还可以:D~ 但是看了其他同事的题目就泪崩了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设计模式XXX&lt;/li&gt;
  &lt;li&gt;垃圾回收XXX&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;擦，怎么感觉这个问题我也不会。。。&lt;/p&gt;

&lt;p&gt;虚拟机给人的感觉像是操作系统、编译器：非常高大上。但是Java程序就跑在上面，遇到问题还得去排查，性能不行还得去优化，基础的知识还是需要的！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内存管理&lt;/h2&gt;

&lt;p&gt;Java虚拟机在执行的过程中会把它所管理的内存划分为若干个不同的数据区域，大致如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JVM之基础-内存划分.png&quot; alt=&quot;内存模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;各部分的功能如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;区域&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;程序计数器&lt;/td&gt;
      &lt;td&gt;可以看做当前线程执行字节码的行号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;虚拟机栈&lt;/td&gt;
      &lt;td&gt;存放局部变量、操作栈等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;本地方法栈&lt;/td&gt;
      &lt;td&gt;与虚拟机栈类似，不过是服务于本地方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;堆&lt;/td&gt;
      &lt;td&gt;存放对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;方法区&lt;/td&gt;
      &lt;td&gt;存放类信息、常量、静态变量、JIT编译后的代码等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;运行时常量池&lt;/td&gt;
      &lt;td&gt;编译时生成的各种字面量和符号使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;直接内存&lt;/td&gt;
      &lt;td&gt;通过NIO分配的对外内存&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在内存管理部分比较大的一块内容是GC（垃圾回收），所谓垃圾回收就是将垃圾占用的内存回收掉。那么第一个问题：&lt;strong&gt;什么是垃圾？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;引用计数算法：被引用次数为0的对象。&lt;/li&gt;
  &lt;li&gt;根搜索算法：从GC Roots沿着引用找不到的对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里都提到了&lt;strong&gt;引用&lt;/strong&gt;，在JDK 1.2之后Java就已经对引用的概念进行了扩充，那么第二个问题：&lt;strong&gt;有哪些类型的引用？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;强引用：Object o = new Object()这种都是强引用。&lt;/li&gt;
  &lt;li&gt;弱引用：还有用但非必须的，在OOM之前被回收。&lt;/li&gt;
  &lt;li&gt;软引用：更弱的引用，在下次GC的时候被回收。&lt;/li&gt;
  &lt;li&gt;虚引用：最弱的，唯一的作用是在对象被回收的时候可以收到通知。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里只有强引用才能对对象的生命周期造成影响。在虚拟机发展的过程中进化出不少垃圾回收算法，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;标记-清除算法&lt;/li&gt;
  &lt;li&gt;复制算法&lt;/li&gt;
  &lt;li&gt;标记-整理算法&lt;/li&gt;
  &lt;li&gt;分代收集算法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实际中用到的回收器都是这几种算法的组合，比如从VisualVM中看到的内存是这样的（需要明白各部分都是怎样互相配合的）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JVM之基础-GC.png&quot; alt=&quot;分代回收&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整体上来看是分代收集算法，而S0、S1这两部分可以看做是标记-整理算法。那么第三个问题：&lt;strong&gt;常见的CMS垃圾回收器的执行流程是怎样的？&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始标记：GC Roots直接关联的对象。&lt;/li&gt;
  &lt;li&gt;并发标记：Root Tracing。&lt;/li&gt;
  &lt;li&gt;重新标记：修复由于程序运行导致标记产生变动。&lt;/li&gt;
  &lt;li&gt;并发清除&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;具体如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JVM之基础-CMS.png&quot; alt=&quot;CMS执行流程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到只有在初始标记和重新标记的时候才需要Stop The World，其他都是和用户线程一起执行，不要以为这就完美了，并行执行的过程会消耗掉一些CPU资源。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;代码执行&lt;/h2&gt;

&lt;p&gt;把Java源码丢给JVM肯定是不能执行的，需要先用javac编译成class文件才行，那么第一个问题：&lt;strong&gt;class文件的结构是怎样的？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常量池&lt;/li&gt;
  &lt;li&gt;访问标志&lt;/li&gt;
  &lt;li&gt;类索引、父类索引和接口索引&lt;/li&gt;
  &lt;li&gt;字段表&lt;/li&gt;
  &lt;li&gt;方法表&lt;/li&gt;
  &lt;li&gt;属性表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;虚拟机规范并没有规定在什么时候要加载类，但是规定了在遇到&lt;strong&gt;new、反射、父类、Main&lt;/strong&gt;的时候需要初始化完成。整个类的生命周期如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JVM之基础-类生命周期.png&quot; alt=&quot;类的生命周期&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在虚拟机中通过ClassLoader来进行类的加载，这地方需要明白：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;两个类是否相同，除了类名外还需要判断ClassLoader是否相同。&lt;/li&gt;
  &lt;li&gt;双亲委派模式并不是一个强制约束。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在类加载完成之后就可以开始执行了，和线程运转相关的东西都放在栈帧中，其结构如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;作用/含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;局部变量表&lt;/td&gt;
      &lt;td&gt;方法参数及方法内部定义的局部变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;操作数栈&lt;/td&gt;
      &lt;td&gt;用来被指令操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;动态连接&lt;/td&gt;
      &lt;td&gt;指向运行时常量池中该栈帧所属方法的引用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;方法返回地址&lt;/td&gt;
      &lt;td&gt;上层方法调用本方法的位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;附加信息&lt;/td&gt;
      &lt;td&gt;调试信息等&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;执行中具体调用哪个方法是个头疼的问题，需要处理：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;静态分派：相同名称、不同参数类型的方法。&lt;/li&gt;
  &lt;li&gt;动态分派：继承中复写的方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;字节码中的指令都是基于栈的操作，比如要完成1+1这样的计算，对应的指令如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
iconst_1 // 将常量1压入栈
iconst_1
iadd // 把栈顶的两个值相加并出栈，然后把结果放回栈
istore_0 // 将栈顶的值放到局部变量表第0个Solt
&lt;/pre&gt;

&lt;p&gt;解释执行的好处是下载后启动速度快，但是确定也非常明显：运行速度慢。JIT正是用来解决这个问题的，能够将&lt;strong&gt;多次调用的方法、多次执行的循环体&lt;/strong&gt;编译成本地代码。&lt;/p&gt;

&lt;p&gt;优化是个很好玩的题目，记得在参加一次变成比赛的时候用gcc -O3编译之后的代码把printf()都没输出了。。在JIT中比较常见的优化手段有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;手段&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;公共子表达式消除&lt;/td&gt;
      &lt;td&gt;如果一个表达式已经计算过了，那么后面不需要重复计算&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数组范围检查消除&lt;/td&gt;
      &lt;td&gt;并不是必须一次不漏地检查&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;方法内联&lt;/td&gt;
      &lt;td&gt;把代码复制到调用方法中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;逃逸分析&lt;/td&gt;
      &lt;td&gt;判断对象是否可能被方法外引用到&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;程序执行一定会涉及到内存操作，在Java中定义了八种操作来完成：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;lock&lt;/td&gt;
      &lt;td&gt;把一个变量标识为线程独占状态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;unlock&lt;/td&gt;
      &lt;td&gt;释放变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;read&lt;/td&gt;
      &lt;td&gt;将变量从主存读取到工作内存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;load&lt;/td&gt;
      &lt;td&gt;将read到的变量值放入工作内存中的副本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;use&lt;/td&gt;
      &lt;td&gt;将工作内存中的变量传递给执行引擎&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;assign&lt;/td&gt;
      &lt;td&gt;引擎返回的值传递给工作内存中的副本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;store&lt;/td&gt;
      &lt;td&gt;将工作内存中的变量传递给主存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;write&lt;/td&gt;
      &lt;td&gt;把从工作内存得到的变量写入主存对应的变量中&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这里有必要讲一下&lt;strong&gt;volatile&lt;/strong&gt;的作用，在使用到的时候能明白下面两条即可：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;保证变量对所有线程是可见的。&lt;/li&gt;
  &lt;li&gt;禁止&lt;a href=&quot;http://ifeve.com/jvm-memory-reordering/&quot;&gt;指令重排&lt;/a&gt;优化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果Java中所有的操作都需要程序员来控制的话，会有大量的重复代码，而且写起来很累，那么我们可以通过&lt;strong&gt;先行发生原则&lt;/strong&gt;来判断并行的两个操作是否存在冲突：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程序次序规则：单线程内按照程序书写顺序。&lt;/li&gt;
  &lt;li&gt;管程锁定规则：unlock必须在lock之前。&lt;/li&gt;
  &lt;li&gt;volatile变量规则：写操作先行发生于读操作。&lt;/li&gt;
  &lt;li&gt;线程启动规则：Thread.start()先于线程的其他任意方法。&lt;/li&gt;
  &lt;li&gt;线程终止规则：线程中所有的操作都先于对此线程的终止检测。&lt;/li&gt;
  &lt;li&gt;线程中断规则：interrupt()先于中断检测。&lt;/li&gt;
  &lt;li&gt;对象终结规则：对象的初始化完成先于它的finalize()方法。&lt;/li&gt;
  &lt;li&gt;传递规则：如果A先于B、B先于C，那么A先于C。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thread的底层实现还是比较麻烦的，但是最起码应该知道Thread的状态是如何进行转换：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JVM之基础-线程状态转换.png&quot; alt=&quot;线程状态转换图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后，常见的同步方式是&lt;strong&gt;synchronized&lt;/strong&gt;或者&lt;strong&gt;aqs&lt;/strong&gt;的各种实现，这里就不讲了，因为每个都足够写一大篇。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 May 2015 21:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/08/JVM-Basis.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/08/JVM-Basis.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>暗时间</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s6586365.jpg&quot; alt=&quot;暗时间&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在很早之前在网上看过前面部分，感觉很受用，所以买下来打算细看一下。细读之前感觉&lt;strong&gt;暗时间&lt;/strong&gt;的含义是指利用琐碎的时间，但完全不是这么回事，这部分的内容花的篇幅很少，想更多的了解可以继续去看《奇特的一生》。&lt;/p&gt;

&lt;p&gt;另外，这本书更像是一个文集，各个文章之间并没有很强的关系，总体上围绕：&lt;strong&gt;如何学习&lt;/strong&gt;、&lt;strong&gt;如何做事&lt;/strong&gt;、&lt;strong&gt;如何思维&lt;/strong&gt;来展开。&lt;/p&gt;

&lt;p&gt;关于如何学习记忆比较深的几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;利用碎片时间思考。&lt;/li&gt;
  &lt;li&gt;专注。&lt;/li&gt;
  &lt;li&gt;为知识建立索引，以便在合适的时候被回忆。&lt;/li&gt;
  &lt;li&gt;通过教别人来验证自己是否真的懂了。&lt;/li&gt;
  &lt;li&gt;抽象&amp;amp;推广。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于如何做事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进度条。&lt;/li&gt;
  &lt;li&gt;遇到问题亲自动手：困难的路越走越容易，容易的路越走越难。&lt;/li&gt;
  &lt;li&gt;用特例引发思考。&lt;/li&gt;
  &lt;li&gt;普通人遵守规则，牛人无视规则，伟人创造规则。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于如何思维，更多的是一些想象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;认知失调和自我辩解。&lt;/li&gt;
  &lt;li&gt;20万年前的自己：天性。&lt;/li&gt;
  &lt;li&gt;能够改变习惯的不是自制力，而是知识。&lt;/li&gt;
  &lt;li&gt;知识是双刃剑，一方面提供解决问题的捷径，另一方面也是思维的桎梏。&lt;/li&gt;
  &lt;li&gt;如果手里有一把锤子，所有的东西看上去都像钉子。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外很喜欢其中的&lt;strong&gt;哥德尔不完备定理&lt;/strong&gt;部分，一方面之前不知道这么叼的东西，另一方面能把各种问题联系在一起确实比较厉害。&lt;/p&gt;

</description>
        <pubDate>Fri, 08 May 2015 21:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/08/Dark-Time.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/08/Dark-Time.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>如何阅读一本书</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s1670978.jpg&quot; alt=&quot;如何阅读一本书&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;看到这个书名可能会想：阅读谁不会，还需要买本书来学？刚开始我也是这么想的，但是自从发奋读书之后发现不是那么回事，遇到一些问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;难啃的书看一半就丢到一边不再管了。&lt;/li&gt;
  &lt;li&gt;读完之后也不知道书里面讲了些什么。&lt;/li&gt;
  &lt;li&gt;更悲剧的是花了很长的时间读完之后发现是一本烂书。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后立即在网上找指导阅读的书。花了两周的时间把这本书看了两遍，非常佩服作者对阅读这件看似简单的事情有这么系统、深入的思考，印象最深的是要带着问题读书：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这本书讲了些什么？&lt;/li&gt;
  &lt;li&gt;细说了哪些部分？&lt;/li&gt;
  &lt;li&gt;说的有道理吗？&lt;/li&gt;
  &lt;li&gt;这本书跟我有什么关系？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之前比较追求豆瓣读书上长长的书单带来的一点点成就感，太Low了。我们应该追求精读书、读好书、让书改变行动和思维，从而真正成为我们的一部分。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内容笔记&lt;/h2&gt;

&lt;p&gt;这本书涉及的内容有：阅读质量、阅读意义和阅读的四个层次。要保证阅读的质量本质上就是要主动，主动做笔记，主动思考（思考上面的四个问题），阅读的意义就略过了（大家应该都懂），重点来看阅读的四个层次。&lt;/p&gt;

&lt;p&gt;第一个层次是&lt;strong&gt;基础阅读&lt;/strong&gt;，简单来说就是识字、能做一些功能性阅读。基础阅读是根本，如果这个都不行就不用看后面的了，所以现在当务之急是把英语补起来&amp;gt;_&amp;lt;。&lt;/p&gt;

&lt;p&gt;第二个层次是&lt;strong&gt;检视阅读&lt;/strong&gt;，目的是为了熟悉架构，那么最直接的方法就是从书的结构入手：书名、目录等，另外可以快速把书过一遍，遇到不理解的地方也不要停。&lt;/p&gt;

&lt;p&gt;第三个层次是&lt;strong&gt;分析阅读&lt;/strong&gt;，所谓分析，就是明白作者写书的出发点、提炼主旨观点并做出评价。书中讲了一些不错的技巧，比如为了更好的理解含义的两个办法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用自己的话描述出来。&lt;/li&gt;
  &lt;li&gt;举出一个和主旨吻合的例子。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第四个层次是&lt;strong&gt;主题阅读&lt;/strong&gt;，到了这个层次，要求我们带着明确的目的去读书，比如想了解明朝的历史，你可以找多本相关的书进行阅读，并且将不同的观点进行比较、思考，形成自己的观点。&lt;/p&gt;

&lt;p&gt;另外，对于不同类型的书有不同的读法，比如小说你就可以很快地阅读，重在感同身受，而不是去分析。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;读书是这样，看人、看事也是如此。对一件事情，先粗略地搞清楚来龙去脉，发现如果值得投入，再花时间去理解细节。对不同的事情可以横向对比，形成自己的做事风格。&lt;/p&gt;

&lt;p&gt;另外，写博客就像是写一本书，告诉别人我是什么样的一个人:D。&lt;/p&gt;

&lt;p&gt;附&lt;a href=&quot;http://naotu.baidu.com/viewshare.html?shareId=av2aukso52ww&quot;&gt;百度脑图笔记&lt;/a&gt;，另外笔记如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/如何阅读一本书.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 07 May 2015 05:04:53 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/07/How-to-Read-a-Book.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/07/How-to-Read-a-Book.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>自由，就是可以选择</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;年轻&lt;/h2&gt;

&lt;p&gt;青春不是年华，而是心境；青春不是桃面、丹唇、柔膝，而是深沉的意志、恢宏的想象、炽热的感情；青春是生命的深泉在涌流。&lt;/p&gt;

&lt;p&gt;青春气贯长虹，勇锐盖过怯弱，进取压倒苟安。如此锐气，二十后生有之，六旬男子则更多见。年岁有加，并非垂老；理想丢弃，方堕暮年。&lt;/p&gt;

&lt;p&gt;岁月悠悠，衰微只及肌肤；热忱抛却，颓唐必至灵魂。忧烦、惶恐、丧失自信，定使心灵扭曲，意气如灰。&lt;/p&gt;

&lt;p&gt;无论年届花甲，抑或二八芳龄，心中皆有生命之欢乐，奇迹之诱惑，孩童般天真久盛不衰。人人心中皆有一台天线，只要你从天上人间接受美好、希望、欢乐、勇气和力量的信号，你就青春永驻，风华常存。&lt;/p&gt;

&lt;p&gt;一旦天线降下，锐气便被冰雪覆盖，玩世不恭、自暴自弃油然而生，即便年方二十，实已垂垂老矣；然则只要竖起天线，捕捉乐观的信号，你就有望在八十离龄告别尘寰时仍觉年轻。&lt;/p&gt;

&lt;p&gt;每次读《年轻》都会热血沸腾，但现实中，干着没有激情的工作、混着得过且过的日子。终于有一天番然悔悟，怎么能这样马虎地度过，我要&lt;strong&gt;选择&lt;/strong&gt;自己想要的生活。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;博客&lt;/h2&gt;

&lt;p&gt;之前用过不少博客产品：CSDN、博客园、简书等等。写了不少文章，但是又逐渐越来越不喜欢它们的风格，因此有了这个博客。使用GitHub搭建，基于jekyll，样式完全自己控制，图片用七牛。&lt;/p&gt;

&lt;p&gt;博客的作用就不多说，就像刘末鹏大牛讲的，把自己的想法写下来与大家分享，好处多多!&lt;/p&gt;

&lt;p&gt;另外我想，一个博客就像一个土地，种下理想，辛勤劳作让它生根发芽、开花结果，长成一棵惨天大树。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;自由&lt;/h2&gt;

&lt;p&gt;自由是什么？自由就是可以选择！&lt;/p&gt;

&lt;p&gt;当你必须按时、按照既有的规则完成每天安排给你的任务，你是自由的吗？&lt;/p&gt;

&lt;p&gt;当你作为底层毫无话语权，你是自由的吗？&lt;/p&gt;

&lt;p&gt;当然不是。想要自由，那就努力提高自己的能力和层次。&lt;/p&gt;
</description>
        <pubDate>Sat, 02 May 2015 05:04:53 +0800</pubDate>
        <link>/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/02/Freedom.html</link>
        <guid isPermaLink="true">/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/02/Freedom.html</guid>
        
        
        <category>里程碑</category>
        
      </item>
    
  </channel>
</rss>
