<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 01 Aug 2015 14:17:17 +0800</pubDate>
    <lastBuildDate>Sat, 01 Aug 2015 14:17:17 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Jstorm</title>
        <description>&lt;p&gt;实际上做过的大部分的系统很难算是分布式系统，处理的流程一般是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将请求随机交给一台机器；&lt;/li&gt;
  &lt;li&gt;在这台机器上面进行处理，如果处理量比较大就开多线程；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在一台机器上面去开多线程处理感觉又回到了古老的单机作战的时代，扩展和性能都是有上限的，那么能不能将一个任务交给不同的机器来协同完成？&lt;/p&gt;

&lt;p&gt;数据处理方面根据不同的场景大致可以分为下面两种场景：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;离线分析：特点是查询单一、数据加工过程也单一，用Hadoop来解决；&lt;/li&gt;
  &lt;li&gt;在线分析：特点是查询随机，玩的就是索引，那么QPS必然不会很高，而且需要的都是好机器，可以用阿里云的ADS来解决；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看是天下太平，但真正用的时候还是会有问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;像ADS这样的产品，可以在一份静态的数据上面方便地进行各种查询，但是新增、更新操作特别频繁的情况下，索引的重构可能会存在瓶颈。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实时性也是数据处理的一个目标，记得之前在压测的时候在Solr实时更新索引上死得很惨，所以需要考虑更加有效、低成本地解决方式。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;基本概念&lt;/h2&gt;

&lt;p&gt;集群架构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以及：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;nimbus&lt;/strong&gt;：分发任务、任务、监控集群运行状态；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;supervisor&lt;/strong&gt;：监听nimbus的指令，接受分发代码、任务并执行；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;worker&lt;/strong&gt;：真正执行的进程；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;task&lt;/strong&gt;：任务；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;executor&lt;/strong&gt;：一个线程，用来轮询task中的接口；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在jstorm中运行的程序就是一个&lt;strong&gt;topology&lt;/strong&gt;，说白了就是一个jar包，可以在nimbus节点使用命名把jar包提交给集群，那么这个jar包中的程序的结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;spout&lt;/strong&gt;：源头；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;bolt&lt;/strong&gt;：处理器；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;tuple&lt;/strong&gt;：数据；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：任务分发、启动的流程可以看&lt;a href=&quot;http://xumingming.sinaapp.com/647/twitter-storm-code-analysis-topology-execution/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在分布式系统中数据都准确性是最难的，通常在检查消息消费失败的时候重试。而在Jstorm里面中就更为复杂，一个消息从spout发给bolt，而一个bolt可能发给多个bolt，这样就构成了一棵树形结构，在jstorm中用&lt;strong&gt;acker&lt;/strong&gt;机制来检测消息是否失败：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Jstorm-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;显然这是一个随机算法，但是发生错误的概率非常小！但是，如果真的出错那就蛋疼了，做个开关或者接口让程序开发者来自己实现acker不好么？&lt;/p&gt;

&lt;p&gt;在并发编程中经常要碰到去处理资源竞争，处理的方式基本上两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁&lt;/li&gt;
  &lt;li&gt;根据所需要的资源进行分组&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用第2种方式，将不同的任务分发给不同的节点来处理，这样就可以减少很多的竞争、简化处理的代码、容易提高性能，在jstorm提供了丰富&lt;strong&gt;grouping&lt;/strong&gt;方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;随机分组&lt;/li&gt;
  &lt;li&gt;根据某个字段分组&lt;/li&gt;
  &lt;li&gt;广播&lt;/li&gt;
  &lt;li&gt;直接分组&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说到消息分组，可能看起来是在&lt;strong&gt;emit&lt;/strong&gt;的时候就直接发出去了，但事实上并不是这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建tuple；&lt;/li&gt;
  &lt;li&gt;worker将目标taskId+tuple放到待发送队列；&lt;/li&gt;
  &lt;li&gt;由一个单独的线程来负责将消息发送给对应的任务处理；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外在jstorm中提供了一些更高级的抽象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CoordinatedBolt&lt;/li&gt;
  &lt;li&gt;Transactional Topology&lt;/li&gt;
  &lt;li&gt;DRPC&lt;/li&gt;
  &lt;li&gt;Trident&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了做到&lt;strong&gt;处理且仅处理一次&lt;/strong&gt;的目的，并且不能牺牲掉并发性，那么Transactional Topology的做法是将一个batch的计算分为两个阶段来完成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;processing&lt;/strong&gt;：多个batch并行处理；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;commit&lt;/strong&gt;：一个一个地提交，batch之间保持强有序；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而Trident则是一个更方便、可靠的接口~&lt;/p&gt;

&lt;p&gt;附jstorm中常用参数设置：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.message.timeout.secs&lt;/td&gt;
      &lt;td&gt;超时时间，如果超时则认为失败&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.max.task.parallelism&lt;/td&gt;
      &lt;td&gt;最大并行度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.state.synchronization.timeout.secs&lt;/td&gt;
      &lt;td&gt;组件同步状态源的最大超时时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.max.spout.pending&lt;/td&gt;
      &lt;td&gt;缓存spout发送的tuple数，超出会阻塞&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.executor.receive.buffer.size&lt;/td&gt;
      &lt;td&gt;executor线程的接收队列大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.executor.send.buffer.size&lt;/td&gt;
      &lt;td&gt;executor线程的发送队列大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.receiver.buffer.size&lt;/td&gt;
      &lt;td&gt;worker接收线程缓存消息的大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.transfer.buffer.size&lt;/td&gt;
      &lt;td&gt;worker进程中向外发送消息的缓存大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;storm.messaging.netty.max_wait_ms&lt;/td&gt;
      &lt;td&gt;最大等待时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;storm.messaging.netty.min_wait_ms&lt;/td&gt;
      &lt;td&gt;最小等待时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;topology.ackers&lt;/td&gt;
      &lt;td&gt;ackaer任务数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;drpc&quot;&gt;DRPC&lt;/h2&gt;

&lt;p&gt;互联网中用户的操作通常是轻量级的，插一下数据库、更新一下缓存就搞定了，但是对于仓库管理这种系统很多操作比较重，有些任务可能需要遍历数据库中的表才能完成，而Distributed RPC可能是提高性能、降低风险的一个途径。&lt;/p&gt;

&lt;p&gt;用Jstorm来搞DRPC的过程如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
DRPCClient client = new DRPCClient(&quot;drpc-host&quot;, 3772);
String result = client.execute(&quot;reach&quot;, &quot;http://twitter.com&quot;);
&lt;/pre&gt;

&lt;p&gt;客户端给DRPC服务器发送要执行的方法名称以及参数，实现了这个函数的topology使用DRPCSpout从DRPC服务器接收函数调用流。每个函数调用被DRPC服务器标记了一个唯一的id。这个topology然后计算结果，在topology的最后一个叫做ReturnResults的bolt会将调用的结果发送给DRPC服务器。&lt;/p&gt;

&lt;p&gt;之前想过可能用一些更简单的方法来试下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在spout的节点提供一个rpc服务；&lt;/li&gt;
  &lt;li&gt;在调用这个服务的时候发送消息给bolt，然后在bolt中完成任务的分发及处理；&lt;/li&gt;
  &lt;li&gt;在spout中统计是否所有的消息都成功消费；&lt;/li&gt;
  &lt;li&gt;返回数据；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样弄会有一些问题，但是感觉没有强依赖于jstorm，而仅仅是用它的消息分发机制就可以了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据流式处理&lt;/h2&gt;

&lt;p&gt;在流式处理的过程中，每次面对的都是单个的记录，而事实上统计都是有状态的，那么：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以把状态保存在本地；&lt;/li&gt;
  &lt;li&gt;可以把状态保存在hbase、ldb等外部的存储；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;保存在本地的内存中速度会很快，也没有序列化等开销，而且通常流处理中时效性要求是比价强的，过去很久的数据基本上就不会再次处理。所以：流玩的好不好，就看本地缓存用的好不好了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;很多语言从一开始就在考虑如何简单地去实现并发编程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;erlang&lt;/li&gt;
  &lt;li&gt;golang&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而我们这些作为老Java程序猿只能是自己去东拼西凑地搞出一个来简化分布式系统中的开发成本。现在考虑下来jstorm应该是个不错的选择：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;运行一个固定结构的topology；&lt;/li&gt;
  &lt;li&gt;在topology上面可以动态地加载、编译我们要执行的脚本；&lt;/li&gt;
  &lt;li&gt;在spout、bolt中调用脚本中的方法；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样也许我们可以更低的成本来享受分布式带来的好处~~&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/31/Jstorm.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/31/Jstorm.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>组件化</title>
        <description>&lt;p&gt;做后端开发已经很清楚地知道如何抽象、解耦，现在RESTful风格的再次流行也让整个后端开发看起来尽善尽美，而前段也很牛逼，有了bootstrap之后，不懂css也能很快上手搞出一个页面，况且还有&lt;a href=&quot;http://www.ibootstrap.cn/&quot;&gt;ibootstrap&lt;/a&gt;这种工具逆天般的存在。&lt;/p&gt;

&lt;p&gt;但是，让一个人做出来一个完整的功能就傻逼了，而有组件化之后就不同了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;目标&lt;/h2&gt;

&lt;p&gt;页面都是用一堆的HTML拼出来的，可以进行划分为一些小块：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;输入框&lt;/li&gt;
  &lt;li&gt;下拉列表&lt;/li&gt;
  &lt;li&gt;按钮&lt;/li&gt;
  &lt;li&gt;列表&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在同一个应用中，这些组件都长得差不多，那么在一个VM上开发了一个按钮之后，通常的做法是在另外一个VM上把代码粘贴上去并简单修改一些参数。在用webx的时候我们会做一堆的controller，但是这个还远远不够。&lt;/p&gt;

&lt;p&gt;组件化的目标就是：&lt;strong&gt;让你ctrl-c、ctrl-v个痛快&lt;/strong&gt;，&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;第一种方案&lt;/h2&gt;

&lt;p&gt;同事正在做的方式，通过一个后台的页面来维护一个树状结构：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;页面
    &lt;ul&gt;
      &lt;li&gt;容器&lt;/li&gt;
      &lt;li&gt;组件A&lt;/li&gt;
      &lt;li&gt;组件B&lt;/li&gt;
      &lt;li&gt;容器&lt;/li&gt;
      &lt;li&gt;组件C&lt;/li&gt;
      &lt;li&gt;组件D&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用一个巨复杂的页面来一个一个构建。这种方案的缺点是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在数据库中用各种表来保存组件数据；&lt;/li&gt;
  &lt;li&gt;在第一次使用中完全不知道怎么使用，除非你知道这套系统的执行逻辑；&lt;/li&gt;
  &lt;li&gt;偶尔会出现配置出错的情况，这台方案回滚起来只能靠人脑了；&lt;/li&gt;
  &lt;li&gt;功能越强大，用起来越复杂；&lt;/li&gt;
  &lt;li&gt;在需要增加新功能的时候必然要去修改配置的页面；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;第二种方案&lt;/h2&gt;

&lt;p&gt;为了改善易用性，另外一种就是用高大上的前端来搞定配置的过程：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在配置页面的过程中，可以在组件上绑定属性和事件，这种方式的问题在于：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;底层结构复杂；&lt;/li&gt;
  &lt;li&gt;配置页面的交互开发量太大；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-3&quot;&gt;第三种方案&lt;/h2&gt;

&lt;p&gt;通常来说DSL基本上是每个专业领域提升效率的终极武器，在配置一个页面的时候可以这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@layout
    @input(name = &quot;warehouse_id&quot;, label = &quot;仓库&quot;)
    @inputWithTime(name = &quot;xxx&quot;, label = &quot;xxx&quot;)
    @button(label = &quot;查询&quot;)
    @button(label = &quot;导出&quot;)
@layout
	@table // 列表的展示
    @page  // 分页组件的展示
&lt;/pre&gt;

&lt;p&gt;页面之间最麻烦的是数据交互和联动，比如在查询的时候需要知道查询条件分别是什么，有两种解决办法，第一种是为button绑定事件，在点击的时候获取其他组件的数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@button
	@onclick
    	var warehouse_id = getByName(&quot;warehouse_id&quot;);
        var response = query(&quot;/path&quot;, warehouse_id);
        // 更新table的展示
&lt;/pre&gt;

&lt;p&gt;看起来是搞定了，而且可以吧获取参数等操作进行封装，使得配置起来更加简单，不过他们之间的耦合有点紧，现在的想法是可以用订阅者模式来松一松：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@channel(name = &quot;queryParam&quot;)
// ..
@input(name = &quot;warehouse_id&quot;, outChannel = &quot;queryParam&quot;)
// ..
@button(label = &quot;查询&quot;, inChannel = &quot;queryParam&quot;)
&lt;/pre&gt;

&lt;p&gt;在组件中定义了输出数据的接口以及接收数据的接口，在input发生变化的时候将数据发送给channel，在channel中有数据的时候将结果推送给订阅过它的组件。&lt;/p&gt;

&lt;p&gt;那么问题来了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;往channel中放的数据是什么格式的？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;貌似&lt;strong&gt;key-value&lt;/strong&gt;的形式可以搞定很多的需求，而在各个组件的作用域也有一个map来保存数据，仅仅是用channel来互相之间同步数据。当然并不是传输数据的时候都去覆盖掉老的数据，可能会有一些个性化的操作：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@button(label = &quot;查询&quot;, inChannel = &quot;queryParam&quot;)
	@onclick
        data = query(&quot;/&quot;, warehouse_id);
        putChannel(&quot;tableData&quot;, data);
&lt;/pre&gt;

&lt;p&gt;在拿到这个模板之后，我们可以这么干：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;解析模板文件；&lt;/li&gt;
  &lt;li&gt;生成AST，然后翻译生成JS文件；&lt;/li&gt;
  &lt;li&gt;前端页面加载JS文件之后，根据其中的数据生成页面展示；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样搞起来感觉难度挺大，但是好处多多！&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;组件化很多人在做，做的时间也比较久，但是好像没有做得比较好用的。那么，为什么不尝试一些新的方法和技术。&lt;/p&gt;
</description>
        <pubDate>Fri, 31 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/31/Componentization.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/31/Componentization.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>WEB开发笔记</title>
        <description>&lt;h2 id=&quot;springbeanfilter&quot;&gt;用SpringBean来配置Filter&lt;/h2&gt;

&lt;p&gt;在web开发中通常会遇到多个环境的问题，比如开发和线上，那他们使用的配置信息也是不同的，Spring给出的解决这个问题的方法是变量替换：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean class=&quot;my.class.path&quot;&amp;gt;
    &amp;lt;property name=&quot;env&quot; value=&quot;${ENV}&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;

&lt;p&gt;但是对于web.xml中的属性这样搞就行不通了，那简单的解决办法就是绕路了：用Spring中配置的Bean来作为Filter行不行？答案是肯定的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;filter&amp;gt;
    &amp;lt;filter-name&amp;gt;ssoFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;filter-class&amp;gt;org.springframework.web.filter.DelegatingFilterProxy&amp;lt;/filter-class&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;targetBeanName&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;myFilterBean&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;init-param&amp;gt;
        &amp;lt;param-name&amp;gt;targetFilterLifecycle&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;true&amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
&amp;lt;/filter&amp;gt;
&lt;/pre&gt;

&lt;p&gt;容器初始化的顺序为Listener-&amp;gt;Filter-&amp;gt;Servlet，这样上面这种玩法跑通就没有问题了~&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;

</description>
        <pubDate>Tue, 21 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/21/Web-Dev.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/21/Web-Dev.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的动态执行</title>
        <description>&lt;p&gt;假如你在用Java的碰到这些问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;灵活地配置规则&lt;/li&gt;
  &lt;li&gt;部署代码无需重启即时生效&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而恰恰你是个“low逼”或者“懒货”不想（更多的是不行）去定义自己的脚本、规则引擎，那么下面这些可能是个不错的选择。&lt;/p&gt;

&lt;h2 id=&quot;groovy&quot;&gt;Groovy的使用&lt;/h2&gt;

&lt;p&gt;Groovy是一种基于JVM的敏捷开发语言，可以无缝与Java整合：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Binding binding = new Binding();
binding.setProperty(&quot;foo&quot;, new Integer(2));
GroovyShell shell = new GroovyShell(binding);
shell.evaluate(&quot;println foo&quot;);
&lt;/pre&gt;

&lt;p&gt;用&lt;strong&gt;GroovyShell&lt;/strong&gt;看起来是非常简单的，但问题是每次在evaluate的时候都需要去解析、编译，速度肯定是上不去的，另外也会频繁地产生很多的Class，增加了内存回收的负担（甚至OOM），但是也看具体使用场景~~&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
String[] roots = new String[] { &quot;your groovy script path&quot; };
GroovyScriptEngine gse = new GroovyScriptEngine(roots);
Binding binding = new Binding();
binding.setProperty(&quot;foo&quot;, new Integer(2));
gse.run(&quot;GroovyShellHellow.groovy&quot;, binding);
&lt;/pre&gt;

&lt;p&gt;用&lt;strong&gt;GroovyScriptEngine&lt;/strong&gt;的时候有了缓存，而且用起来也更加简单，用起来也很简单了，但是很多人开始诟病Groovy脚本的性能，确实是比较低，再来看一种处理方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
new GroovyClassLoader().parseClass(&quot;print 123&quot;);// 得到Class
&lt;/pre&gt;

&lt;p&gt;在用&lt;strong&gt;GroovyClassLoader&lt;/strong&gt;生成好Class之后通过反射调用对应的方法。有人可能觉得这种方法弱爆了，又难用又效率低，但是如果将生成的Class缓存起来呢？等等，应该怎么生成Class？&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
CompilerConfiguration configuration = new CompilerConfiguration();
configuration.setOutput(new PrintWriter(new FileWriter(&quot;D:\\a&quot;)));
configuration.setTargetDirectory(&quot;D:\\&quot;);
new GroovyClassLoader(
    Thread.currentThread().getContextClassLoader(),
        configuration)
        .parseClass(&quot;print 123&quot;);
&lt;/pre&gt;

&lt;p&gt;好了，讲差不多了，我们来重点看下GroovyClassLoader吧。可能在你看完GroovyScriptEngine之后会说：GroovyScriptEngine已经将GroovyClassLoader封装的挺不错的来，但是会有一个问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其中用的是同一个ClassLoader，在脚本发生变化的时候就生成新的Class，时间久了Perm就满了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在可以对GroovyClassLoader根据业务具体的需求进行封装即可，在上面的代码中可以在指定的文件夹中就可以生成好Class。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;既然GroovyClassLoader直接可以解析脚本，为什么还需要生成Class。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果做的平台用的人非常多，成千上万个脚本都是有可能的（虽然现在一个都没有），那么在系统启动的时候是不是要把所有的脚本拿下来编译一遍？这个可能会比较影响启动的速度，所以可以在保存Script的时候再保存一个Class文件，在系统启动的时候直接去Load即可。&lt;/p&gt;

&lt;p&gt;再来看Groovy的好处：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@TypeChecked
int func(){
    def a = 123;
    a = a + &quot;&quot;;
    return a;// 这里会报错
}
&lt;/pre&gt;

&lt;p&gt;在Groovy的2.0版本以后加入了静态类型检查器，可以在编写代码的时候看到类型错误。动态语言太灵活了，这样可以减少很多开发的成本，因为不用等到运行的时候才发现错误。&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@CompileStatic
int func(){
    123 + 123 + 123;
}
&lt;/pre&gt;

&lt;p&gt;使用&lt;strong&gt;@CompileStatic&lt;/strong&gt;注释将会静态地编译代码，产生的字节码和Java运行得一样快，这样看来性能也将不再是问题。&lt;/p&gt;

&lt;p&gt;最后，现在很多规则的配置都用Groovy来解决，因为处理Map、新建类等非常方便，如果用原生的Java写的话，配置的时候不会真方便，当然，编译Java代码的方式也是要研究一下的。&lt;/p&gt;

&lt;h2 id=&quot;java&quot;&gt;动态编译Java源码&lt;/h2&gt;

&lt;p&gt;除了用Groovy这种脚本的方式，还可以用Java代码来搞：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);
JavaFileObject fileObject = new SimpleJavaFileObject(
    URI.create(&quot;string:///CalculatorTest&quot; + JavaFileObject.Kind.SOURCE.extension),
    JavaFileObject.Kind.SOURCE) {
    @Override
    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {
        return &quot;class CalculatorTest {}&quot;;
    }
};
JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, null, null, Arrays.asList(fileObject));
task.call();// 编译
&lt;/pre&gt;

&lt;p&gt;在编译好Class文件之后，使用的时候加载进来，然后通过反射进行调用。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;在选择编程语言来实现某个功能时，会考虑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;学习成本&lt;/li&gt;
  &lt;li&gt;开发速度&lt;/li&gt;
  &lt;li&gt;性能&lt;/li&gt;
  &lt;li&gt;用的人多不多&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之前可能开口闭口都是性能，但是，感觉现在的开发语言越来越注重的是开发的速度以及语言本身是否简洁，简洁的语言更不容易写出BUG，另外如果让一个用惯了有GC的语言，再去尝试写C这种古老的语言肯定是一百个不习惯。&lt;/p&gt;

&lt;p&gt;最后为什么要考虑用的人多不多呢？因为在用的人多的情况下，大家会开发出各种各样优秀的工具，那么在实现某个功能的时候不用自己写代码了，直接“拿来主义”。&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/21/Dynamic-Compilation.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/21/Dynamic-Compilation.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>SpringMVC</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概念&lt;/h2&gt;

&lt;p&gt;在MVC中最基本的概念就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Model&lt;/li&gt;
  &lt;li&gt;View&lt;/li&gt;
  &lt;li&gt;Controller&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在SpringMVC中对这些结构进行了封装：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ModelAndView&lt;/td&gt;
      &lt;td&gt;在同一个地方可以同时操作Model和View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ModelMap&lt;/td&gt;
      &lt;td&gt;数据承载对象，用于到后面渲染View，在RequestMapping的时候很有用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当然对处理流程也进行了封装：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;DispatcherServlet&lt;/td&gt;
      &lt;td&gt;前置分发控制器，请求统一交给它处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VelocityViewResolver&lt;/td&gt;
      &lt;td&gt;通过name查找View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HandlerInterceptor&lt;/td&gt;
      &lt;td&gt;拦截器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DefaultAnnotationHandlerMapping&lt;/td&gt;
      &lt;td&gt;类级别的@RequestMapping&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AnnotationMethodHandlerAdapter&lt;/td&gt;
      &lt;td&gt;方法级别的@RequestMapping&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HandlerMethodArgumentResolver&lt;/td&gt;
      &lt;td&gt;参数解析器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping&lt;/td&gt;
      &lt;td&gt;映射规则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Controller&lt;/td&gt;
      &lt;td&gt;注入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@ModelAttribute&lt;/td&gt;
      &lt;td&gt;被注释的方法在Controller中处理请求的方法之前执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@PathVariable&lt;/td&gt;
      &lt;td&gt;获取路径上的变量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;处理请求&lt;/h2&gt;

&lt;p&gt;用的最多的情况就是用户输入URL你给他返回一个&lt;strong&gt;页面&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@RequestMapping(value = &quot;/abc&quot;)
public ModelAndView handle() throws Exception {
    ModelAndView mv = new ModelAndView(&quot;abc&quot;);
    mv.addObject(&quot;key&quot;, &quot;abc&quot;);
    return mv;
}
&lt;/pre&gt;

&lt;p&gt;在很多请求的时候需要返回&lt;strong&gt;JSON&lt;/strong&gt;数据，只需要将字符串写出即可：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@RequestMapping(value = &quot;/abc&quot;)
public void handle(HttpServletResponse response) throws Exception {
    Map map = Maps.newHashMap();
    map.put(&quot;123&quot;, 123);
    response.getOutputStream().write(JSON.toJSONString(map).getBytes());
    response.getOutputStream().flush();
}
&lt;/pre&gt;

&lt;p&gt;对于&lt;strong&gt;文件&lt;/strong&gt;下载的场景也是类似的，不同之处是要指定文件名等：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@RequestMapping(value = &quot;/abc&quot;)
public void handle(HttpServletResponse response) throws Exception {
    OutputStream os = response.getOutputStream();
    response.reset();
    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=file.txt&quot;);
    response.setContentType(&quot;application/octet-stream; charset=utf-8&quot;);
    os.write(&quot;hello&quot;.getBytes());
    os.flush();
    os.close();
}
&lt;/pre&gt;

&lt;p&gt;从上面可以看到拿到&lt;strong&gt;HttpServletResponse&lt;/strong&gt;之后就可以完全控制住返回值了，在SpringMVC中最简单、直接的获取方式是入参，&lt;strong&gt;HandlerMethodArgumentResolver&lt;/strong&gt;会在解析参数的时候进行处理。在网上有看到用&lt;strong&gt;ModelAttribute&lt;/strong&gt;的方式，这样貌似不是线程安全的吧~&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;HttpServletRequest&lt;/strong&gt;更简单一些，可以使用RequestContextListener或者RequestContextFilter来做，另外更简单的可以直接注入：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Resource
HttpServletRequest  request;
&lt;/pre&gt;

&lt;p&gt;看起来很诡异，这个是如何注入的？其实这里的request只是一个代理，真正的处理过程可以看：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ObjectFactoryDelegatingInvocationHandler&lt;/li&gt;
  &lt;li&gt;RequestObjectFactory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是找了一圈没找到Response有类似的方法，所以，这种方式对Response可能行不通。其实我们自己也可以实现类似的功能，比如用&lt;strong&gt;HandlerInterceptor&lt;/strong&gt;来搞：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface HandlerInterceptor {
    // 在方法之前执行
    boolean preHandle(HttpServletRequest request,
        HttpServletResponse response,
        Object handler) throws Exception;
    // 在方法之后执行
    void postHandle(HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        ModelAndView modelAndView) throws Exception;
    // 在请求处理完成的时候执行
    void afterCompletion(HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        Exception ex) throws Exception;
&lt;/pre&gt;

&lt;p&gt;我们在preHandle的时候将Request、Response写入ThreadLocal，用FactoryBean来在注入的时候生成代理对象，在调用代理对象的时候先从ThreadLocal中获取对象，再反射调用对象的方法。&lt;/p&gt;

&lt;p&gt;从URL到Controller中的方法的映射也是一个需要注意的地方：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;设置&lt;/th&gt;
      &lt;th&gt;匹配&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(value = “/abc”)&lt;/td&gt;
      &lt;td&gt;/abc、/abc.*、/abc/&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestParam(“id”)&lt;/td&gt;
      &lt;td&gt;限制参数中必须有id，并将其放到入参中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(value = “/abc/{id}”)&lt;/td&gt;
      &lt;td&gt;REST风格，用@PathVariable(“id”)放到入参&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(value = “/{path:[0-9a-z-]+}”)&lt;/td&gt;
      &lt;td&gt;支持正则表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(method = RequestMethod.GET)&lt;/td&gt;
      &lt;td&gt;方法过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(params = “123”)&lt;/td&gt;
      &lt;td&gt;参数过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(headers = “abc”)&lt;/td&gt;
      &lt;td&gt;头信息过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(consumes = “application/json”)&lt;/td&gt;
      &lt;td&gt;处理请求的提交内容类型过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(produces = “application/json”)&lt;/td&gt;
      &lt;td&gt;返回的内容类型过滤&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在SpringMVC中整体的处理逻辑都在&lt;strong&gt;DispatcherServlet&lt;/strong&gt;中完成，处理逻辑如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;处理multipart类型的请求&lt;/li&gt;
  &lt;li&gt;获取处理链HandlerExecutionChain，其中封装了拦截器和处理器&lt;/li&gt;
  &lt;li&gt;执行拦截器的preHandle方法&lt;/li&gt;
  &lt;li&gt;执行处理器&lt;/li&gt;
  &lt;li&gt;设置View&lt;/li&gt;
  &lt;li&gt;执行拦截器的postHandle方法&lt;/li&gt;
  &lt;li&gt;渲染&lt;/li&gt;
  &lt;li&gt;执行拦截器的afterCompletion方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总体看下来比webx简单、好用一些。&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/11/SpringMVC.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/11/SpringMVC.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Redis设计与实现</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img4.douban.com/mpic/s27297117.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;这本书主要是讲Redis底层的实现，总体上分为四部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据结构与对象&lt;/li&gt;
  &lt;li&gt;单机数据库的实现&lt;/li&gt;
  &lt;li&gt;多机数据库的实现&lt;/li&gt;
  &lt;li&gt;独立功能的实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个顺序和作者自己学习的顺序应该是一致的，但是感觉有一点不合理：在刚开始看的时候一直比较着急，因为是在对Redis整体上没有概念的情况下看细节。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;学习笔记&lt;/h2&gt;

&lt;p&gt;在Redis中键为字符串、值为对象，底层处理用到的数据结构有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;动态字符串：使用预分配和惰性释放来减少内存操作次数&lt;/li&gt;
  &lt;li&gt;链表&lt;/li&gt;
  &lt;li&gt;字典：渐进式rehash防止卡住&lt;/li&gt;
  &lt;li&gt;跳跃表&lt;/li&gt;
  &lt;li&gt;整数集合：有序、不重复的整数集合，在必要的时候升级来节约内存&lt;/li&gt;
  &lt;li&gt;压缩列表：连续内存保存整数或字节的列表，通过压缩来节省内存&lt;/li&gt;
  &lt;li&gt;对象：在Redis中都是对象，实现基于上面的数据结构&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于Redis是用C编写的，没有垃圾回收机制，因此在对象系统中构建了一个&lt;strong&gt;引用计数&lt;/strong&gt;实现内存回收器，通过该机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。&lt;/p&gt;

&lt;p&gt;有了这些基础就可以开始看Redis作为一个服务器是如何工作的：&lt;/p&gt;

&lt;pre&gt;
                  +-------------+                   
                  | redisServer |                   
                  +------+------+                   
                         |                          
+-----------+     +------+------+      +-----------+
|redisClient+-----+   redisDb   +--+---+    dict   |
+-----------+     +-------------+  |   +-----------+
                  |   redisDb   |  |                
                  +-------------+  |   +-----------+
                  |   redisDb   |  +---+  expires  |
                  +-------------+      +-----------+

&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;dict&lt;/strong&gt;：键空间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;expires&lt;/strong&gt;：键的过期时间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有另外一种做过期时间的方法是：对dict上的键做扩展，增加过期时间字段。和Redis的做法相比可能有几个缺点：浪费空间、遍历时浪费时间、结构不清晰。过期键的删除有三种策略：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;定时删除&lt;/strong&gt;：在设置键的过期时间时创建Timer，当Timer运行时执行删除操作&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;：在取值时判断是否过期，如果过期则删除&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;定期删除&lt;/strong&gt;：每隔一段时间对数据库进行检查扫描，删除里面过期的键&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定时删除显然不靠谱，在Redis中同时使用了&lt;strong&gt;定期删除&lt;/strong&gt;和&lt;strong&gt;惰性删除&lt;/strong&gt;，当然在持久化程序中也需要考虑过期时间。&lt;/p&gt;

</description>
        <pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/07/08/Redis.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/07/08/Redis.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>Cookie</title>
        <description>&lt;h2 id=&quot;cookie&quot;&gt;COOKIE是什么&lt;/h2&gt;

&lt;p&gt;一切的罪魁祸首都是由于HTTP协议是无状态的，也就是说没有上下文的！那么对于网站来说，它只能输出网页了，至于用户啥的就搞不定了。显然不可接受，于是有了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;COOKIE&lt;/li&gt;
  &lt;li&gt;SESSION&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;COOKIE在浏览器保存信息，SESSION在服务器保存信息，我们可以在Chrome里面F12可以看到COOKIE的内容：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Cookie-F12.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;各列的含义如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Name&lt;/td&gt;
      &lt;td&gt;键&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Value&lt;/td&gt;
      &lt;td&gt;值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Domain&lt;/td&gt;
      &lt;td&gt;域名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Path&lt;/td&gt;
      &lt;td&gt;路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Expires/Max-age&lt;/td&gt;
      &lt;td&gt;过期时间，超过过期时间会被删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Size&lt;/td&gt;
      &lt;td&gt;大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Http&lt;/td&gt;
      &lt;td&gt;限制脚本访问和修改，可以在一定程度提升安全性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Secure&lt;/td&gt;
      &lt;td&gt;只在HTTPS的链接中才能正常使用，否则就当它不存在吧&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以后再发送请求的时候就会带上COOKIE，服务器上拿到之后就可以判断是哪个用户发过来的请求了！既然请求都会带COOKIE，那么如果保存了很多数据的话也会给网络传输增加负担，所以使用需谨慎！其实浏览器对大小也有限制，而基本上做的都是规范的下限：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;总共至少可存300个&lt;/li&gt;
  &lt;li&gt;每个域名至少可存20个&lt;/li&gt;
  &lt;li&gt;每个COOKIE至少可以存4KB&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要是别人向我的网站写入COOKIE然后再操作怎么办？不知道别人有没有过类似的担心，因为有域名的限制，所以总体来说COOKIE还是挺好用的！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;登录&lt;/h2&gt;

&lt;p&gt;在COOKIE中存放三个东西：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用户名：明文保存&lt;/li&gt;
  &lt;li&gt;登录序列：只有在密码修改的时候时候才更新，否则每次都一样&lt;/li&gt;
  &lt;li&gt;随机数：在同一个会话中用一个，再次登录之后重新生成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样可以保证每个用户只能登录一次，而且可以通过判断&lt;strong&gt;随机数&lt;/strong&gt;是否发生变化来做盗用检测，这时候可以通过重新登录并生成&lt;strong&gt;登录序列&lt;/strong&gt;来使盗用者的COOKIE失效。&lt;/p&gt;

&lt;p&gt;当然登录还有很多有趣的细节，可以看&lt;a href=&quot;http://coolshell.cn/articles/5353.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安全&lt;/h2&gt;

&lt;p&gt;在cookie中保存很多关键性的数据，不过不安全还是挺蛋疼的，我们来看看这套机制的设计者是如何考虑安全问题的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不能跨域访问&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要是我能随便增加、删除别人的网站上面的cookie，那就没法玩了~ 由于在JS中也可以操作cookie，那么对于有输入的应用（比如博客）就危险了，用户输入一段JS同样也可以进行操作了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;设置HttpOnly属性之后不能通过脚本访问&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有了上面两个限制，那么剩下的事情就是防止别人模拟发送请求就可以了，比如通过随机数的方式。&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/04/Cookie.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/04/Cookie.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>VIM</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/VIM-LOGO.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很早之前就知道VIM很厉害，不过作为一个Java攻城狮，用起来实在是不方便，完全没有Eclipse或者IDEA写代码顺畅，比如代码提示等（怀疑自己配置有问题-.-!）。最近对golang非常感兴趣，然而默认的IDE实在是太丑了，所以决心把VIM捡起来。&lt;/p&gt;

&lt;p&gt;周围用Emacs的同事越来越多，但是简单用了几次，总觉得不怎么顺手，也就不了了之。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;插件管理器&lt;/h2&gt;

&lt;p&gt;相比现代编辑器，VIM缺乏默认的插件管理功能，之前在配置时不停地从网上收集插件，然后粘贴到对应的目录下。这个过程相当地考验耐心，以及人品。&lt;/p&gt;

&lt;p&gt;最近无意间发现了一个插件管理工具：&lt;strong&gt;vundle&lt;/strong&gt;。玩了一下感觉还不错，首先从github上下载:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后修改&lt;strong&gt;vimrc&lt;/strong&gt;文件：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
set nocompatible &quot;关闭兼容模式
filetype off &quot;
set rtp+=~/.vim/bundle/Vundle.vim &quot; 写自己安装的目录
call vundle#begin() &quot;

Bundle 'gmarik/Vundle.vim' &quot; 插件列表
&quot; ... 插件列表

call vundle#end() &quot;
filetype plugin indent on
&lt;/pre&gt;

&lt;p&gt;如果是&lt;strong&gt;vim-scripts&lt;/strong&gt;下面的插件直接写名字就好了，否则为&lt;strong&gt;用户名/插件&lt;/strong&gt;的格式，使用时用到的几个命令如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleList&lt;/td&gt;
      &lt;td&gt;列举出列表中(.vimrc中)配置的所有插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall&lt;/td&gt;
      &lt;td&gt;安装列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall!&lt;/td&gt;
      &lt;td&gt;更新列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch foo&lt;/td&gt;
      &lt;td&gt;查找foo插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch! foo&lt;/td&gt;
      &lt;td&gt;刷新foo插件缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean!&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;写代码之前&lt;/h2&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Golang入门</title>
        <description>&lt;p&gt;虽然Go已经不算是一个很新的语言了，但是现在非常地火！一般来说语言本身没有什么好讲究的，能快速编程、少点坑就算是一门好的语言了。但是，如果语言火了之后，其周围的工具发展起来之后，能用它做的事情就太多了~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;环境搭建&lt;/h2&gt;

&lt;p&gt;因为我仅仅打算在ubuntu上面进行golang的开发，所以其他的系统后面用过了再来补充！配置来说相当容易：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载golang的包解压安装，如果官网上的访问不到就到&lt;a href=&quot;http://www.golangtc.com/&quot;&gt;golang中国&lt;/a&gt;找个版本下载&lt;/li&gt;
  &lt;li&gt;在/etc/profile中配置&lt;strong&gt;PATH&lt;/strong&gt;、&lt;strong&gt;GOROOT&lt;/strong&gt;、&lt;strong&gt;GOPATH&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;配置你的IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面就开始GOLANG的学习。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基础语法&lt;/h2&gt;

&lt;p&gt;按照惯例，来看Hello World代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
package main

import &quot;fmt&quot;

func main(){
    fmt.Println(&quot;Hello World&quot;);
}
&lt;/pre&gt;

&lt;p&gt;使用&lt;strong&gt;go run hello.go&lt;/strong&gt;即可执行，也可以使用&lt;strong&gt;go build hello.go&lt;/strong&gt;打包完成之后在运行，所有的命令作用如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;build&lt;/td&gt;
      &lt;td&gt;用于测试编译&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clean&lt;/td&gt;
      &lt;td&gt;移除当前源码包里面编译生成的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;env&lt;/td&gt;
      &lt;td&gt;环境变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fix&lt;/td&gt;
      &lt;td&gt;修复以前老版本的代码到新版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fmt&lt;/td&gt;
      &lt;td&gt;代码格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;generate&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get&lt;/td&gt;
      &lt;td&gt;动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;install&lt;/td&gt;
      &lt;td&gt;生成结果文件(可执行文件或者.a包)，把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;list&lt;/td&gt;
      &lt;td&gt;列出当前全部安装的package&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;run&lt;/td&gt;
      &lt;td&gt;编译并运行Go程序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tool&lt;/td&gt;
      &lt;td&gt;运行对应的工具类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;version&lt;/td&gt;
      &lt;td&gt;版本号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;码代码最基本的是变量和常量，在Go中的定义方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var a string = &quot;initial&quot;  /* 变量 */
const s string = &quot;initial&quot; /* 常量 */
&lt;/pre&gt;

&lt;p&gt;另外一些基本的控制结构也基本一致，简单来看就是省略了不少的括号：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// FOR
for i &amp;lt;= 3
for i := 1; i &amp;lt;= 3; i++
for
// IF
if 8%4 == 0
if num := 9; num &amp;lt; 0
// SWITCH
switch time.Now().Weekday() {
    case time.Saturday, time.Sunday:
    default:
}
&lt;/pre&gt;

&lt;p&gt;Go中的集合用起来感觉跟Python中的有点像：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// ARRAY:数组
var a [5]int
b := [5]int{1, 2, 3, 4, 5}
var c [2][3]int

// SLICES:跟数组很像，不过区间操作非常方便
s := make([]string, 10)
l := s[2:5]
l := s[2:]
l := s[:5]

// RANGE:更方便地遍历，数组的话返回下标和值，MAP返回KEY、VALUE
for _,num := nums {
    sum += num;
}

// MAP:这个没什么好说的
m := make(map[string]int)
m[&quot;a&quot;] = 1
m[&quot;b&quot;] = 2
&lt;/pre&gt;

&lt;p&gt;在Go中定义方法也是比较奇葩的语法，用过的其他语言大部分把返回值写在前面，而它是写在后面，不过应该也没有谁优谁劣，而且在Go中方法可以返回多个值(尤其是在后面会用来返回错误)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func vals() (int, int) {// 普通函数：a, b := vals()
    return 1, 2;
}
func sum(nums ...int) {// 可变参数：sum(1, 2)   sum(1, 2, 3)
}
func zeroptr(iptr *int) {// 参数类型为指针
    *iptr = 0
}
func intSeq() func() int {// 闭包
    i := 0
    return func() int {
        i += 1
        return i
    }
}
&lt;/pre&gt;

&lt;p&gt;在Go中所有的面向对象就是&lt;strong&gt;struct&lt;/strong&gt;了，是不是感觉有点简单？或者有点low？另外在Go中定义了一个奇葩的&lt;strong&gt;interface&lt;/strong&gt;，感觉有点像是一个方法的集合：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
type method interface {
    output();
}

type person struct {
    name string
    age  int
}

func (p *person) output(){// 定义方法，再次吐槽：是不是跟Python很像
    fmt.Println(p.name, p.age);
}

func f(m method) { // 为不同对象定义相同的方法，用这个来实现泛型的话，额~~
	fmt.Println(m);
    m.output();
}

func f1(arg int) (int, error) {
    return -1, errors.New(&quot;i can't work！&quot;); // 返回错误
}

// 调用方法
fmt.Println(person{&quot;Bob&quot;, 20})
fmt.Println(person{name: &quot;Alice&quot;, age: 30})
&lt;/pre&gt;

&lt;p&gt;在Go中比较吸引人的应该就是&lt;strong&gt;goroutines&lt;/strong&gt;，面向并发的语言自然要最大程度的简化对应的代码才算合格。在Go中任意一个方法都可以使用&lt;strong&gt;go&lt;/strong&gt;这个关键字来当做一个协程进行处理：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;go func(“abc”)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仅仅这样是不够的，在Go中又提供了&lt;strong&gt;channel&lt;/strong&gt;用来做消息传递，这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;消息传递&lt;/li&gt;
  &lt;li&gt;共享内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种方式在Go里面就凑齐了，另外&lt;strong&gt;select&lt;/strong&gt;也大大简化了IO时候的操作，代码减了多少并不重要，关键是代码与其含义更加地贴近：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
messages := make(chan string)
messages := make(chan string, 2)

messages &amp;lt;- &quot;buffered&quot; // 写入
msg := &amp;lt;-messages // 读取

select {
    case msg := &amp;lt;-messages:
        fmt.Println(&quot;received message&quot;, msg)
    default:// 这样就不会阻塞了
        fmt.Println(&quot;no message received&quot;)
}
&lt;/pre&gt;

&lt;p&gt;总是感觉select与switch很像，不仅仅是写法上面，另外连TimeOut的写法能很简单、粗暴地搞定：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
select {
    case res := &amp;lt;-c1:
        fmt.Println(res)
    case &amp;lt;-time.After(time.Second * 1):
        fmt.Println(&quot;timeout 1&quot;)
    }
&lt;/pre&gt;

&lt;p&gt;用这种方式能设置延迟，在需要重复的场景下可以用&lt;strong&gt;ticker := time.NewTicker(time.Millisecond * 500)&lt;/strong&gt;来解决。&lt;/p&gt;

&lt;p&gt;在Go语言中不支持传统的try-catch-finally这种异常机制，因为Go的设计者认为可能程序员经常会滥用，所以在大部分的情况都通过返回多个值、其中一个为&lt;strong&gt;ERROR&lt;/strong&gt;的办法来处理，只有在真正异常的情况下才使用Go的Exception机制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;defer&lt;/strong&gt;：为函数添加结束时执行的语句&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;panic&lt;/strong&gt;：非常严重的不可恢复的错误&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;recover&lt;/strong&gt;：从错误中恢复&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看简单的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func f() (result int) {// 返回值为1，只有defer执行后才有效
    defer func() {
        result++
    }()
    return 0;
}
panic(&quot;problem&quot;);// 在这个地方程序就挂掉了

func a(){
    panic(&quot;a---error&quot;);
}
func b(){
    panic(&quot;b---error&quot;);
}
func(){
    def func(){
        if r:= recover(); r != nil {
            log.Printf(&quot;caught: %v&quot;, r);
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;用recover的方法有点像缩水版的try-catch，最后，在Go中居然支持&lt;strong&gt;goto&lt;/strong&gt;，虽然我觉得goto还是挺好用的。&lt;/p&gt;

&lt;p&gt;简单把Go的语法过了一遍，总体的感觉就是简单、面向工程开发，没有很多的废话，也没有太多学术上很有用、工程上用的不多的细节。基本语法的例子都可以在&lt;a href=&quot;https://gobyexample.com/&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;工程开发&lt;/h2&gt;

</description>
        <pubDate>Tue, 09 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Spring</title>
        <description>&lt;p&gt;如今作为一个Java程序员，如果没用过Spring的话基本上没法混了~ 这里就不再啰嗦如何如何从EJB走到了Spring(毕竟咱也没经历过那些个艰难的时代)，直接来看它带给我们哪些东西：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;IoC&lt;/li&gt;
  &lt;li&gt;Aop&lt;/li&gt;
  &lt;li&gt;SpringMVC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面分几个部分很粗地描述一下Spring~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;控制反转&lt;/h2&gt;

&lt;p&gt;要看控制反转，那么我们先看看没有反转的时候是什么样子的，当自己的服务依赖于别人的实现时，在其使用之前选择合适的服务实现对其进行初始化：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    private XXService xxService;
    public MyService(){
        this.xxService = new XXServiceImpl();/* 利用合适的实现进行初始化 */
    }
    // ...
}
&lt;/pre&gt;

&lt;p&gt;程序可以正常运行，但是当你有几十个类中使用了XXService，而某一天发现XXServiceImpl是有BUG的，你想换个实现类，那就傻逼了~~&lt;/p&gt;

&lt;p&gt;用IoC最原始的配置方式就可以将这个问题引刃而解：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean id=&quot;myService&quot; class=&quot;com.test.MyService&quot;&amp;gt;
    &amp;lt;property name=&quot;xxService&quot; ref=&quot;xxService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;xxService&quot; class=&quot;com.test.XXServiceImpl&quot;/&amp;gt;&amp;lt;!-- 改这里 --&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在配置文件中搞定他们之间的依赖关系，在使用前，需要用&lt;strong&gt;BeanFactory&lt;/strong&gt;来构建其中的Bean，在需要时，调用&lt;strong&gt;getBean&lt;/strong&gt;取得实例，然后就可以继续后面的操作了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
BeanFactory factory = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
MyService myService = (MyService)factory.getBean(&quot;myService&quot;);
&lt;/pre&gt;

&lt;p&gt;可能“顽固派”会说：干嘛要怎么麻烦，把你要使用的类包装一下再交给MyService使用就可以了啊！确实可以解决问题，但是思路决定出路，这种解决方法确实解决了上面的问题，但是下面&lt;strong&gt;ApplicationContext&lt;/strong&gt;的登场，使得这种依赖管理变得异常简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    @Resource /* 利用注解完成注入 */
    private XXService xxService;
    // ...
}
@Component(&quot;xxService&quot;) /* 声明一个Bean */
public class XXServiceImpl{
    // ...
}
&lt;/pre&gt;

&lt;p&gt;一直感觉注解在Java中的作用就是将配置信息植入到代码文件里面，现在在依赖管理中注解再一次发挥了巨大的威力。到这里基本上满足大部分的需求了，但是Spring提供的功能可能远超过了你需要的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BeanFactoryAware：获取BeanFactory实例&lt;/li&gt;
  &lt;li&gt;BeanPostProcessor：在afterPropertiesSet的方法前后执行&lt;/li&gt;
  &lt;li&gt;InitializingBean：完成一些初始化动作&lt;/li&gt;
  &lt;li&gt;BeanFactoryPostProcessor:处理Bean的定义，也就是BeanDefinition&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有很多其他的扩展点，下面重点看下Bean的生命周期：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Spring-Bean生命周期.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外IoC里面有很多的细节点，逐步整理中：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;byType/byName&lt;/td&gt;
      &lt;td&gt;根据类型/名字注入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;scope(singleton/prototype)&lt;/td&gt;
      &lt;td&gt;单例还是每次都生成一个新的Bean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;factory-bean/FactoryBean&lt;/td&gt;
      &lt;td&gt;工厂类型的Bean，getBean时会调用其getObject方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Resource&lt;/td&gt;
      &lt;td&gt;默认byName，找不到的时候就byType(指定name就只能byName了)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Autowire&lt;/td&gt;
      &lt;td&gt;默认byType，可以配合@Qualifier变为byName&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lazy-init&lt;/td&gt;
      &lt;td&gt;只对singleton的Bean起作用，效果是在getBean的时候才初始化&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;面向切面编程&lt;/h2&gt;

&lt;p&gt;面向切面编程(Aspect Oriented Programming)提供了另外一个角度来考虑程序结构，在介绍AOP的时候几乎都会介绍&lt;strong&gt;打日志&lt;/strong&gt;的需求，当然除此之外还有很多的场景，这里就不赘述。简单来说Spring的AOP提供了拦截一批方法的手段。&lt;/p&gt;

&lt;p&gt;其实我们自己也可以利用&lt;strong&gt;BeanFactoryPostProcessor&lt;/strong&gt;来实现类似的功能，但在Spring中AOP强大的地方是提供了很多种方便的配置方式。第一种是用XML的配置方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect id=&quot;logaop&quot; ref=&quot;allLogAdvice&quot;&amp;gt;&amp;lt;!--处理类 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.test.MyService.*(..))&quot; /&amp;gt;&amp;lt;!-- 方法 --&amp;gt;
        &amp;lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&amp;gt;&amp;lt;!-- 方式及调用方法 --&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;

&lt;p&gt;另外一种个人感觉比较好用的就是&lt;strong&gt;@Aspect&lt;/strong&gt;方式，这种方式把方法和它要拦截的方法放在一个地方，比较自然一点：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class MyAspect {
    @Pointcut(&quot;execution(* com.test.MyService.*(..))&quot;)
    private void aspectjMethod(){};

    @Before(&quot;service()&quot;)
    private void aroundMethod(){ /* code */ }
}
&lt;/pre&gt;

&lt;p&gt;在使用前需要配置&lt;strong&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/strong&gt;，第二种方式确实有一些进步，但是考虑注解之后，AOP的功能开始变得有点IMBA了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class LocalCacheAspect {
    @Pointcut(&quot;@annotation(localCache)&quot;)
    public void getLocalCacheAnnotation(LocalCache localCache) {}

    @Around(&quot;getLocalCacheAnnotation(localCache)&quot;)
    public Object handleCache(ProceedingJoinPoint joinPoint, LocalCache localCache) throws Throwable {
        /* code */
    }
}
&lt;/pre&gt;

&lt;p&gt;这样当你在Spring的某个方法上加注解&lt;strong&gt;@LocalCache&lt;/strong&gt;后，就可以被handleCache拦截了，在这里需要注意一下大小写。在具体实现的时候AOP利用了两种技术：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JDK动态代理&lt;/li&gt;
  &lt;li&gt;CGLIB字节码生成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想选择cglib需要配置文件中加上&lt;strong&gt;&amp;lt;aop:aspectj-autoproxy proxy-target-class=”true”/&amp;gt;&lt;/strong&gt;。
AOP中涉及到的细节整理如下(不断更新中)：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Pointcut&lt;/td&gt;
      &lt;td&gt;通常使用正则表达式来描述切入的点(拦截哪些方法)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Advice&lt;/td&gt;
      &lt;td&gt;在特定的Pointcut执行的动作：around、before、throws等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Joinpoint&lt;/td&gt;
      &lt;td&gt;具体运行时拦截到的信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;

&lt;p&gt;细想一下大部分的Java程序员应该都在直接或者间接的做页面开发，那么这里就涉及到分层的概念了，当然这里不会讲这些东西。在WEB应用作用，不能不提&lt;strong&gt;web.xml&lt;/strong&gt;,其中需要清楚&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;listener&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;servlet&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它们的作用以及运行机制，在通过SpringMVC来开发Web应用前，需要配置：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.htm&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/pre&gt;

&lt;p&gt;这样就把所有以&lt;strong&gt;.htm&lt;/strong&gt;结尾的请求都交给&lt;strong&gt;DispatcherServlet&lt;/strong&gt;进行具体的处理并返回，过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常用的&lt;strong&gt;handleMapping&lt;/strong&gt;的方式有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SimpleUrlHandlerMapping&lt;/li&gt;
  &lt;li&gt;DefaultAnnotationHandlerMapping&lt;/li&gt;
  &lt;li&gt;AnnotationMethodHandlerAdapter&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用注解的方式更直观一些，在代码中直接就可以明白你正在处理什么样的请求，最简单的一个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Controller
@RequestMapping(&quot;/helloAnnoController.html&quot;)
public class AnyTypeYouLikeController{
    @RequestMapping(method={RequestMethod.GET,RequestMethod.POST})
    public String processWebRequest(){
        return &quot;anno/helloAnnController&quot;;
    }
}
&lt;/pre&gt;

&lt;p&gt;PS：现在各种WEB框架非常多，关键是了解它们运行机制，在遇到问题的时候可以DEBUG去找到解决办法，对某个框架有哪些“奇技淫巧”就不说了，细节太多了···&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;数据访问&lt;/h2&gt;

&lt;p&gt;首先想想要想是的访问数据更方便，Spring应该做什么事情？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;统一的异常处理&lt;/li&gt;
  &lt;li&gt;将相同（类似）操作进行封装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果直接用JDBC来完成数据访问，大致如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    Connection connection = getDataSource().getConnection();
    Statement statement = connection.createStatement();
    // TODO 执行数据库操作
    statement.executeUpdate(&quot;sql...&quot;);
    statement.close();
}finally{
    statement.close();
    connection.close();
}
&lt;/pre&gt;

&lt;p&gt;显然在使用JDBC API处理数据的时候会有大量相似的代码，不仅增加了代码量，而且使得业务
逻辑不清晰、工程难维护。在Spring中用&lt;strong&gt;JdbcTemplate&lt;/strong&gt;通过模板方式来解决这些问题：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class JdbcTemplate {
    public Object execute(StatementCallback action) throws DataAccessException
    {
       // 将连接数据库等操作抽取出来
    }
}
&lt;/pre&gt;

&lt;p&gt;在JdbcTemplate中定义了很多queryXXX和updateXXX的方法，其本质上还是&lt;strong&gt;Callback&lt;/strong&gt;的方
式实现的，定义出来方便我们使用：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
JdbcTemplate jdbcTemplate = new JdbcTemplate();
jdbcTemplate.setDataSource(ds);
jdbcTemplate.execute(new StatementCallback(){
    public Object doInStatement(Statement stmt) throws SQLException {
        stmt.execute(&quot;your sql&quot;);
        return ret;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样编码起来方便了很多，但是接着会想如果我们把SQL写到单独的文件里面，这样剥离开应该
会更好一下吧，这样就有了各种ORM，比如&lt;strong&gt;iBatis&lt;/strong&gt;和&lt;strong&gt;Hibernate&lt;/strong&gt;，在iBatis中用SqlMapClient
来访问数据，通常访问的方式有三种：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
//1、基于SqlMapCLient的自动提交事务型简单数据访问
Map parameters = new HashMap();
parameters.put(&quot;param1&quot;, value);
// ..
Object ret = sqlMap.queryForObject(&quot;sql_id&quot;, parameters);
// 2、基于SqlMapClient的非自动提交事务型数据访问
try{
    sqlMap.startTransaction();
    sqlMap.update(&quot;....&quot;);
    sqlMap.commitTransaction();
} finally {
    sqlMap.endTransaction();
}
// 3、基于SqlMapSession的数据访问
SqlMapSession session = null;
try{
    session = sqlMap.openSession();
    session.startTransaction();
    session.update(&quot;...&quot;);
    session.commitTransaction();
} finally {
    session.endTransaction();
}
&lt;/pre&gt;

&lt;p&gt;因为Spring在集成iBatis的时候要考虑将事务控制也纳入进来，所以使用基于SqlMapSession
的数据访问方式对iBatis进行集成，这种方式更灵活，可以将iBatis内部直接指定的数据源和事
务管理器等转由外部提供（IoC），&lt;strong&gt;SqlMapClientTemplate&lt;/strong&gt;是Spring为iBatis的数据访问操
作提供的模板方法类：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class SqlMapClientTemplate {
    public Object execute(SqlMapClientCallback action) throws DataAccessException {
        // ...
    }
}
&lt;/pre&gt;

&lt;p&gt;SqlMapClientCallback可以完成任何基于iBatis的数据访问操作，比如要向一个数据库批量提
交更新数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
protected void batchInsert(final List beans) {
    sqlMapClientTemplate.execute(new SqlMapClientCallback() {
        public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
            executor.startBatch();
            Interator iter = beans.iterator();
            while(iter.hasNext()) {
                Bean bean = (Bean) iter.next();
                executor.insert(&quot;insert_name&quot;, bean);
            }
            executor.executeBatch();
            return null;
        }
    });
}
&lt;/pre&gt;

&lt;p&gt;最后来看事务处理，局部事务的话用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    transaction = session.beginTransaction();
    // TODO 操作数据
    session.flush();
    transaction.commit();
} catch (Exception e){
    transaction.rollback(); // 回滚
} finally {
    session.close();
}
&lt;/pre&gt;

&lt;p&gt;因为JDBC的局部事务控制是由同一个Connection来完成的，所以要保证两个DAO的数据访问
方式处于一个事务中，我们就得保证他们使用的是同一个Connection，要做到这一点，通常采
用称为connection-passing的方式，即为同一个事务中的各个DAO的数据访问传递当前事务对
应的同一个Connection。&lt;/p&gt;

&lt;p&gt;我们可以直接使用PlatformTransactionManager，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
definition.setXXX();
definition.setXXX();
TransactionStatus status = transactionManager.getTransaction(definition);
try {
    // TODO 业务逻辑
} catch (Exception e) {
    transactionManager.roolback(status);
}
transactionManager.commit(status);
&lt;/pre&gt;

&lt;p&gt;可以看到上面有很多重复的操作，接着用TransactionTemplate对事务的管理进行模板化。而
基于申明式的事务有四种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ProxyFactory + TransactionInterceptor&lt;/li&gt;
  &lt;li&gt;TransactionProxyFactoryBean&lt;/li&gt;
  &lt;li&gt;BeanNameAutoProxyCreator&lt;/li&gt;
  &lt;li&gt;Spring 2.x申明事务配置方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然也可以通过注解&lt;strong&gt;@Transactional&lt;/strong&gt;来申明事务。&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
