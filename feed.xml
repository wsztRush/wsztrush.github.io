<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 17 Jan 2016 19:44:31 +0800</pubDate>
    <lastBuildDate>Sun, 17 Jan 2016 19:44:31 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>进入Linux的世界</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/LINUX-MINT-1.png&quot; width=&quot;500px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;断断续续地用过一段时间&lt;strong&gt;Ubuntu&lt;/strong&gt;，但也只是玩玩而已，一直没有勇气抛弃&lt;strong&gt;Windows&lt;/strong&gt;。后来公司要求安装的软件越来越多（各种杀毒、监控）、开机速度越来越慢、看着越来越红的C盘，是时候开启Linux了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;的界面有点丑，于是这次尝试用&lt;strong&gt;Linux Mint Cinnamon&lt;/strong&gt;，安装方式很常规：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载镜像&lt;/li&gt;
  &lt;li&gt;用dd命令刻录到U盘&lt;/li&gt;
  &lt;li&gt;按照提示一路设置就可以了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来开始安装需要的软件。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一、文本编辑&lt;/h3&gt;

&lt;p&gt;自带的vi和gedit能用，但需要更强大的（VIM）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install vim
&lt;/pre&gt;

&lt;p&gt;关于VIM的用法可以看&lt;a href=&quot;http://wsztrush.github.io/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html&quot;&gt;《VIM入门》&lt;/a&gt;，虽然强大但现在并不熟练，于是想起来在Windows上用的挺爽的&lt;strong&gt;sublime text&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install sublime-text
&lt;/pre&gt;

&lt;p&gt;结果发现和Windows版的有点区别：无法输入中文。感兴趣的可以看&lt;a href=&quot;http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html&quot;&gt;这里&lt;/a&gt;，不过由于&lt;strong&gt;VSCODE&lt;/strong&gt;突然火了一把赶紧从&lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;官网&lt;/a&gt;下载，用着还不错，到现在还用它来开发前端代码。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、浏览器&lt;/h3&gt;

&lt;p&gt;自带的火狐还不错，但是团队做的系统目前只考虑兼容Chrome，只好去下载个。。。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、前端开发环境&lt;/h3&gt;

&lt;p&gt;对前端来说&lt;strong&gt;nodejs&lt;/strong&gt;是必须的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install nodejs
sudo apt-get install npm
&lt;/pre&gt;

&lt;p&gt;为了顺畅使用可以考虑切成&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;淘宝镜像&lt;/a&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
npm config set registry https://registry.npm.taobao.org
&lt;/pre&gt;

&lt;p&gt;打包工具使用&lt;a href=&quot;http://www.gruntjs.net/&quot;&gt;Grunt&lt;/a&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
npm install -g grunt-cli
&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;四、后端开发环境&lt;/h3&gt;

&lt;p&gt;工作中后端开发使用的是Java，貌似系统自带了JDK不过不全，只能自己动手：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install openjdk-7-jdk
&lt;/pre&gt;

&lt;p&gt;记得在&lt;strong&gt;~/.bashrc&lt;/strong&gt;设置变量：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
&lt;/pre&gt;

&lt;p&gt;另外maven是少不了的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install maven2
&lt;/pre&gt;

&lt;p&gt;代码编辑使用IDEA，直接从官网下载就可以了（14一直有BUG，现在用的是13）。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;五、输入法&lt;/h3&gt;

&lt;p&gt;用过搜狗，但是偶尔BUG，现在用ibus：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install ibus-rime ibus-gtk* ibus-qt4
&lt;/pre&gt;

&lt;p&gt;下载之后学了一段时间双拼，后来想想为啥要在这上面浪费时间，于是果断换回全拼，囧。在排查线上问题的时候需要用到很多命令，在压力巨大的情况下不一定能打出来，那么可以在输入法上做一点文章：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/LINUX-MINT-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在【Edit custom phrase】里面加入：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gc=jstat -gcutil&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在可以“临危不乱”了:)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/LINUX-MINT-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其实之前一直觉得配上机械键盘敲键盘熟练地敲命令挺爽的，但是最近登录跳板的那么一大串命令实在是有点烦了。。。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;六、聊天工具&lt;/h3&gt;

&lt;p&gt;工作一直用旺旺，但Linux上这货BUG太多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;刚启动CPU一直是100%&lt;/li&gt;
  &lt;li&gt;用一段时间界面就乱了，测试了下关闭一些特效会稍微好点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了旺旺尝试过用&lt;strong&gt;Oracle VM VirtualBox&lt;/strong&gt;装Windows虚拟机，但是没搞定（囧），以后有时间继续。好在公司现在要转钉钉，有WEB版，幸福感飙升。。。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;七、图片&lt;/h3&gt;

&lt;p&gt;用Visio画图很方便，可惜Linxu上没有，可以考虑用yEd，从&lt;a href=&quot;http://www.yworks.com/&quot;&gt;官网&lt;/a&gt;下载后执行脚本：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;xxxxxxx_setup.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然你可以可以考虑用VIM来画图（可以看&lt;a href=&quot;http://wsztrush.github.io/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016/01/05/VIM-PAINT.html&quot;&gt;这里&lt;/a&gt;），用来对付简单的图还是比较给力的。&lt;/p&gt;

&lt;p&gt;之前一直使用旺旺的截图，现在不行来，感觉&lt;strong&gt;shutter&lt;/strong&gt;还是不错的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo apt-get install shutter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-7&quot;&gt;八、博客&lt;/h3&gt;

&lt;p&gt;博客使用jekyll来搞的，需要安装ruby（因为jekyll对ruby版本有要求，只能下源码搞了）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
tar xzvf ruby-2.2.2.tar.gz 
cd ruby-2.2.2
./configure –prefix=/usr/local/ruby  
make &amp;amp;&amp;amp; make install
&lt;/pre&gt;

&lt;p&gt;刚开始因为python3没有向后兼容一直报错，把版本退回去才搞定。。。同样如果你是墙内用户可以考虑用淘宝的源：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
gem sources --remove https://rubygems.org/
gem sources -a http://ruby.taobao.org/
&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;九、总结&lt;/h3&gt;

&lt;p&gt;用了有几个月了，平常的使用已经慢慢熟悉起来了，而且感觉【工作区】的功能还是挺炫的（Ctrl+Alt+【方向键】），也比较实用。而且使用Linux会让你有一种&lt;strong&gt;everything is under control&lt;/strong&gt;的错觉:)&lt;/p&gt;

&lt;p&gt;总的来说：值得拥有！&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E4%BD%9C/2016/01/17/LINUX.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E4%BD%9C/2016/01/17/LINUX.html</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>必然</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s28377994.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还没看过《失控》有点遗憾，再加上罗胖极力推荐，于是带着很大的期望来看《必然》。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;内容&lt;/h2&gt;

&lt;p&gt;对未来三十年的一些预测，通过十二个关键字来概括。&lt;/p&gt;

&lt;h3 id=&quot;becoming&quot;&gt;一、形成（Becoming）&lt;/h3&gt;

&lt;p&gt;技术不断的发展，每天都在变得更好一点，但是这种进步通常不被察觉，在不断的升级中我们将永远都是菜鸟，所谓的“进乌托邦”。&lt;/p&gt;

&lt;h3 id=&quot;cognifying&quot;&gt;二、知化（Cognifying）&lt;/h3&gt;

&lt;p&gt;在各个领域出现高度的智能化：医学、化学实验等，机器人将代替绝大多数的机械劳动。&lt;/p&gt;

&lt;h3 id=&quot;flowing&quot;&gt;三、流动（Flowing）&lt;/h3&gt;

&lt;p&gt;一个东西一旦可以复制，那么很快就会变得廉价甚至免费（想想你产出的东西是不是可复制的），比免费更重要的一些属性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;及时性&lt;/li&gt;
  &lt;li&gt;个性化&lt;/li&gt;
  &lt;li&gt;解释性：比如给你DNA序列也没用啊，你需要的是如何去解释这个序列&lt;/li&gt;
  &lt;li&gt;可靠性&lt;/li&gt;
  &lt;li&gt;获取权：获取服务&lt;/li&gt;
  &lt;li&gt;实体化&lt;/li&gt;
  &lt;li&gt;可赞助&lt;/li&gt;
  &lt;li&gt;可寻性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流动意味着处理的将不再是静止的，会具有更高的实时性，以后我们更多的是会去面对信息流。&lt;/p&gt;

&lt;h3 id=&quot;screening&quot;&gt;四、屏读（Screening）&lt;/h3&gt;

&lt;p&gt;可以通过屏幕获取几乎所有需要的信息。&lt;/p&gt;

&lt;h3 id=&quot;accessing&quot;&gt;五、使用（Accessing）&lt;/h3&gt;

&lt;p&gt;简单来说就是：租比买好！在提供服务上有几个趋势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减物质化&lt;/li&gt;
  &lt;li&gt;去中心化&lt;/li&gt;
  &lt;li&gt;即时性&lt;/li&gt;
  &lt;li&gt;平台协同&lt;/li&gt;
  &lt;li&gt;云&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用可以是按需获取到更优质的服务（所以罗胖卖房？）。&lt;/p&gt;

&lt;h3 id=&quot;sharing&quot;&gt;六、共享（Sharing）&lt;/h3&gt;

&lt;p&gt;由很多人来共同完成看似不可能的事情：维基百科（或者linux？）。&lt;/p&gt;

&lt;h3 id=&quot;filtering&quot;&gt;七、过滤（Filtering）&lt;/h3&gt;

&lt;p&gt;信息产生的速度飞快，过滤意味着让用户更好的选择感兴趣的信息，而我们则需要花心思让用户注意到我们。&lt;/p&gt;

&lt;h3 id=&quot;remixing&quot;&gt;八、重混（Remixing）&lt;/h3&gt;

&lt;p&gt;对已有的事物的重新排列和再利用（在视频剪切中非常常见）。&lt;/p&gt;

&lt;h3 id=&quot;interacting&quot;&gt;九、互动（Interacting）&lt;/h3&gt;

&lt;p&gt;虚拟现实会带来非常好的互动效果，不能互动的东西在未来将被认为是坏的。&lt;/p&gt;

&lt;h3 id=&quot;tracking&quot;&gt;十、追踪（Tracking）&lt;/h3&gt;

&lt;p&gt;通过硬件、互联网来“追踪”获取信息，通过人工智能来“追踪”信息的价值。&lt;/p&gt;

&lt;h3 id=&quot;questioning&quot;&gt;十一、提问（Questioning）&lt;/h3&gt;

&lt;p&gt;每找到一个答案的时候就会产生两个新的问题，互联网会有很多很多的不可能，在网络上找到答案的成本很低，好的问题价值非常大。&lt;/p&gt;

&lt;h3 id=&quot;beginning&quot;&gt;十二、开始（Beginning）&lt;/h3&gt;

&lt;p&gt;所有的都已经开始，但也仅仅是个开始。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;书中的很多内容其实有想过（或者跟别人聊过），未来已来，只是尚未流行。以后需要多接触新的东西，并思考这些新东西的本质。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;可能跟翻译也有点关系，感觉有点乱（读起来不是很顺畅），不过还是值得一读。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/10/THE-INEVITABLE.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/10/THE-INEVITABLE.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>创造:只给勤奋者的创新书</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.doubanio.com/mpic/s28351737.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;公司里面比较鼓励员工写专利（有奖金），但是，看了很多通过的专利文档后简直颠覆了对专利的看法：怎么什么都能申请专利？如果你有一样的想法，看完这本书可能就没了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;内容&lt;/h2&gt;

&lt;p&gt;书的原名叫《How To Fly A Horse》，译者翻译为《创造》虽然很朴实但挺准确的，这本书整本都围绕着创造（或者创新）。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一、创造很寻常&lt;/h3&gt;

&lt;p&gt;爱德蒙（一个十二岁的非洲奴役）解决了难倒欧洲几百年的香草授粉的难题，可见创造本身并没有特别的门槛！我们知道“爱德蒙手势”，但并不知道：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;是谁第一次发现兰花的果实可以加工变成美味。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这难道不是创造吗？还有很多很多的了不起的发现不为所知，但是并不代表它们不存在。现在有了专利系统可以统计一下创造发明的情况：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每4000个美国人就有一个人申请专利。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可见专利（或者创造）并不是极少数精英的专属领域（把创造者拉下神坛），那么再回过头来看什么是创造：&lt;strong&gt;创造就是工作&lt;/strong&gt;（把创造拉下神坛）。特曼搞优生学，想搞个实验来证明智商是门槛，结果却是打脸（用这个例子来证明IO和创造没关系，逻辑性不是特别强吧）。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;二、思考就像散步&lt;/h3&gt;

&lt;p&gt;思考过程是一步一个脚印（遇到问题、解决问题、遇到问题..）的，就像散步！用&lt;strong&gt;利用图钉、火柴把蜡烛固定在墙上&lt;/strong&gt;实验来证明思考的过程，并对一些“顿悟”提出质疑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阿基米德洗澡的时候想到鉴别皇冠的方法&lt;/li&gt;
  &lt;li&gt;忽必烈的诗是在梦中想到的&lt;/li&gt;
  &lt;li&gt;梦中发现苯的环状结构&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用爱因斯坦的话来将问题的解决就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是一步一步朝它迈进的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以不要太期望在睡梦中孵化出“啊哈！时刻”，你应该花尽量多的时间思考！&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三、遇见逆境&lt;/h3&gt;

&lt;p&gt;在福克曼利用杀死肿瘤周围的血管来饿死癌细胞的方法解救了詹妮弗的下巴之前：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不能出版文章&lt;/li&gt;
  &lt;li&gt;不能收到资助&lt;/li&gt;
  &lt;li&gt;不能做外科手术&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;甚至被除名，当他成功以后却成了哈佛大学的骄傲。在创造的过程中会遇到很多的逆境和失败，需要非常坚韧地去坚持，去证明自己是正确的。&lt;/p&gt;

&lt;p&gt;如果不想着证明自己但却到处喊口号，可能会像赛迈尔维斯那样，虽然拯救了无数孕妇的生命，但结局却是在精神病院里被打死，而更重要的是错过了细菌的发现：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;非同寻常的发现需要非同寻常的证明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;遇到逆境有时候要以退为进，反思自己的思路是否正确（不反思的下场就是跳伞摔死的瑞切特）。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;四、如何去看&lt;/h3&gt;

&lt;p&gt;有时候重大的发现就在眼皮低下，但就是没人看到，比如&lt;strong&gt;幽门螺旋杆菌&lt;/strong&gt;（传统认为胃酸里面不可能存在细菌）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我倾向于相信我的眼睛，而不是医学教材或者医学界同仁！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在眼睛看到图像交给大脑的过程中，会对信息利用已有的知识做一系列的过滤，以至于我们只能看到关心的东西：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;医学专家能看一眼X光片就知道出了什么问题，但没发现其中的猩猩&lt;/li&gt;
  &lt;li&gt;国际大师下象棋时只需要考虑很少的可能走法，而新手需要考虑更多的可能性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一种高效的机制（很有好处），但是会阻碍发现新的东西：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;技艺的真正秘诀是永远当一个初学者！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓的“不忘初心”？&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;五、应授予荣誉时&lt;/h3&gt;

&lt;p&gt;罗莎琳德·富兰克林是发现DNA双螺旋结构过程中最重要的一环，但是荣誉却给了沃森和克里克，一直以来女性都不公平！这章有点像在讲野史。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;六、结果之链&lt;/h3&gt;

&lt;p&gt;创造新事物的链条长的不可预测（可口可乐的生产过程），而创造的结果更难预测。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;七、创造的动力&lt;/h3&gt;

&lt;p&gt;伍迪·艾伦获得过很多的奥斯卡，但是都没有去领奖（领完奖可能就写不出来了）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当你真正坐下来写作时，感觉就像在吃一顿你在厨房里花一整天做出来的饭。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内在因素（感觉有点像兴趣的力量）才是创造真正的动力，而外在（比如钱）的常常会形成阻碍。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;八、创造型组织&lt;/h3&gt;

&lt;p&gt;二战期间Skonk工厂用184天造出来喷气式飞机：8-80流星战斗机，创造型组织在有不同的观点产生时应该给它们机会，当：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;约翰逊认为飞机模型不稳定的时候&lt;/li&gt;
  &lt;li&gt;里奇设计出隐形飞机的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给他们&lt;strong&gt;证明给你看&lt;/strong&gt;的机会，当然是用行动而不是嘴巴去证明！&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;九、再见了，天才&lt;/h3&gt;

&lt;p&gt;没有天才，每个人都有天赋。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;整体上看内容并没有安排的特别清晰，不同章节想要表达的意思重复，内容有点冗余。不过，里面穿插了很多不错的故事。看完这本书之后一个感觉就是让你：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不要在想“我做不到”、“我创造不出什么”！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可以的！有点鸡汤的味道。。而创造需要的是什么？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;激情&lt;/li&gt;
  &lt;li&gt;高度的专注和大量的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而不是做着白日梦等待顿悟，不过在作者看来潜意识对思考好像没什么作用，创新都是靠着一步一步思考出来的，这一点我还是持怀疑的态度。另外，虽然看完这本说，我还是觉得世界上存在天才:-)&lt;/p&gt;

&lt;p&gt;作为一个程序猿如何创造？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;专业知识&lt;/li&gt;
  &lt;li&gt;不要为了做项目而做项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不要在开发的过程中把现有的框架当成理所当然（当成初学者），去思考问题的本质是什么，去思考如何解决问题！&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;逻辑不强，故事不错，值得一读（快读）。&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/09/HOW-TO-FLY-A-HORSE.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/09/HOW-TO-FLY-A-HORSE.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>用VIM画图</title>
        <description>&lt;p&gt;在Linux上其实并不缺少画图软件（比如yEd等），那么为什么还需要用VIM来画图：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;更轻，不需要安装太多东西&lt;/li&gt;
  &lt;li&gt;更小，就是一些文本，比图片什么的小多了，使用起来也更简单&lt;/li&gt;
  &lt;li&gt;更有逼格&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先，在VIM中安装DrawIt插件（可以参考&lt;a href=&quot;http://wsztrush.github.io/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html&quot;&gt;这里&lt;/a&gt;），然后就可以开始画图之旅，在命令模式下使用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\di&lt;/code&gt;：开启DrawIt&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\ds&lt;/code&gt;：关闭DrawIt&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开启之后有两种模式：&lt;strong&gt;画图&lt;/strong&gt;和&lt;strong&gt;擦除&lt;/strong&gt;，他们之间通过&lt;strong&gt;空格&lt;/strong&gt;来切换。可以使用按键来控制向八个方向画线（或者擦除）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;方向键的上、下、左、右分别对应其四个方向&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pgup&lt;/strong&gt;：上右&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pgdn&lt;/strong&gt;：下右&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Home&lt;/strong&gt;：左上&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;End&lt;/strong&gt;：左下&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下图（其实也不需要记，和键盘上的位置是一致的）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
                         Home    Up   Pgup
                             \   |   / 
                              \  |  / 
                               \ | / 
                                \|/ 
                        Left----------Right
                                /|\
                               / | \
                              /  |  \
                             /   |   \
                          End   Down  Pgdn

&lt;/pre&gt;

&lt;p&gt;箭头的画法也很直观，简单的箭头用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;就搞定了，粗的箭头可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;\&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\&amp;lt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\^&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\v&lt;/code&gt;来弄（感觉粗的箭头不太好控制）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
 &amp;gt; &amp;lt; ^ v  |&amp;gt; &amp;lt;|
              
   _ _      . 
   \ /     /_\
    &#39;         
&lt;/pre&gt;

&lt;p&gt;用鼠标可以选择块，这对后面的操作有一定的简化，利用用&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;\l&lt;/code&gt;不带箭头）来根据选中的块来画线：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
-------                               
       \-----------                   
                   \-----------       
                               \-----&amp;gt;
&lt;/pre&gt;

&lt;p&gt;或用&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;来画矩形框或者用&lt;code class=&quot;highlighter-rouge&quot;&gt;\e&lt;/code&gt;来画椭圆：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
+--------------------+          *************      
|                    |      ****             ****  
|                    |    **                     **
+--------------------+    *                       *
                          **                     **
                            ****             ****  
                                *************      
&lt;/pre&gt;

&lt;p&gt;完事了可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt;来对图形进行填充：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
+------------------+
|##################|
|##################|
|##################|
+------------------+
&lt;/pre&gt;

&lt;p&gt;位置有一些偏差是常有的事情，这时候不要急着重画：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用鼠标选中要移动的块，然后按住ctrl并拖动鼠标。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当要擦除一整快的内容时，用方向键来搞也比较蛋疼，可以用：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用鼠标选中要擦除的部分，然后执行r &amp;lt;space&amp;gt;（相当于用空格替换）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外需要注意：ubuntu和mint上安装到VIM默认是不支持&lt;strong&gt;系统剪贴板&lt;/strong&gt;的，需要安装：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo apt-get install vim-gnome&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单体验下来，如果能灵活运用VIM本身的强大功能（复制、粘贴等），DrawIt用起来还是挺给力的！&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016/01/05/VIM-PAINT.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016/01/05/VIM-PAINT.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>NETTY基础知识</title>
        <description>&lt;p&gt;网络IO总体上分为（&lt;a href=&quot;http://www.cnblogs.com/Anker/p/3254269.html&quot;&gt;这里&lt;/a&gt;的比喻不错）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阻塞&lt;/li&gt;
  &lt;li&gt;非阻塞&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;阻塞的方式写起来很简单：当链接可读的时候就读一些，不可读的时候就等待：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ServerSocket serverSocket = new ServerSocket(8787);
while (true) {
    Socket socket = serverSocket.accept();
    // TODO 交给线程池进行处理。
}
&lt;/pre&gt;

&lt;p&gt;网络情况不好时阻塞的方式用起来有点蠢，用NIO（有点像SELECT/EPOLL）会靠谱些，当有链接可读时让工作线程来拿数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Selector selector = Selector.open();

ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.socket().bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8787));
serverSocketChannel.configureBlocking(false);
serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    selector.select();
    Set&amp;lt;SelectionKey&amp;gt; selectionKeySet = selector.selectedKeys();
    Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeySet.iterator();
    while (iterator.hasNext()) {
        SelectionKey selectionKey = iterator.next();
        if (selectionKey.isAcceptable()) {
            ServerSocketChannel channel = (ServerSocketChannel) selectionKey.channel();
            SocketChannel socketChannel = channel.accept();
            socketChannel.configureBlocking(false);
            socketChannel.register(selector, SelectionKey.OP_READ);
        }
        if (selectionKey.isReadable()) {
            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
            int size = socketChannel.read(byteBuffer);
            if (size &amp;lt; 0) {
                selectionKey.cancel();
                socketChannel.close();
            }
            for (int i = 0; i &amp;lt; size; i++) {
                System.out.print((char) byteBuffer.get(i));
            }
        }
        iterator.remove();
    }
}
&lt;/pre&gt;

&lt;p&gt;写最简单的功能都要这么多代码，维护起来也比较痛苦，下面来看如何用NETTY简化开发！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;下面的代码用来实现上面的功能：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
EventLoopGroup bossGroup = new NioEventLoopGroup();
EventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, 1024)
        .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
            protected void initChannel(SocketChannel ch) throws Exception {
                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                        ByteBuf buffer = (ByteBuf) msg;
                        int size = buffer.readableBytes();
                        for (int i = 0; i &amp;lt; size; i++) {
                            System.out.print((char) buffer.getByte(i));
                        }
                    }
                });
            }
        });
ChannelFuture future = bootstrap.bind(8787).sync();
future.channel().closeFuture().sync();
&lt;/pre&gt;

&lt;p&gt;看起来也不怎么直观，不要急，先来了解一些NETTY中的概念：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;概念&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Bootstrap/ServerBootstrap&lt;/td&gt;
      &lt;td&gt;配置netty（添加组件、设置参数）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Channel&lt;/td&gt;
      &lt;td&gt;定义I/O操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ChannelHandlerContext&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ChannelHandler&lt;/td&gt;
      &lt;td&gt;处理感兴趣的事件（read、readomplete、bind、flush等）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ChannelPipeline&lt;/td&gt;
      &lt;td&gt;ChannelHandler的容器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EventLoop/EventLoopGroup&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Future/Promise&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unsafe&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ByteBuf&lt;/td&gt;
      &lt;td&gt;处理缓存的工具，比byte[]或者java.nio.ByteBuffer好用一些&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/29/NETTY-BASIC.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/29/NETTY-BASIC.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>用数据来驱动仓库</title>
        <description>&lt;p&gt;双十一的时候去仓库驻仓，还是挺激动的，在十号的时候开始动员大会，由于双十一的量会比平时大很多，所以需要挺多的临时工帮忙：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DATA-DRIVEN-WAREHOUSE-2.jpg&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;过了十一号的零点，本来大家以为会有很多的单子下来，但是并没有:(！大约过了半个小时才有第一单下来，然后陆陆续续地来了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DATA-DRIVEN-WAREHOUSE-4.jpg&quot; height=&quot;300&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双十一的单量不是盖的，大家也按照之前的准备开干，热火朝天：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DATA-DRIVEN-WAREHOUSE-3.jpg&quot; width=&quot;300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然，机器也很忙：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DATA-DRIVEN-WAREHOUSE-1.jpg&quot; width=&quot;300px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在都在讲数据驱动，在仓库的时候也想了一下如何做，下面是一些简单的想法。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;精确&lt;/h2&gt;

&lt;p&gt;和&lt;a href=&quot;http://www.umeng.com/&quot;&gt;友盟&lt;/a&gt;的场景有很大的不同，尤其是数据准确性上：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PV/UV这些数据错一两个没关系，但是给生产用的报表不行！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果有一个订单在数据上看到的是没有完成，那么仓库管理员就会去排查到底是卡在什么环节！还有，平时看到的大部分报表都是T-1（昨天）的，这种数据很难用来帮助生产，所以要做到数据驱动还是需要&lt;strong&gt;实时&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;展示&lt;/h2&gt;

&lt;p&gt;数据可视化是非常有学问的一个东西，之前看别人的思考竟然都考虑到色盲，比较佩服！但是现在要讨论的并不是这个，在仓库中一个好的展示必须是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可查询/设置&lt;/li&gt;
  &lt;li&gt;有明细&lt;/li&gt;
  &lt;li&gt;汇总信息一目了然（尤其是大盘上）&lt;/li&gt;
  &lt;li&gt;统计逻辑清晰、没有任何歧义&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些算是最起码的要求了!&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;报警&lt;/h2&gt;

</description>
        <pubDate>Sat, 26 Dec 2015 00:00:00 +0800</pubDate>
        <link>/%E5%85%B6%E4%BB%96/2015/12/26/DATA-DRIVEN-WAREHOUSE.html</link>
        <guid isPermaLink="true">/%E5%85%B6%E4%BB%96/2015/12/26/DATA-DRIVEN-WAREHOUSE.html</guid>
        
        
        <category>其他</category>
        
      </item>
    
      <item>
        <title>ZOOKEEPER基础知识</title>
        <description>&lt;p&gt;搞数据开发的对一些产品非常熟悉，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HBase&lt;/li&gt;
  &lt;li&gt;Hadoop&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是对它们背后共同的“男人”没有太多的了解，太不应该了。这篇是一个基础的介绍，看完之后应该会对ZOOKEEPER有大概了解。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;安装部署&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;http://zookeeper.apache.org/releases.html&quot;&gt;这里&lt;/a&gt;下载包，放到你喜欢的目录解压缩：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo tar -zxvf zookeeper-3.4.7.tar.gz&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;配置信息在&lt;strong&gt;conf/zoo.cfg&lt;/strong&gt;中（可以在zoo_sample.cfg中看到），常用的几个设置项如下（更多看&lt;a href=&quot;http://www.cnblogs.com/ggjucheng/p/3352591.html&quot;&gt;这里&lt;/a&gt;）：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;配置&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;tickTime&lt;/td&gt;
      &lt;td&gt;客户端和服务器之间的心跳间隔（毫秒）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;initLimit&lt;/td&gt;
      &lt;td&gt;FOLLOWER与LEADER初始连接的最大延迟心跳数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;syncLimit&lt;/td&gt;
      &lt;td&gt;FOLLOWER与LEADER请求应答的最大延迟心跳数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dataDir&lt;/td&gt;
      &lt;td&gt;数据文件目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;dataLogDir&lt;/td&gt;
      &lt;td&gt;日志文件目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clientPort&lt;/td&gt;
      &lt;td&gt;客户端连接端口&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;配置安成以后使用命令启动（standalone模式）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;./bin/zkServer.sh start&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看zookeeper的状态（看看起来没）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;./bin/zkServer.sh start&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然也可以用客户端试一下能不能连上：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;./bin/zkCli.sh 或者 ./bin/zkCli.sh -server 127.0.0.1:2181&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在还是单个节点，离集群还差很多，怎么办？暂时没有很多机器，在单机上搞“伪集群”应该还是简单的，这样和真正的集群差的不是太多了。刚开始看&lt;a href=&quot;http://blog.csdn.net/tanyujing/article/details/8504481&quot;&gt;这里的方法&lt;/a&gt;感觉没啥问题，但是有点烦，于是看下./bin/zkServer.sh的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
if [ &quot;x$2&quot; != &quot;x&quot; ]
then
    ZOOCFG=&quot;$ZOOCFGDIR/$2&quot;
fi
&lt;/pre&gt;

&lt;p&gt;发现果然是可以指定配置文件的，于是创建文件&lt;strong&gt;./conf/zoo_1.cfg&lt;/strong&gt;，内容如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/tmp/zookeeper/1 # 新建个目录
clientPort=3181 # 注意端口不要冲突
server.0=127.0.0.1:2008:6008
server.1=127.0.0.1:2007:6007
&lt;/pre&gt;

&lt;p&gt;当然需要对原来的&lt;strong&gt;./conf/zoo.cfg&lt;/strong&gt;做一点小修改：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/tmp/zookeeper/0 # 新建个目录
clientPort=2181 # 注意端口不要冲突
server.0=127.0.0.1:2008:6008
server.1=127.0.0.1:2007:6007
&lt;/pre&gt;

&lt;p&gt;后面放的是ZK的服务器列表（每个节点上的列表都是一样的），格式如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;server.[myId]=[IP地址][通信端口][选举端口]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外需要写入myid：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
echo &#39;0&#39; &amp;gt; /tmp/zookeeper/0/myid
echo &#39;1&#39; &amp;gt; /tmp/zookeeper/1/myid
&lt;/pre&gt;

&lt;p&gt;现在可以启动了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
./bin/zkServer.sh start ./conf/zoo.cfg
./bin/zkServer.sh start ./conf/zoo_1.cfg
&lt;/pre&gt;

&lt;p&gt;再用命令查看状态显示&lt;strong&gt;Mode: follower&lt;/strong&gt;，启动成功（STOP的时候也需要指定配置文件）。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;实现原理&lt;/h2&gt;

&lt;p&gt;在分布式的环境中保证数据的一致是比较困难的，比如用主备方式（两个都是中心）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主机挂了备如何自动起来？备也挂了怎么办？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面来看ZK如何做到&lt;strong&gt;去中心化&lt;/strong&gt;的，在集群中有下面几种角色：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;角色&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;LEADER&lt;/td&gt;
      &lt;td&gt;数据同步、发起选举&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FOLLOWER&lt;/td&gt;
      &lt;td&gt;响应客户端请求，并在选举的过程中投票&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OBSERVER&lt;/td&gt;
      &lt;td&gt;响应客户端请求，不参与投票（不影响写性能、提高读性能）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CLIENT&lt;/td&gt;
      &lt;td&gt;发送请求&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在他们之间流转的消息有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;消息&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;PING&lt;/td&gt;
      &lt;td&gt;心跳&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REQUEST&lt;/td&gt;
      &lt;td&gt;FOLLOWER发出的提议（写请求、同步请求）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PROPOSAL&lt;/td&gt;
      &lt;td&gt;LEADER发起的提案，要求FOLLOWER投票&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ACK&lt;/td&gt;
      &lt;td&gt;FOLLOWER对提案的回复（超过半数就算通过）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REVALIDATE&lt;/td&gt;
      &lt;td&gt;用来延长SESSION有效时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;COMMIT&lt;/td&gt;
      &lt;td&gt;服务端最新一次提案的信息，FOLLOWER收到后更新本地数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UPTODATE&lt;/td&gt;
      &lt;td&gt;同步完成&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;总体上是通过选举机制来保证集群中LEADER的唯一性（就算集群被分成两半），然后用LEADER来保证数据的一致性。时刻记着&lt;strong&gt;过半就安全&lt;/strong&gt;会比较好理解一些，下面来看一些主要流程。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;一、写入&lt;/h3&gt;

&lt;p&gt;客户端连的可能是FOLLOWER，也可能是LEADER，写操作引发的消息如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ZOOKEEPER-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所有的都会交给LEADER来顺序处理，因此就没有“同时”写入这么一说了。我们知道ZK一个典型的使用场景&lt;strong&gt;分布式锁&lt;/strong&gt;，那么：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;是否所有的分布式锁都适合用ZK来实现？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;每个写入都需要投票，只有收到过半的同意才算完，当ZK集群数量较多时IO的压力还是比较大的，那么如果我想在每个写操作上加锁（防止多台机器并发），而且TPS峰值会比较高，用ZK来实现是不怎么合适的。&lt;/p&gt;

&lt;p&gt;另外，如果太高的TPS峰值把ZK给压挂了，重新进行选举，那选举的过程中你也是加不了锁的:D。接着看，ZK保证高可用是因为必然会有FOLLOWER保存了数据，那么：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;FOLLOWER中的数据是什么时候写进去的？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当FOLLOWER收到PROPOSAL消息后会将其写入日志文件并发送ACK消息，ZK相关的文件包括（格式参考&lt;a href=&quot;http://blog.csdn.net/pwlazy/article/details/8080626&quot;&gt;这里&lt;/a&gt;）：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;文件&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SNAPSHOT&lt;/td&gt;
      &lt;td&gt;内存数据的快照（FUZZY），当日志写到一定数量开始用异步线程执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LOG&lt;/td&gt;
      &lt;td&gt;日志文件，类似MYSQL的BINLOG，记录每次写操作&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在恢复数据的时候需要配合使用这两个文件！在LEADER发出提案以后可能面临的情况有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;收集到过半的ACK：LEADER更新自己的数据以后发送COMMIT和INFORM来更新其他服务器的消息；&lt;/li&gt;
  &lt;li&gt;没有收集到过半的ACK：一直等，等到成功或者新一轮的投票选举；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;处理流程可以在&lt;a href=&quot;http://blog.csdn.net/dengsilinming/article/details/18224925&quot;&gt;这里&lt;/a&gt;看到（真正想完全了解还是得读源码）。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;二、投票&lt;/h3&gt;

&lt;p&gt;当PING的时候发现FOLLOWER的“存活数”没有过半（或者其他异常）时，那么此时需要进行新的一轮选举，那么问题来了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;既然存活的FOLLOWER都没过半，再选也解决不了问题啊？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这就不对了，比如LEADER所在机房的网线被挖断了而已，其他机器互相之间连得好好的，那么此时仍然是可能选出一个新LEADER的。选举过程中节点有四种状态：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;状态&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;LOOKING&lt;/td&gt;
      &lt;td&gt;启动时，还没有找到LEADER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FOLLOWING&lt;/td&gt;
      &lt;td&gt;参与投票，但没有成为LEADER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LEADING&lt;/td&gt;
      &lt;td&gt;参与投票，并且成为了LEADER&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OBSERVING&lt;/td&gt;
      &lt;td&gt;不参与投票&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;刚开始大家都处于LOOKING状态，通过互相之间发送消息来决定谁是LEADER，默认的&lt;strong&gt;FastLeader&lt;/strong&gt;算法从单个机器的角度来看运行流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ZOOKEEPER-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本地记录中保存了所有机器的投票，比如刚开始都投选自己，那么内容就是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ZOOKEEPER-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;收到别人的投票信息后，与自己的投票对象对比，如果别人的更优，那么自己重新投票并广播。经过几轮通信优秀的人获得的投票数会过半，此时LEADER就选出来了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ZOOKEEPER-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;详细过程可以看这几篇文章（&lt;a href=&quot;http://www.open-open.com/lib/view/open1413796647528.html&quot;&gt;1&lt;/a&gt;、&lt;a href=&quot;http://blog.csdn.net/xhh198781/article/details/6619203&quot;&gt;2&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/yuyijq/p/4116365.html&quot;&gt;3&lt;/a&gt;）如果仅仅是从ID来判断谁优谁劣，那么C、D、E都有可能成为LEADER，那么：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有这么多可能性，ZK重启后集群上的最新数据能保证和之前是一样的吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从上面写入的过程发现：如果写入成功必然是有过半的机器保存来数据，而选举的时候同样需要过半达成一致，那么：&lt;strong&gt;过半与过半之间必然有重叠的部分&lt;/strong&gt;。而在选举过程中根据数据新旧决定是否更优，那么有最新数据的机器必然会被选举出来。感觉&lt;strong&gt;Paxos&lt;/strong&gt;算法要稍复杂一些：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ZOOKEEPER-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个执行流程分成两个阶段：&lt;strong&gt;准备&lt;/strong&gt;（绿色）和&lt;strong&gt;批准&lt;/strong&gt;（黄色），详细的内容可以在&lt;a href=&quot;http://blog.sina.com.cn/s/blog_3dbab28401014lt4.html&quot;&gt;这里&lt;/a&gt;看到，不过&lt;a href=&quot;http://www.open-open.com/lib/view/open1420635646984.html&quot;&gt;这里&lt;/a&gt;的最后一张图还是给力啊（推荐）！通过这么纠结的过程做到了两个限制：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;P2c&lt;/strong&gt;：如果一个编号为N的提案具有VALUE V，那么存在一个多数派：要么他们中所有人都没有接受编号小于N的任何提案，要么他们已经接受的所有编号小于N的提案中编号最大的那个提案具有VALUE V；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;P1a&lt;/strong&gt;：当且仅当ACCEPTOR没有回应过编号大于N的PREPARE请求时，ACCEPTOR接受编号为N的提案；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了这些限制集群就不会通过两个不一样的结果（不管消息的顺序是怎么样的）。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;看下来在ZK上保存一些配置的信息很靠谱，那么接下来来看如何在JAVA中对其进行操作，首先要连接到服务器（本地启动的ZK）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ZooKeeper zooKeeper = new ZooKeeper(&quot;127.0.0.1:3181&quot;, 3000, new Watcher() {
    public void process(WatchedEvent watchedEvent) {
        // 处理事件
    }
});
// TODO 在这里写你要作的操作
zooKeeper.close();
&lt;/pre&gt;

&lt;p&gt;连接到服务器之后就可以开始操作，在ZK中的数据用树形结构进行保存：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;做工具或者平台的时候，用这种方式来存储基本上能满足所有的组织数据的需求。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单的用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 创建节点
zooKeeper.create(&quot;/root&quot;, &quot;root&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
// 获取节点数据
System.out.println(new String(zooKeeper.getData(&quot;/root&quot;, false, null)));
// 创建子节点
zooKeeper.create(&quot;/root/child_1&quot;, &quot;child_1&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
// 获取子节点
System.out.println(zooKeeper.getChildren(&quot;/root&quot;, true));
// 修改节点数据
zooKeeper.setData(&quot;/root/child_1&quot;, &quot;child_1&quot;.getBytes(), -1);
// 删除节点
zooKeeper.delete(&quot;/root/child_1&quot;, -1);
zooKeeper.delete(&quot;/root&quot;, -1);
&lt;/pre&gt;

&lt;p&gt;对复杂的操作以及在用的过程中可能会遇到的问题后面再写文章详细写。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;分布式环境下的网络等问题处理起来非常复杂，数据的一致性非常头疼，有了ZK之后又可以愉快地玩耍了:)&lt;/p&gt;
</description>
        <pubDate>Tue, 22 Dec 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/22/ZOOKEEPER-BASIC.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/22/ZOOKEEPER-BASIC.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>从下向上来开发</title>
        <description>&lt;p&gt;因为在公司接触业务比较少，更多的是在想办法做一些工具来帮助快速开发，过程中感觉做业务的思路与做工具（系统）的思路差别比较大。下面分享一下在两个模块中的思考过程。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;获取数据&lt;/h2&gt;

&lt;p&gt;团队做的业务复杂无比，几百张的数据表导致有非常非常多的报表，通常的做法是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;iBatis(SQL)&lt;/li&gt;
  &lt;li&gt;DAO+DO&lt;/li&gt;
  &lt;li&gt;Manager&lt;/li&gt;
  &lt;li&gt;Web+VO&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;几十张报表开发起来非常痛苦，而且大部分的代码实现的功能都是&lt;strong&gt;相似&lt;/strong&gt;的！说到相似，那么是不是把不同的部分（取数逻辑）独立出来，相同部分进行复用即可：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置一个数据接口只需要填写一段SQL就可以了！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的操作（数据库、返回数据）不需要你再关心了。YY了一下大部分的需求用SQL绝对绰绰有余，这件事情就这样结束了！&lt;strong&gt;图样图森破啊&lt;/strong&gt;！！马上遇到了这样的需求：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
{
    title : &quot;xxx&quot;,
    data : [1, 2, 3, 4, 5, 6, 7, 8]
}
&lt;/pre&gt;

&lt;p&gt;还有这样（一些常量）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
[
    {text : &#39;A&#39;, value : 1},
    {text : &#39;B&#39;, value : 2}
]
&lt;/pre&gt;

&lt;p&gt;于是火速开发了更多的功能组件来解决问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MYSQL&lt;/li&gt;
  &lt;li&gt;MYSQL-XXX&lt;/li&gt;
  &lt;li&gt;JSON&lt;/li&gt;
  &lt;li&gt;VELOCITY&lt;/li&gt;
  &lt;li&gt;XXXX&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组件越来越多，“新手”进来已经不是特别了解每个的具体含义，配置的成本也越来越大。感觉系统用起来并不想当初想的那么美好！&lt;/p&gt;

&lt;p&gt;停下来想一下，从一开始的目标：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我要一个可以干啥干啥的功能！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在实现起来没有任何的拐弯抹角，一步到位完成之后没有考虑过：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;系统有多少的灵活性、可以从哪些方面扩展？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仔细想了一想，我们对系统进行了简单的改造：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;利用GROOVY脚本极大的灵活性，让系统的适应能力也有所提高！虽然花了很多业务时间来研究ACE的功能来提高编辑体验，但是还是有非常多的同一种吐槽：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写脚本的学习成本太高！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更郁闷的是来吐槽的都是“资深”JAVA开发工程师（GROOVY和JAVA不是很像么）！在现在的系统上面只需要实现一个方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static Ojbect execute(){
    return [1, 2, 3];
}
&lt;/pre&gt;

&lt;p&gt;即可通过RPC或者HTTP获取数据（在底层已经将参数传递等东西都封装完成），作为一个程序猿对这样写一小段脚本就能实现的方式挺亲切的，不明白为啥其他的同是开发对这种方式极其的排斥，以至于我几乎没有机会去讲我夹下来要做的事情。&lt;/p&gt;

&lt;p&gt;接下来要做什么呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;脚本再简单也只能开发来写，那像原来只会SQL的人就用不来这个系统了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;显然不能让这种情况发生，解决办法也非常简单：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写一个通用解决问题的脚本&lt;/li&gt;
  &lt;li&gt;在执行时，将SQL、数据源信息通过参数传给对应的通用脚本执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如一个查询数据库的脚本如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static Object execute(sql, datasource){
    // 1. 根据datasource获取数据源
    // 2. 指定sql
    // 3. 返回执行结果
}
&lt;/pre&gt;

&lt;p&gt;而此时用户看到的配置页面就小白很多了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;保存时会将其填写的信息以及要使用的目标脚本一起保存下来，执行时将参数传给指定的脚本执行即可（是不是有点像带参数的ln）。&lt;/p&gt;

&lt;p&gt;将该功能开放给各个业务系统，那么就可以自己去做各自需要的小白配置页面了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组装页面&lt;/h2&gt;

&lt;p&gt;缺前端是个普遍的问题，如果能将前端的开发简化到后端也能参与，也许能在一定程度上得到解决。&lt;/p&gt;

&lt;p&gt;首先，把页面上的各个部分抽象成组件：&lt;strong&gt;组件=数据+动作+展示&lt;/strong&gt;。比如带下拉列表的选择输入框：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据：列表中的内容以及当前展示的内容&lt;/li&gt;
  &lt;li&gt;动作：内容发生改变&lt;/li&gt;
  &lt;li&gt;展示：可以用bootstrap等前段框架实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在使用的时候就非常简单了（一行代码相当于原来20行左右的HTML+JS）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@input(label=&quot;仓库&quot; name=&quot;warehouse&quot; items=[{text:&quot;A&quot;, value:&quot;1&quot;},{text:&quot;B&quot;, value:&quot;2&quot;}])
&lt;/pre&gt;

&lt;p&gt;直观上干了两件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用组件输入框（input）&lt;/li&gt;
  &lt;li&gt;设置一些属性（label、name、items）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那展示呢？这个显然不应该交给用户来操心，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要引入哪些CSS、JS？&lt;/li&gt;
  &lt;li&gt;对应的DOM结构应该是什么样的？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了达到这种效果，一个组件的定义可以是这样的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@import(
    &#39;bootstrap.css&#39; // 依赖的CSS文件（需要的时候也可以加JS）
)
@component
    this.width = &#39;10px&#39;; // 一些默认的数据

    @render  // 在render下定义渲染（有点像JSX吧）
    &amp;lt;ul&amp;gt;
        for(i in items){
            &amp;lt;li&amp;gt;${items[i]}&amp;lt;/li&amp;gt;
        }
    &amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在做的过程中发现一些好玩的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JS的资源不一定适合SEAJS来加载，因为JS之间可能有依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;渲染DOM的部分类似JSX，但更暴力：&lt;strong&gt;支持JavaScript的各种控制结构&lt;/strong&gt;，但这一点是有代价的。仔细想一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript和HTML的语法之间天然就是彼此隔离的，除了‘&amp;lt;’之外。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那做到上面这种模板语法也就比较简单自然了。到这里组件就变为一个&lt;strong&gt;方便定制&lt;/strong&gt;、&lt;strong&gt;高度聚合&lt;/strong&gt;的东西了！但是光聚合没用啊，需要把他们拼装成一个页面，需要解决：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;布局（把组件拼装成一个完整的区块甚至页面）&lt;/li&gt;
  &lt;li&gt;数据交互（组件之间建立关联）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单想了一种方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;利用&lt;strong&gt;缩进&lt;/strong&gt;来控制层次关系&lt;/li&gt;
  &lt;li&gt;利用&lt;strong&gt;@on&lt;/strong&gt;来进行组件关联&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@layout// 布局
    @input(name=&quot;a&quot;)
    @input(name=&quot;b&quot;)
    @input(name=&quot;c&quot;)
    @button(label=&#39;查询&#39;)// 查询
        @on(click)
            // 1. 获取a、b、c的数据
            // 2. 请求数据
            // 3. 更新table、page的展示
@layout
    @table // 表格
    @page// 分页
&lt;/pre&gt;

&lt;p&gt;当点击查询按钮时，根据三个输入框（a、b、c）的内容查询数据并更新表格的展示。最后我们需要将该页面放到业务系统中，做法也非常的‘土’：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;script&amp;gt;
engine.init(&quot;page&quot;, document.body);// 将page对应的页面渲染到body下面。
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;渲染的位置你可以随意指定。到这里用法就说完了，下面来看如何实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;模块很简单，我用SEAJS的方法，但是作了一些简化和定制。组件的操作包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用组件（添加到父组件的children列表中）&lt;/li&gt;
  &lt;li&gt;设置属性&lt;/li&gt;
  &lt;li&gt;绑定事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTML的操作包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建标签&lt;/li&gt;
  &lt;li&gt;设置属性&lt;/li&gt;
  &lt;li&gt;绑定事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;既然想为以后留好扩展性，那么JavaScript作为中间层应该是一个不错的选择，将对应的HTML操作可以翻译成下面几个方法（组件的也类似）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;create   // 创建HTML标签&lt;/li&gt;
  &lt;li&gt;attr     // 设置属性&lt;/li&gt;
  &lt;li&gt;listen   // 绑定事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了处理层次还需要&lt;strong&gt;push&lt;/strong&gt;、&lt;strong&gt;pop&lt;/strong&gt;方法。为了实现这些我们需要一个翻译器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将生成的JS文件保存到CDN上面，再结合HTTP缓存，性能应该还是可以的！我们继续，在此基础上可以扩展出更多的玩法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在是将结果渲染到某个DOM节点下面，那是否可以直接在Velocity中使用某个组件，像这样:&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;div&amp;gt;
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;上面是对后端Javaer敞开大门，那前端工程师是否可以得到好处，像这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;script type=&quot;text/engine&quot;&amp;gt;
@input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;因为每一步前后都没有耦合，你完全可以去扩展自己想要的东西。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;远古时期的程序员在实现业务时可能把：取数据、业务逻辑、渲染都放在一个代码中完成，后来逐渐分成几层来做：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Model&lt;/li&gt;
  &lt;li&gt;View&lt;/li&gt;
  &lt;li&gt;Controller&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不仅结构更清晰，而且在任何一层你都可以选择不同的方案来实现。我们在做工具时也可以参考这种思路，多分几步来做。&lt;/p&gt;

&lt;p&gt;那什么是从下到上呢？和上面的分层的角度不一样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;越下越灵活，但门槛越高&lt;/li&gt;
  &lt;li&gt;越上越好用，但扩展起来不是很容易&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在对一些场景实现工具，根据灵活度和易用性来分成几步来做，这样不同的技术背景的人都可以使用，而且最关键的是可以扩展出更多的使用场景！:-)&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/17/DOWN-TO-UP.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/17/DOWN-TO-UP.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>从下向上来开发(PPT)</title>
        <description>&lt;!-- test --&gt;

&lt;!-- test end--&gt;

&lt;!-- (0) --&gt;
&lt;section&gt;&lt;h1&gt;EASY-DT&lt;/h1&gt;&lt;/section&gt;
&lt;!-- (1) --&gt;
&lt;section&gt;&lt;h3&gt;获取数据&lt;/h3&gt;&lt;/section&gt;
&lt;!-- (2) --&gt;
&lt;section&gt;
&lt;!-- (2 类型比较多) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
![需要选择很多类型](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-SLIDES-1.png)

提前做好一些读取数据和加工数据的组件
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2 不知道每种类型应该怎么用) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
![每种类型都有自己的学习成本](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-SLIDES-2.png)

用XML格式的配置文件来描述逻辑
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2 结果数据比较灵活，可能遇到的时候就需要写代码或者增加新的组件) --&gt;
&lt;section&gt;
&lt;pre&gt;&lt;code&gt;
[
    {
        &quot;name&quot;: &quot;拣选&quot;,
        &quot;list&quot;: [
            0, 0, 0, 0, 0, 0, 0, 0, 256, 6049, 5684, 3008
        ],
        &quot;latest_count&quot;: 4862
    },
    {}
]
&lt;/code&gt;&lt;/pre&gt;

格式常常无法预料：&lt;span style=&quot;color:red;&quot;&gt;加组件&lt;/span&gt; or &lt;span style=&quot;color:red;&quot;&gt;不支持&lt;/span&gt;
&lt;/section&gt;
&lt;!-- (2 分析问题到底出在哪里) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 分析问题

&lt;br/&gt;

- 组件生成的数据结构固定，无法灵活适应业务
- 很难组合使用多个组件
- 扩展较复杂
- 上手、维护成本高
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2 最底层用GROOVY来写的好处) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 解决方法（GROOVY）

&lt;br/&gt;

- 查看、编辑、保存、调试、高亮、自动补全等
- 提交、发布
- 权限、开关、限流（在树形结构上统一做掉）
- 日常同步到线上
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2 脚本编辑页面) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
![脚本编辑页面](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-SLIDES-3.png)

代码编辑（ACE）
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2 小白用户更愿意看到的配置页面) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
![小白用户想看到的配置方式](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-SLIDES-4.png)

小白用户想看到的配置方式
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2 实现小白配置页面的方法) --&gt;
&lt;section&gt;
&lt;pre&gt;&lt;code&gt;
static Object execute(){
    def template_context = get(&quot;template_context&quot;);
    def sql = template_context.get(&quot;sql&quot;);
    def datasource = template_context.get(&quot;datasource&quot;);
    // 
}
static void mock(){
    // 
}
&lt;/code&gt;&lt;/pre&gt;

可能的一种实现方式
&lt;/section&gt;
&lt;!-- (2 提供给业务应用使用) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 业务系统中使用

&lt;br/&gt;

- &lt;span style=&quot;color:lightgray&quot;&gt;your-domain&lt;/span&gt;&lt;span style=&quot;color:yellow;&quot;&gt;/easydt&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;/wms/owner&lt;/span&gt;&lt;span style=&quot;color:lightgray&quot;&gt;.do&lt;/span&gt;
- &lt;span style=&quot;color:lightgray&quot;&gt;Easydt.getResult(&quot;&lt;/span&gt;&lt;span style=&quot;color:red;&quot;&gt;/wms/owner&lt;/span&gt;&lt;span style=&quot;color:lightgray&quot;&gt;&quot;, param);&lt;/span&gt;
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2 整体架构) --&gt;
&lt;section&gt;
&lt;pre style=&quot;text-align:center;width:120%;height:120%;box-shadow:none;&quot;&gt;
       1.通过HSF接口获取数据                         1、参数传递                      
                                                     2、统一的编译、发布功能          
 +-----------+         +-----------+                 3、统一的高亮、提示、自动补全功能
 |    APP    |---------|   EASYDT  |                                                  
 +-----------+         +-----+-----+                                                  
                             |                                                        
                       +-----+-----+                                                  
                       |   CLASS   |                                                  
                       +-----+-----+                                                  
                             |                                                        
                       +-----+-----+        +-----------+                             
                       |  OSS/LDB  |--------|    APP    |                             
                       +-----------+        +-----------+                             
                                                                                      
                              2.拿到CLASS在业务应用中执行                             
&lt;/pre&gt;
&lt;/section&gt;
&lt;!--(2 结束)--&gt;
&lt;/section&gt;
&lt;!--(3)--&gt;
&lt;section&gt;&lt;h3&gt;展示数据&lt;/h3&gt;&lt;/section&gt;
&lt;!--(4)--&gt;
&lt;section&gt;
&lt;!--(4 好的展示并不简单)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
![](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-SLIDES-5.png)

更清晰的展示数据
&lt;/script&gt;&lt;/section&gt;
&lt;!--(4 老的开发模式的问题)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 分析问题

&lt;br/&gt;

- 没有足够的前端资源来针对每个页面优化
- 报表页面部分重复、部分个性
- 逻辑无法预测
&lt;/script&gt;&lt;/section&gt;

&lt;!--(4 解决问题的方式)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 解决问题

&lt;br/&gt;

- 将能复用的抽出来生成组件
- 用DSL来描述页面，无须拖拽也有比较好的体验
- 在组件中封装对JS、CSS的依赖
- 组件最终生成JS代码，保证可扩展性
&lt;/script&gt;&lt;/section&gt;

&lt;!--(4 组件的使用方式)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 使用组件

&lt;br/&gt;

&lt;span style=&quot;color:red;&quot;&gt;@input&lt;/span&gt;(&lt;span style=&quot;color:green;&quot;&gt;label&lt;/span&gt;=&quot;仓库&quot; &lt;span style=&quot;color:green;&quot;&gt;name&lt;/span&gt;=&quot;warehouse&quot;)

&lt;br/&gt;

&lt;span style=&quot;color:red;&quot; class=&quot;fragment&quot;&gt;@warehouse&lt;/span&gt;
&lt;/script&gt;&lt;/section&gt;

&lt;!--(4 组件之间的关联关系的实现)--&gt;
&lt;section&gt;
&lt;h3&gt;组件关联&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
@input(name=&quot;warehouse&quot;)
@input(name=&quot;owner&quot;)
    @on(target=&quot;warehouse&quot; type=&quot;change&quot;)
        // 1. 请求接口获取数据
        // 2. 更新组件自生的数据
        // 3. 刷新展示
&lt;/code&gt;&lt;/pre&gt;

&lt;br /&gt;

仓库发生变化时更新货主列表
&lt;/section&gt;

&lt;!--(4 定义组件的方式)--&gt;
&lt;section&gt;
&lt;h3&gt;定义组件&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
@import(
    &#39;bootstrap.css&#39; // 依赖的CSS文件（需要的时候也可以加JS）
)
@component
    this.width = &#39;10px&#39;; // 一些默认的数据

    @render  // 在render下定义渲染（有点像JSX吧）
        &lt;ul&gt;
            for(i in items){
                &lt;li&gt;${items[i]}&lt;/li&gt;
            }
        &lt;/ul&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;br /&gt;

最终会生成&lt;span style=&quot;color:red;&quot;&gt;@init&lt;/span&gt;和&lt;span style=&quot;color:red;&quot;&gt;@render&lt;/span&gt;方法
&lt;/section&gt;

&lt;!-- (4 DPL中的一个例子) --&gt;
&lt;section&gt;
&lt;h3&gt;生成代码&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
	create(&quot;div&quot;);
	attr(&quot;class&quot;,&quot;control-group span8&quot;);
	push();
	create(&quot;label&quot;);
	attr(&quot;class&quot;,&quot;control-label&quot;);
	push();
	create(null, (&quot;供应商编码：&quot;));
	pop();
	create(&quot;div&quot;);
	attr(&quot;id&quot;,&quot;s1&quot;+this.name);
	attr(&quot;class&quot;,&quot;controls&quot;);
	push();
	pop();
	pop();
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;!--(4 如果没有在平台上使用而是单独在JS中使用的方式)--&gt;
&lt;section&gt;
&lt;h3&gt;前端&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
&lt;script type=&quot;text/engine&quot;&gt;
@layout
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
@layout
    @table
    @page
&lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;

&lt;!--(4 没有在平台上使用，而是单独在后端VM文件中使用的方式)--&gt;
&lt;section&gt;
&lt;h3&gt;后端&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
&lt;form&gt;
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;) // 使用组件
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;) // 使用组件
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;) // 使用组件
    &lt;table&gt;&lt;/table&gt;
&lt;/form&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!-- (4 结束)--&gt;
&lt;/section&gt;
&lt;!--(5)--&gt;
&lt;section&gt;&lt;h3&gt;加工数据&lt;/h3&gt;&lt;/section&gt;
&lt;!--(6)--&gt;
&lt;section&gt;

&lt;!--(6 常规的思路)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 常用方法

&lt;br/&gt;

- 离线分析：odps
- 在线分析：garuda(ads)、...
- 流计算：galaxy、tlog、jstorm、...

&lt;br/&gt;

&lt;span style=&quot;color:red;&quot; class=&quot;fragment&quot;&gt;越实时越好，几乎不能有误差&lt;/span&gt;
&lt;/script&gt;&lt;/section&gt;

&lt;!--(6 实时选择中的纠结)--&gt;
&lt;section&gt;
&lt;span style=&quot;color:red;font-size:2em;&quot;&gt;olap&amp;nbsp;&lt;/span&gt;vs&lt;span style=&quot;color:red;font-size:2em;&quot;&gt;&amp;nbsp;stream&lt;/span&gt;
&lt;/section&gt;

&lt;!--(6 可能导致错误的原因)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 误差原因

&lt;br/&gt;

- 并发
- 重复（为了做到消息丢失，重复几乎是不可避免的）
- 乱序
&lt;/script&gt;&lt;/section&gt;

&lt;!--(6 解决办法)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 解决办法

&lt;br/&gt;

- 锁
 - 分布式锁（等待or快速失败）
 - 主键
- 消息分发（让处理变得有序）来消除竞争
 - metaq
 - jstorm
&lt;/script&gt;&lt;/section&gt;

&lt;!--(6 把通用的解决方式套到JSTORM上面)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
![](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-SLIDES-6.png)

尝试将通用的解决方法套在JSTORM上:)
&lt;/script&gt;&lt;/section&gt;

&lt;!--(6 仅仅是数据加工？)--&gt;
&lt;section&gt;
&lt;span style=&quot;color:lightgray;&quot;&gt;Jstorm仅仅只能用来做数据加工？&lt;/span&gt;
&lt;/section&gt;
&lt;!-- (6 结束) --&gt;
&lt;/section&gt;

&lt;!-- (7) --&gt;
&lt;section&gt;
&lt;span style=&quot;font-size:2em;color:lightgray;&quot;&gt;Thank You&lt;/span&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate>
        <link>/ppt/2015/12/17/DOWN-TO-UP-SLIDES.html</link>
        <guid isPermaLink="true">/ppt/2015/12/17/DOWN-TO-UP-SLIDES.html</guid>
        
        
        <category>PPT</category>
        
      </item>
    
      <item>
        <title>用ACE来写代码（二）</title>
        <description>&lt;p&gt;仅仅把代码高亮了还不够，在正常的编辑器中当输入少量的几个字符串就可以根据它来提示可能的输入：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-4.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样用起来能极大地提高输入的效率，而实现起来非常简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ace.require(&quot;ace/ext/language_tools&quot;);
var editor = ace.edit(&quot;editor&quot;);
editor.session.setMode(&quot;ace/mode/groovy&quot;);
editor.setTheme(&quot;ace/theme/tomorrow&quot;);
editor.setOptions({
    enableBasicAutocompletion: true,
    enableSnippets: true,
    enableLiveAutocompletion: true
});
&lt;/pre&gt;

&lt;p&gt;另外注意需要引入&lt;strong&gt;ext-language_tools.js&lt;/strong&gt;文件！感觉看英文的文档有些地方不是很清楚（可能是英语水平的问题☺），于是我们继续开始读源码。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;源码分析&lt;/h2&gt;

&lt;p&gt;我们设置了&lt;strong&gt;enableLiveAutocompletion&lt;/strong&gt;后输入内容时会执行&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/ext/language_tools.js#L156&quot;&gt;doLiveAutocomplete&lt;/a&gt;方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var doLiveAutocomplete = function(e) {
    var editor = e.editor;
    var hasCompleter = editor.completer &amp;amp;&amp;amp; editor.completer.activated;
    if (e.command.name === &quot;backspace&quot;) {// 删除动作
        if (hasCompleter &amp;amp;&amp;amp; !getCompletionPrefix(editor))
            editor.completer.detach();
    } else if (e.command.name === &quot;insertstring&quot;) {// 输入动作
        var prefix = getCompletionPrefix(editor);
        if (prefix &amp;amp;&amp;amp; !hasCompleter) {
            if (!editor.completer) {
                editor.completer = new Autocomplete();
            }
            editor.completer.autoInsert = false;
            editor.completer.showPopup(editor);// 入口方法
        }
    }
};
&lt;/pre&gt;

&lt;p&gt;对操作的类型及内容做一些简单的过滤之后就交由&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js&quot;&gt;Autocomplete&lt;/a&gt;来完成实质性的工作：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.showPopup = function(editor) {
    // 初始化
    if (this.editor)
        this.detach();
    this.activated = true;
    this.editor = editor;
    if (editor.completer != this) {
        if (editor.completer)
            editor.completer.detach();
        editor.completer = this;
    }
    // 绑定方法
    editor.on(&quot;changeSelection&quot;, this.changeListener);
    editor.on(&quot;blur&quot;, this.blurListener);
    editor.on(&quot;mousedown&quot;, this.mousedownListener);
    editor.on(&quot;mousewheel&quot;, this.mousewheelListener);
    // 更新补全信息列表
    this.updateCompletions();
};
&lt;/pre&gt;

&lt;p&gt;方法&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L253&quot;&gt;showPopup&lt;/a&gt;中先进行初始化：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用detach进行清理；&lt;/li&gt;
  &lt;li&gt;绑定事件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来就使用&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L274&quot;&gt;updateCompletions&lt;/a&gt;来获取补全列表信息并进行展示：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.updateCompletions = function(keepPopupPosition) {
    if (keepPopupPosition &amp;amp;&amp;amp; this.base &amp;amp;&amp;amp; this.completions) {
        var pos = this.editor.getCursorPosition();
        var prefix = this.editor.session.getTextRange({start: this.base, end: pos});
        // 内容没有发生变化
        if (prefix == this.completions.filterText)
            return;
        this.completions.setFilter(prefix);
        if (!this.completions.filtered.length)
            return this.detach();
        if (this.completions.filtered.length == 1
            &amp;amp;&amp;amp; this.completions.filtered[0].value == prefix
            &amp;amp;&amp;amp; !this.completions.filtered[0].snippet)
            return this.detach();
        this.openPopup(this.editor, prefix, keepPopupPosition);
        return;
    }
    var _id = this.gatherCompletionsId;
    // 收集所有的补全信息并执行（全部用回调函数来搞看着好累- -!）
    this.gatherCompletions(this.editor, function(err, results) {
        var detachIfFinished = function() {
            if (!results.finished) return;
            return this.detach();
        }.bind(this);
        // 获取前缀
        var prefix = results.prefix;
        var matches = results &amp;amp;&amp;amp; results.matches;
        // 没有匹配到的时候就可以清理一下然后返回了
        if (!matches || !matches.length)
            return detachIfFinished();
        if (prefix.indexOf(results.prefix) !== 0 || _id != this.gatherCompletionsId)
            return;
        this.completions = new FilteredList(matches);
        // 是否精确匹配
        if (this.exactMatch)
            this.completions.exactMatch = true;
        // 过滤，过滤完的结果保存在filtered中
        this.completions.setFilter(prefix);
        var filtered = this.completions.filtered;
        // 检查过滤完的结果，没有匹配到的就清理并返回
        if (!filtered.length)
            return detachIfFinished();
        if (filtered.length == 1 &amp;amp;&amp;amp; filtered[0].value == prefix &amp;amp;&amp;amp; !filtered[0].snippet)
            return detachIfFinished();
        if (this.autoInsert &amp;amp;&amp;amp; filtered.length == 1 &amp;amp;&amp;amp; results.finished)
            return this.insertMatch(filtered[0]);
        // 展示内容
        this.openPopup(this.editor, prefix, keepPopupPosition);
    }.bind(this));
};
&lt;/pre&gt;

&lt;p&gt;其中参数&lt;strong&gt;keepPopupPosition&lt;/strong&gt;表示是否保持弹出框的位置保持不变：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;补全框中的内容会随着你的输入变化而变化，但是位置却保持不变就是这个参数在起作用！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中比较关键的用&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L224&quot;&gt;gatherCompletions&lt;/a&gt;来收集所有补全器提供的数据（感觉是用这个方法把language_tools.js和autocomplete.js打通）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.gatherCompletions = function(editor, callback) {
    var session = editor.getSession();
    var pos = editor.getCursorPosition();
    var line = session.getLine(pos.row);
    var prefix = util.retrievePrecedingIdentifier(line, pos.column);
    this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
    this.base.$insertRight = true;
    var matches = [];
    var total = editor.completers.length;
    // 遍历执行每个补全器
    editor.completers.forEach(function(completer, i) {
        // 获取补全列表
        completer.getCompletions(editor, session, pos, prefix, function(err, results) {
            // 在没有发生错误的时候，将结果合并到matchs中
            if (!err)
                matches = matches.concat(results);
            var pos = editor.getCursorPosition();
            var line = session.getLine(pos.row);
            // 调用回调函数
            callback(null, {
                prefix: util.retrievePrecedingIdentifier(line, pos.column, results[0] &amp;amp;&amp;amp; results[0].identifierRegex),
                matches: matches,
                finished: (--total === 0)
            });
        });
    });
    return true;
};
&lt;/pre&gt;

&lt;p&gt;在每个补全器的&lt;strong&gt;getCompletions&lt;/strong&gt;方法中都会调用callback方法：将自己的结果合并到全局的数据中。获取补全器的数据之后就会调用&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L81&quot;&gt;openPopup&lt;/a&gt;方法来更新展示：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.openPopup = function(editor, prefix, keepPopupPosition) {
    if (!this.popup)
        this.$init();
    this.popup.setData(this.completions.filtered);
    editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    var renderer = editor.renderer;
    this.popup.setRow(this.autoSelect ? 0 : -1);
    if (!keepPopupPosition) {
        // 设置展示
        this.popup.setTheme(editor.getTheme());
        this.popup.setFontSize(editor.getFontSize());
        var lineHeight = renderer.layerConfig.lineHeight;
        // 设置位置
        var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
        pos.left -= this.popup.getTextLeftOffset();
        var rect = editor.container.getBoundingClientRect();
        pos.top += rect.top - renderer.layerConfig.offset;
        pos.left += rect.left - editor.renderer.scrollLeft;
        pos.left += renderer.gutterWidth;
        // 展示内容
        this.popup.show(pos, lineHeight);
    } else if (keepPopupPosition &amp;amp;&amp;amp; !prefix) {
        this.detach();
    }
};
&lt;/pre&gt;

&lt;p&gt;回过头再来看language_tools.js中的补全器：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;getCompletions&lt;/strong&gt;：获取补全列表；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;getDocTooltip&lt;/strong&gt;：返回HTML格式的提示内容；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个补全列表中的元素包含如下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;caption&lt;/strong&gt;：字幕，也就是展示在列表中的内容&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;meta&lt;/strong&gt;：展示类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;name&lt;/strong&gt;：名称&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;：值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;score&lt;/strong&gt;：分数，越大的排在越上面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而getDocTooltip感觉又进一步地提升了写代码时候的体验（在写代码的时候就知道输入的是什么）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-5.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体是怎么实现的呢？接着来看代码，&lt;strong&gt;Mode&lt;/strong&gt;中的&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/mode/text.js#L370&quot;&gt;getCompletions&lt;/a&gt;如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.getCompletions = function(state, session, pos, prefix) {
    // 获取当前Mode的关键字
    var keywords = this.$keywordList || this.$createKeywordList();
    // 根据关键字组装补全列表
    return keywords.map(function(word) {
        return {
            name: word,
            value: word,
            score: 0,
            meta: &quot;keyword&quot;
        };
    });
};
&lt;/pre&gt;

&lt;p&gt;在当前文件中写过的单词被自动提示补全的逻辑在&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete/text_completer.js&quot;&gt;text_completer.js&lt;/a&gt;中实现（逻辑很简单），比较麻烦的是&lt;strong&gt;enableSnippets&lt;/strong&gt;，这个后面有时间再看。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;自定义补全&lt;/h2&gt;

&lt;p&gt;知道了ACE的补全运行的原理，那么现在扩展起来就比较简单了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var languageTools = ace.require(&quot;ace/ext/language_tools&quot;);
    languageTools.addCompleter({
        getCompletions: function(editor, session, pos, prefix, callback) {
        callback(null,  [
            {
                name : &quot;test&quot;,
                value : &quot;test&quot;,
                caption: &quot;test&quot;,
                meta: &quot;test&quot;,
                type: &quot;local&quot;,
                score : 1000 // 让test排在最上面
            }
        ]);
    }
});
&lt;/pre&gt;

&lt;p&gt;虽然看到的例子都是同步执行callback方法，但用异步来做也是完全没有问题的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在上面看源码的时候还不明白为啥每次回调的时候都要更新显示而不是等全部执行完后更新一次~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在事件驱动的系统中接口的设计还是需要多思考、多推敲的啊！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;有了自动补全之后与IDE的距离又近了一步，不仅仅能加快脚步编写的速度，更重要的是代码的准确性也会有所提高，当然这还是不够的！&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Nov 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/11/06/ACEJS-B.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/11/06/ACEJS-B.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
