<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 27 Oct 2015 08:50:28 +0800</pubDate>
    <lastBuildDate>Tue, 27 Oct 2015 08:50:28 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>用ACE做WEB代码高亮（一）</title>
        <description>&lt;p&gt;后台应用通常会有很多的配置页面，现在在状态是直接搞一个textarea来搞：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种粗糙、QJ用户的行为显然不是一个有节操的程序员该干的，为了这种配置的页面好用最少应该提供三个功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;高亮：提示关键字、类型，可以在第一时间发现简单错误&lt;/li&gt;
  &lt;li&gt;缩进：增加配置可读性的最简单的办法&lt;/li&gt;
  &lt;li&gt;折叠：有一大堆的配置的时候折叠还是挺好用的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在网上逛了一圈发现Colud9的ACE还是挺好用的（GitHub上10000+的Star也说明了实力），可以在&lt;a href=&quot;https://ace.c9.io/build/kitchen-sink.html&quot;&gt;这里&lt;/a&gt;体验下，国内的&lt;a href=&quot;https://coding.net/&quot;&gt;coding.net&lt;/a&gt;平台所使用的也是该工具，但是做出来的效果离Colud9还是有不小的差距。。。&lt;/p&gt;

&lt;p&gt;由于网上的资料不多，学习过程非常痛苦，有些东西是直接看&lt;a href=&quot;https://github.com/ajaxorg/ace&quot;&gt;代码&lt;/a&gt;去猜测运行的原理，希望对需要的人有一点帮助！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;使用&lt;/h2&gt;

&lt;p&gt;使用方法很经典（和HighCharts等差不多）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&amp;gt;
    #editor {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;editor&quot;&amp;gt;function foo(items) {
    var x = &quot;All this is syntax highlighted&quot;;
    return x;
}&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;https://ace.c9.io/build/src/ace.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var editor = ace.edit(&quot;editor&quot;);
    editor.setTheme(&quot;ace/theme/monokai&quot;);
	editor.getSession().setMode(&quot;ace/mode/javascript&quot;);
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;完成后ACE会在&lt;code&gt;&amp;lt;div id=&quot;editor&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;渲染出对应的DOM结构，其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;editor.setTheme&lt;/strong&gt;：设置主题，有点皮肤的意思&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;editor.getSession().setMode&lt;/strong&gt;：设置模式，上面这段设置的是JavaScript的模式，其中包括了高亮、缩进、折叠凳功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ajaxorg/ace/tree/master/lib/ace/mode&quot;&gt;内部&lt;/a&gt;有大部分语言的模式，正常情况下你是不需要考虑后面的内容的。后来有同事用drools做规则引擎，这个没有现成的只能自己来搞！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;高亮&lt;/h2&gt;

&lt;p&gt;让代码高亮显示的思路很简单，比如将关键字用&lt;code&gt;&amp;lt;span class=&quot;ace_keyword&quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt;包裹起来并在CSS中设置样式即可，那么关键问题就是如何对源码进行&lt;strong&gt;词法分析&lt;/strong&gt;了。&lt;/p&gt;

&lt;p&gt;在ACE中实现的时候有点像&lt;strong&gt;状态机&lt;/strong&gt;，在处理时不断地从当前状态的规则集中找到匹配&lt;code&gt;regex&lt;/code&gt;的规则，之后跳转到对应的&lt;code&gt;next&lt;/code&gt;状态：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.$rules = {
    &quot;start&quot; : [
        {
            token: &amp;lt;token&amp;gt;, // class名称
            regex: &amp;lt;regex&amp;gt;, // 正则匹配串
            next:  &amp;lt;next&amp;gt;   // 下个状态
        }
    ]
};
&lt;/pre&gt;

&lt;p&gt;相比普通的词法分析器，一个状态就相当于一个小的隔离环境，在这个隔离环境中在做匹配的时候难度要小很多，你只需要考虑在该状态内可能出现的TOKEN即可：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-2.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外比较好用的几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设置&lt;strong&gt;merge:true&lt;/strong&gt;来合并连续的token&lt;/li&gt;
  &lt;li&gt;利用&lt;strong&gt;createKeywordMapper&lt;/strong&gt;来简化关键字列表的编写&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么简单来做个drools高亮的Mode如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ace.define(&quot;ace/mode/drools_highlight_rules&quot;, function(require, exports, module) {
    &quot;use strict&quot;;
    var oop = require(&quot;../lib/oop&quot;);
    var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
    var DroolsHighlightRules = function(){
        var keywordMapper = this.createKeywordMapper({
            &quot;keyword&quot;:
                &quot;when|then|rule|end|salience&quot;
        }, &quot;identifier&quot;);
        this.$rules = {
            &quot;start&quot; :[{
                token : keywordMapper,
                regex : &quot;[a-zA-Z_$][a-zA-Z0-9_$]*\\b&quot;
            }]
        };
    };
    oop.inherits(DroolsHighlightRules, TextHighlightRules);
    exports.DroolsHighlightRules = DroolsHighlightRules;
});
 
ace.define(&quot;ace/mode/drools&quot;, function(require, exports, module) {
    &quot;use strict&quot;;
    var oop = require(&quot;../lib/oop&quot;);
    var TextMode = require(&quot;./text&quot;).Mode;
    var DroolsHighlightRules = require(&quot;./drools_highlight_rules&quot;).DroolsHighlightRules;
    var DroolsMode = function(){
        this.HighlightRules = DroolsHighlightRules;
    };
    oop.inherits(DroolsMode, TextMode);
    (function() {
        this.$id = &quot;ace/mode/drools&quot;
    }).call(DroolsMode.prototype),
    exports.Mode = DroolsMode;
});
&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-3.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更多的功能可以在&lt;a href=&quot;https://ace.c9.io/#nav=higlighter&quot;&gt;这里&lt;/a&gt;看到，不过貌似很不稳定- -！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缩进&lt;/h2&gt;

&lt;p&gt;ACE为MODE扩展缩进预留了接口，你只需要实现&lt;strong&gt;getNextLineIndent&lt;/strong&gt;方法即可，会将其结果自动添加到新行的开头，参数含义为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;state：状态&lt;/li&gt;
  &lt;li&gt;line：当前行内容&lt;/li&gt;
  &lt;li&gt;tab：缩进符号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看个例子（如果是{[(结尾的，那么下一行的缩进加一）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
(function(){
    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        if (state == &quot;start&quot;) {
            var match = line.match(/^.*[\{\(\[]\s*$/); // 如果是{[(结尾的，那么下一行的缩进加一
            if (match) {
                indent += tab;
            }
        }
        return indent;
    };
}).call(DroolsMode.prototype);
&lt;/pre&gt;

&lt;p&gt;对大部分的缩进需求这种方式完全能搞定了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;折叠&lt;/h2&gt;

&lt;p&gt;折叠的实现涉及到范围对象new Range(Number startRow, Number startColumn, Number endRow, Number endColumn)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;startRow：开始行&lt;/li&gt;
  &lt;li&gt;startColumn：开始列&lt;/li&gt;
  &lt;li&gt;endRow：结束行&lt;/li&gt;
  &lt;li&gt;endColumn：结束列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现折叠需要提供两个方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;getFoldWidget&lt;/strong&gt;：折叠开始的地方&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;getFoldWidgetRange&lt;/strong&gt;：需要折叠的范围&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们为drools实现一个简单的折叠逻辑，也就是将&lt;strong&gt;rule&lt;/strong&gt;与&lt;strong&gt;end&lt;/strong&gt;之间的部分能够折叠隐藏：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ace.define(&quot;ace/mode/folding/drools_fold&quot;, function(require, exports, module) {
    &quot;use strict&quot;;
    var Range = require(&quot;../../range&quot;).Range;
    var FoldMode = exports.FoldMode = function() {};
    (function() {
        this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (line == &quot;rule&quot;)
                return &quot;start&quot;;
            return &quot;&quot;;
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
            var startRow = row, startColumn = 4;
            var endRow = row+1, endColumn = 3;
            while(session.getLine(endRow) != &quot;end&quot;){
                endRow += 1;
            }
            return new Range(startRow, startColumn, endRow, endColumn);
        };
    }).call(FoldMode.prototype);
});
&lt;/pre&gt;

&lt;p&gt;然后需要在drools的Mode中设置&lt;strong&gt;foldingRules&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var DroolsFoldMode = require(&quot;ace/mode/folding/drools_fold&quot;).FoldMode;
var DroolsMode = function(){
    this.foldingRules = new DroolsFoldMode();
};
&lt;/pre&gt;

&lt;p&gt;在ACE中提供了一个基本的折叠块：&lt;strong&gt;fold_mode&lt;/strong&gt;，用来折叠相同的缩进部分，如果需要直接集成即可！&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;实现了这三部分功能已经可以大幅度提升简单配置页面的体验，但是作为一个在线的IDE才仅仅是万里长征的第一步！&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Oct 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/19/ACEJS-A.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/19/ACEJS-A.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>模板语言设计</title>
        <description>&lt;p&gt;模板语言技术极大的减少了苦逼码农的工作量，使我们从大量的字符串拼接中脱离出来：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;有自己的语法控制结构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将两种语法分割&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;作为一种语言运行的方式无非下面几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;边处理源码边渲染，和很多的脚本语言类似&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成AST存到内存里面，每次渲染则是在AST上遍历完成&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成目标语言或者字节码等&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这篇文章的重点是比较各个模板语言，看看大家设计的思虑~ 具体如何解析、运行看看&lt;a href=&quot;http://wsztrush.github.io/dsl/2015/09/06/Language-Implementation-Patterns.html&quot;&gt;《编程语言实现模式》&lt;/a&gt;基本可以很快搞出来。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;有控制结构&lt;/h2&gt;

&lt;p&gt;从实习就开始用&lt;strong&gt;Velocity&lt;/strong&gt;来渲染HTML，感觉好用以至于现在都用它来渲染SQL语句：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;

#foreach($info in $list)

    $info.someList

#end

&lt;/pre&gt;

&lt;p&gt;所有的控制结构都是&lt;code&gt;#&lt;/code&gt;开头的，而取数据则是&lt;code&gt;$&lt;/code&gt;开头，剩下普通的字符串就直接向结果中拼接，因为#$在HTML中很少用到，所以这样设计还是非常好用的~&lt;/p&gt;

&lt;p&gt;对应的，在前端世界里&lt;strong&gt;EmberJS&lt;/strong&gt;与它很像：&lt;/p&gt;

&lt;pre class=&quot;prettyrpint&quot;&gt;



    Welcome back, &amp;lt;b&amp;gt; &amp;lt;/b&amp;gt;!



    Please log in.



&lt;/pre&gt;

&lt;p&gt;这两年非常火的&lt;strong&gt;Angular&lt;/strong&gt;基本上也是这种思路，用``来取数据（双向绑定）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;

&amp;lt;div ng-if=&quot;person != null&quot;&amp;gt;

    Welcome back, &amp;lt;b&amp;gt; &amp;lt;/b&amp;gt;!

&amp;lt;/div&amp;gt;

&amp;lt;div ng-if=&quot;person == null&quot;&amp;gt;

    Please log in.

&amp;lt;/div&amp;gt;

&lt;/pre&gt;

&lt;p&gt;由于Angular想做的事情是根据数据的变化来修改页面的展示，用Velocity这种有自己的控制语句来做还是非常困难的，那么更好的思路就是把控制结构与DOM结构绑定，比如&lt;code&gt;ng-if&lt;/code&gt;，&lt;code&gt;ng-repeat&lt;/code&gt;等。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;无控制结构&lt;/h2&gt;

&lt;h2 id=&quot;react&quot;&gt;React&lt;/h2&gt;

&lt;p&gt;最近两年React红的发紫，不仅仅因为有个好爹，体验了一下感觉JSX还是不错的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;

var root =(

    &amp;lt;ul className=&quot;my-list&quot;&amp;gt;

        &amp;lt;li&amp;gt;First Text Content&amp;lt;/li&amp;gt;

        &amp;lt;li&amp;gt;Second Text Content&amp;lt;/li&amp;gt;

    &amp;lt;/ul&amp;gt;

);

&lt;/pre&gt;

&lt;p&gt;这种JS和XML混排的方式看着有点头大，但是仔细看下还是挺直观的！在遇到&lt;code&gt;&amp;lt;xxx&amp;gt;&lt;/code&gt;的时候创建元素，在遇到&lt;code&gt;{xxx}&lt;/code&gt;的时候当做JS解析，而最终是将其翻译成JS代码来执行：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;

var child1 = React.createElement('li', null, 'First Text Content');

var child2 = React.createElement('li', null, 'Second Text Content');

var root = React.createElement('ul', { className: 'my-list' }, child1, child2);

&lt;/pre&gt;

&lt;p&gt;让JS参与到模板渲染的过程中能极大地提高模板的能力，但是问题是太灵活了以至于数据变化的时候都不知道该怎么修改DOM了，这么看来虚拟DOM的&lt;strong&gt;Diff&lt;/strong&gt;算法其实也是无奈之举~~~&lt;/p&gt;

&lt;h2 id=&quot;emberjs&quot;&gt;EmberJS&lt;/h2&gt;

&lt;p&gt;在绑定数据的同时可以进行一些简单的逻辑控制：&lt;/p&gt;

&lt;p&gt;看起来有点像是Angular和Velocity的结合体！越是这么搞越像是在搞静态页面，对于动态页面来说基本是不行的~~&lt;/p&gt;

&lt;h2 id=&quot;mustache&quot;&gt;Mustache&lt;/h2&gt;

&lt;p&gt;Mustache通常被称为JavaScript模板的基础：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;

Mustache.render(&quot;Hello, &quot;, { name: &quot;Jack&quot; });

&lt;/pre&gt;

&lt;p&gt;用来渲染字符串（或者静态HTML）还是可以的！&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Oct 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/15/Template-Language.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/15/Template-Language.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>xml之schema</title>
        <description>&lt;p&gt;在网络传输中JSON和XML是最长用的两种数据格式，JSON的特点是短小、简单，但是除了这点以外就完全不能跟XML比了，所以涉及到配置方面还是优先考虑XML吧！&lt;/p&gt;

&lt;p&gt;但是裸奔的XML并不好用，比如我们打出来Jar包给别人用，需要他们自己在Spring配置中添加：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean class=&quot;xxxxxx&quot;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;功能简单的时候是没有问题的，当你做的东西比较复杂的时候就会变成：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean class=&quot;xxx&quot;&amp;gt;
    &amp;lt;property name=&quot;aaa&quot; value=&quot;aaa&quot;/&amp;gt;
    &amp;lt;property name=&quot;bbb&quot; value=&quot;bbb&quot;/&amp;gt;
    &amp;lt;property name=&quot;ccc&quot; value=&quot;ccc&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;

&lt;p&gt;除非在你的WILE里面写的非常清楚应用用哪个&lt;code&gt;class&lt;/code&gt;，需要设置哪些&lt;code&gt;property&lt;/code&gt;，哪些是必填的等等等，不然没人知道该怎么写，而更好的解决办法是编写schema来定义XML的规则！&lt;/p&gt;

&lt;h2 id=&quot;xmlns&quot;&gt;命名空间（xmlns）&lt;/h2&gt;

&lt;p&gt;我们在配置Spring的时候经常会这么写：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;beans:beans xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;&amp;gt;
    &amp;lt;beans:import resource=&quot;xxx&quot;/&amp;gt;
&amp;lt;/beans:beans&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;http://www.springframework.org/schema/beans&lt;/code&gt;就是一个命名空间，而&lt;code&gt;xmlns:beans&lt;/code&gt;相当于设置了命名空间的一个代号，在使用时&lt;code&gt;beans:import&lt;/code&gt;就可以表示使用该命名空间中的import元素。&lt;/p&gt;

&lt;p&gt;可以不写&lt;code&gt;:beans&lt;/code&gt;来表示默认就用该命名空间，那么配置就更简单了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&amp;gt;
    &amp;lt;import resource=&quot;xxx&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在schema中由下面三个属性来控制命名空间的行为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;targetNamespace：目标命名空间&lt;/li&gt;
  &lt;li&gt;elementFormDefault：unqualified/qualified&lt;/li&gt;
  &lt;li&gt;attributeFormDefault：unqualified/qualified&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当设置&lt;code&gt;unqualified&lt;/code&gt;时schema中除了根元素以外，其他的元素都是没有命名空间的，在使用的时候需要将其命名空间设置为空：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;easydt:easydt xmlns:easydt=&quot;http://www.cainiao.com/schema/easydt&quot;&amp;gt;
    &amp;lt;provider xmlns=&quot;&quot;/&amp;gt;&amp;lt;!-- 注意这里 --&amp;gt;
&amp;lt;/easydt:easydt&amp;gt;
&lt;/pre&gt;

&lt;p&gt;而设置为&lt;code&gt;qualified&lt;/code&gt;时schema中定义的所有元素都属于&lt;code&gt;targetNamespace&lt;/code&gt;所定义的命名空间：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;easydt:easydt xmlns=&quot;http://www.cainiao.com/schema/easydt&quot;&amp;gt;
    &amp;lt;provider/&amp;gt;&amp;lt;!-- 看这里 --&amp;gt;
&amp;lt;/easydt:easydt&amp;gt;
&lt;/pre&gt;

&lt;p&gt;显然用qualified看起来更简单一些，不过也是看情况的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;定义元素&lt;/h2&gt;

&lt;p&gt;完整的schema的定义如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.w3school.com.cn&quot;
xmlns=&quot;http://www.w3school.com.cn&quot;
elementFormDefault=&quot;qualified&quot;&amp;gt;
    在这里定义元素和属性
&amp;lt;/xs:schema&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其目的就是配置出来一堆的&lt;code&gt;element&lt;/code&gt;和&lt;code&gt;attribute&lt;/code&gt;来约束XML的行为，简单来说&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;yyy xxx=&quot;xxx&quot;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其中：yyy是element、xxx是属性！最简单的元素如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;easydt:a&amp;gt;123&amp;lt;/easydt:a&amp;gt;
&lt;/pre&gt;

&lt;p&gt;对应的配置如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;a&quot; type=&quot;xs:integer&quot;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;设置type为&lt;code&gt;integer&lt;/code&gt;之后会对内容进行检查，如果不是数字则报错，另外可以通过&lt;code&gt;simpleType&lt;/code&gt;对其扩展来实现更复杂的限定：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;age&quot;&amp;gt;
    &amp;lt;xs:simpleType&amp;gt;
        &amp;lt;xs:restriction base=&quot;xs:integer&quot;&amp;gt;
            &amp;lt;xs:minInclusive value=&quot;0&quot;/&amp;gt;
            &amp;lt;xs:maxInclusive value=&quot;100&quot;/&amp;gt;
        &amp;lt;/xs:restriction&amp;gt;
    &amp;lt;/xs:simpleType&amp;gt;
&amp;lt;/xs:element&amp;gt;
&lt;/pre&gt;

&lt;p&gt;向元素中添加子元素、属性之后就不是一个简单元素，而是一个复杂元素，可以用&lt;code&gt;complexType&lt;/code&gt;定义其类型：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;note&quot;&amp;gt;
    &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:attribute name=&quot;app&quot; type=&quot;xs:string&quot;/&amp;gt;
    &amp;lt;/xs:complexType&amp;gt;
&amp;lt;/xs:element&amp;gt;
&lt;/pre&gt;

&lt;p&gt;对应的XML的配置为&lt;code&gt;&amp;lt;easydt:note app=&quot;123&quot;/&amp;gt;&lt;/code&gt;，子节点的定义也很简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;note&quot;&amp;gt;
    &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:sequence&amp;gt;
            &amp;lt;xs:element name=&quot;a&quot; type=&quot;xs:integer&quot;/&amp;gt;
            &amp;lt;xs:element name=&quot;b&quot; type=&quot;xs:integer&quot;/&amp;gt;
        &amp;lt;/xs:sequence&amp;gt;
    &amp;lt;/xs:complexType&amp;gt;
&amp;lt;/xs:element&amp;gt;
&lt;/pre&gt;

&lt;p&gt;对应的XML的配置为&lt;code&gt;&amp;lt;note&amp;gt;&amp;lt;a&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;2&amp;lt;/b&amp;gt;&amp;lt;/note&amp;gt;&lt;/code&gt;，其中sequence的作用是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;组中的元素以指定的顺序出现在包含元素中，每个子元素可以出现0次到任意次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然还有其他的方式：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指示器&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;子元素可以按照任意顺序出现，且每个子元素必须只出现一次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;choice&lt;/td&gt;
      &lt;td&gt;随便添加子元素，可以使用&lt;code&gt;maxOccurs&lt;/code&gt;来设置可添加子元素的数目&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;attributeGroup&lt;/td&gt;
      &lt;td&gt;属性组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;group&lt;/td&gt;
      &lt;td&gt;元素组&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;元素的类型是非常复杂的，不同的类型之间很可能有一些定义是可以重用的，我们可以定义一些基础的类型，然后使用&lt;code&gt;extension&lt;/code&gt;对其进行扩展可以得到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:complexType name=&quot;baseInfo&quot;&amp;gt;
    &amp;lt;xs:sequence&amp;gt;
        &amp;lt;xs:element name=&quot;id&quot; type=&quot;xs:string&quot;/&amp;gt;
    &amp;lt;/xs:sequence&amp;gt;
&amp;lt;/xs:complexType&amp;gt;
&amp;lt;xs:complexType name=&quot;fullpersoninfo&quot;&amp;gt;
    &amp;lt;xs:complexContent&amp;gt;
        &amp;lt;xs:extension base=&quot;baseInfo&quot;&amp;gt;
            &amp;lt;xs:sequence&amp;gt;
                &amp;lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&amp;gt;
            &amp;lt;/xs:sequence&amp;gt;
        &amp;lt;/xs:extension&amp;gt;
    &amp;lt;/xs:complexContent&amp;gt;
&amp;lt;/xs:complexType&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其他元素的可以在&lt;a href=&quot;http://www.w3school.com.cn/schema/schema_elements_ref.asp&quot;&gt;这里&lt;/a&gt;查看使用方法~~&lt;/p&gt;

&lt;p&gt;当上面这些不能满足你的需求时，可以使用&lt;code&gt;any&lt;/code&gt;、&lt;code&gt;anyAttribute&lt;/code&gt;来允许用户配置没有在schema中定义过的东西，然后在解析的阶段进行处理！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解析&lt;/h2&gt;

&lt;p&gt;在Spring中定义解析需要用下面两个文件来配置（需要放在META-INF目录，Spring会自动加载）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;spring.schemas&lt;/strong&gt;：命名空间对应的schemas配置的位置&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;spring.handlers&lt;/strong&gt;：命名空间对应的解析类&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// spring.schemas
http\://www.cainiao.com/schema/easydt/easydt.xsd=META-INF/easydt.xsd
// spring.handlers
http\://www.cainiao.com/schema/easydt=com.cainiao.easydt.client.springTag.EasyDtNamespaceHandler
&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;NamespaceHandlerSupport&lt;/code&gt;中定义了遇到对应的元素的时候应该使用Parser：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class EasyDtNamespaceHandler extends NamespaceHandlerSupport {
	public void init() {
		registerBeanDefinitionParser(&quot;easydt&quot;, new EasyDtBeanDefinitionParser());
	}
}
&lt;/pre&gt;

&lt;p&gt;然后用&lt;code&gt;AbstractBeanDefinitionParser&lt;/code&gt;中拿到配置信息并使用&lt;code&gt;addPropertyValue&lt;/code&gt;来定义BeanDefinition：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class EasyDtBeanDefinitionParser extends AbstractSingleBeanDefinitionParser{
	protected Class&amp;lt;EasyDt&amp;gt; getBeanClass(Element element) {
		return EasyDt.class;
	}
	protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
		builder.addPropertyValue(&quot;domain&quot;, element.getAttribute(&quot;domain&quot;));
	}
}
&lt;/pre&gt;

&lt;p&gt;关于BeanDefinition的载入和解析的过程可以看&lt;a href=&quot;http://book.51cto.com/art/201203/322589.htm&quot;&gt;这里&lt;/a&gt;，具体的解析工作是交给&lt;code&gt;BeanDefinitionParserDelegate&lt;/code&gt;来完成的，如果子元素不是简单元素可以调用&lt;code&gt;parseCustomElement&lt;/code&gt;来完成解析：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
builder.addPropertyValue(&quot;provider&quot;,
    parserContext.getDelegate().parseCustomElement(
        DomUtils.getChildElementByTagName(element, &quot;provider&quot;),
        builder.getRawBeanDefinition()));
&lt;/pre&gt;

&lt;p&gt;想更灵活地在Spring中玩耍XML还是要多看看Bean的解析过程。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;用这些最基本的用法基本可以搞定大部分的自定义schema的需求，对于复杂的还需要深入去研究。&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Oct 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/14/Xml-Schema.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/14/Xml-Schema.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>JQUERY</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img4.douban.com/mpic/s10170467.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jquery&quot;&gt;为什么学习jQuery&lt;/h2&gt;

&lt;p&gt;原生JavaScript写代码很不方便而且容易出错（一直感觉写getElementById非常地烦），再加上浏览器之间差异处理起来就更烦躁了，jQuery刚好能解决这些问题，而且：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;轻量级&lt;/li&gt;
  &lt;li&gt;链式编程&lt;/li&gt;
  &lt;li&gt;隐式迭代&lt;/li&gt;
  &lt;li&gt;丰富的插件支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，赶紧开始jQuery之旅！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;元素选择及操作&lt;/h2&gt;

&lt;p&gt;用jQuery在选择元素时和用CSS选择非常像且代码量很少，因此上手很容易：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;选择器&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;基本选择器&lt;/td&gt;
      &lt;td&gt;$(‘div’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;层次选择器&lt;/td&gt;
      &lt;td&gt;$(‘.a &amp;gt; div’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;基本过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div:first’)、$(‘input:even’)、$(‘header’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内容过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div:contains(di)’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可见性过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div:visible’)、$(‘div:hidden’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;属性过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div[title]’)、$(‘div[id][title*=es]’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;子元素过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div.one :nth-child(2)’)、$(‘div.one :first-child’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表单对象属性过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘#form1 input:enable’)、$(‘input:checked’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表单选择器&lt;/td&gt;
      &lt;td&gt;$(‘#form1 :input’)、$(‘#form1 :password’)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;遇到特殊字符时需要转义，比如对&lt;strong&gt;&amp;lt;div id=”id#b”&amp;gt;bb&amp;lt;/div&amp;gt;&lt;/strong&gt;需要用&lt;strong&gt;$(‘#id\#b’)&lt;/strong&gt;来选取，编写时尤其需要注意空格，挨着和不挨着的区别太大了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(‘.test :hidden’)&lt;/li&gt;
  &lt;li&gt;$(‘.test:hidden’)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了可以使用jQuery，还有其他的方式支持CSS选择器，这里就省略了~ 用选择器拿到的是jQuery对象（对dom对象做了封装），可用$cr[0]拿到对应的dom对象~&lt;/p&gt;

&lt;p&gt;另外jQuery对DOM操作的封装有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;创建&lt;/td&gt;
      &lt;td&gt;$(‘&amp;lt;li&amp;gt;abc&amp;lt;/li&amp;gt;’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;插入&lt;/td&gt;
      &lt;td&gt;$(“p”).prepend($(‘&amp;lt;li&amp;gt;abc&amp;lt;/li&amp;gt;’))&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;删除&lt;/td&gt;
      &lt;td&gt;remove&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;复制&lt;/td&gt;
      &lt;td&gt;$(this).clone(true)没有参数时复制生成的对象不具有任何行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;替换&lt;/td&gt;
      &lt;td&gt;$(“p”).replaceWith(“&amp;lt;strong&amp;gt;abc&amp;lt;strong&amp;gt;”)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;包裹&lt;/td&gt;
      &lt;td&gt;$(“strong”).warp(“&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;”)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设置/获取属性&lt;/td&gt;
      &lt;td&gt;获取：$para.attr(“title”)，设置：$para.attr(“title”, “new title”)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;样式&lt;/td&gt;
      &lt;td&gt;addClass、removeClass、toggleClass、hasClass、css&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;文本&lt;/td&gt;
      &lt;td&gt;获取：$para.html()，设置：$para.html(“&amp;lt;strong&amp;gt;abc&amp;lt;strong&amp;gt;”)，text()/val()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;子元素&lt;/td&gt;
      &lt;td&gt;children&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;兄弟元素&lt;/td&gt;
      &lt;td&gt;next、pre、sibling&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事件与动画&lt;/h2&gt;

&lt;p&gt;以前经常在代码中看到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
$(function(){
    // DOM就绪时执行的方法
});
&lt;/pre&gt;

&lt;p&gt;作用像是绑定了对ready的响应，而对于普通的事件（鼠标点击等）可以用&lt;strong&gt;on&lt;/strong&gt;来统一搞定：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;on(events, [, selector] [, data], handler)
on( eventsMap [, selector ] [, data ] )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参数的含义如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;events&lt;/strong&gt;：一个或多个用空格分隔的事件类型和可选的命名空间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;eventsMap&lt;/strong&gt;：属性对应事件类型和可选的命名空间，属性值对应绑定的事件处理函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;selector&lt;/strong&gt;：指定哪些后代元素可以触发绑定的事件&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;：触发事件时，需要通过event.data传递给事件处理函数的任意数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;handler&lt;/strong&gt;：事件处理函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：在jQuery1.8之后bind、delegate、live都不建议使用，所以干脆就都用on好了！&lt;/p&gt;

&lt;p&gt;另外并不是每个事件都只有一个处理函数，在jQuery中有两个合成事件：&lt;strong&gt;hover&lt;/strong&gt;和&lt;strong&gt;toggle&lt;/strong&gt;，其中hover的使用方法如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;hover(enter, lever)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;分别用两个函数来响应移入和移出，相比较toggle就更加暴力了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;toggle(f1, f2, …., fn)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在第一次点击时调用f1、第二次调用f2、依次类推，n个方法循环调用（没想到需要用到什么地方- -!），jQuery对事件对象进行了封装，提供如下方法：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;type()&lt;/td&gt;
      &lt;td&gt;类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;stopPropagation()&lt;/td&gt;
      &lt;td&gt;停止事件冒泡&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;preventDefault()&lt;/td&gt;
      &lt;td&gt;阻止默认的行为，比如可以阻止点击&amp;lt;a&amp;gt;标签打开新页面的行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;target()&lt;/td&gt;
      &lt;td&gt;触发事件的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;relatedTarget()&lt;/td&gt;
      &lt;td&gt;获取相关元素，在mouseover和mouseout的时候经常用到&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;which()&lt;/td&gt;
      &lt;td&gt;鼠标点击或者键盘点击事件中，获取具体的按键&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;既然能绑定就应该能解除：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jQueryObject.off( [ events [, selector ] [, handler ] ] )
jQueryObject.off( eventsMap [, selector ] )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：可以用&lt;strong&gt;trigger&lt;/strong&gt;来模拟事件，用来实现一些功能（比如快捷键）还是非常方便的！在jQuery中对DOM元素上的动画做了一些封装（不用再蛋疼地使用setTimeout）：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;效果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;show/hide&lt;/td&gt;
      &lt;td&gt;显示、隐藏元素，可通过参数控制速度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fadeIn/fadeOut&lt;/td&gt;
      &lt;td&gt;改变元素不透明度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;slideUp/slideDown&lt;/td&gt;
      &lt;td&gt;改变元素高度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;animate&lt;/td&gt;
      &lt;td&gt;自定义动画，上面的功能用该方法都很容易搞定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;toggle&lt;/td&gt;
      &lt;td&gt;两种状态切换，用在按钮的效果上面非常合适&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;slideToggle&lt;/td&gt;
      &lt;td&gt;通过高度变化来切换元素的可见性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fadeTo&lt;/td&gt;
      &lt;td&gt;以渐进的方式修改不透明度&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;strong&gt;animate&lt;/strong&gt;的定义如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;animate(params, speed, callback)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参数含义如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;params&lt;/strong&gt;：包含样式属性及值的映射，用来控制动画的行为&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;speed&lt;/strong&gt;：速度&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;callback&lt;/strong&gt;：结束时的回调函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面来看几个实际的例子感受下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
$(this).animate({left:&quot;500px&quot;}, 3000);// 使left从原来的值变为500
$(this).animate({left:&quot;+=500px&quot;}, 3000);// 使left从原来的值增加500
$(this).animate({left:&quot;+=500px&quot;,height:&quot;+=600px&quot;}, 3000);// 多重动画
$(this).animate({left:&quot;+=500px&quot;}, 3000)
       .animate({height:&quot;+=500px&quot;}, 3000);// 两个动画效果链式写法
&lt;/pre&gt;

&lt;p&gt;延迟总是会带来问题，比如为元素的移入、移出设计了动画，但是在鼠标快速移动的时候动画的效果可能就与实际鼠标的位置不一致了，这时候需要&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;stop([cleanQueue] [, gotoEnd])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cleanQueue：是否清空未执行完成的动画&lt;/li&gt;
  &lt;li&gt;gotoEnd：是否将正在执行的动画跳转到末状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外可以使用&lt;strong&gt;$(this).is(“:animated”)&lt;/strong&gt;判断元素是否处于动画状态！&lt;/p&gt;

&lt;h2 id=&quot;ajax&quot;&gt;Ajax&lt;/h2&gt;

&lt;p&gt;全称为&lt;strong&gt;Asynchronous JavaScript and XML&lt;/strong&gt;，并不是指一种单一的技术，而是有机地利用一系列交互式网页应用相关的技术所形成的结合体，优势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不需要插件支持&lt;/li&gt;
  &lt;li&gt;优秀的用户体验&lt;/li&gt;
  &lt;li&gt;提高Web程序的性能&lt;/li&gt;
  &lt;li&gt;减轻服务器和带宽的负担&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器对XMLHttpRequest对象的支持度不足&lt;/li&gt;
  &lt;li&gt;破坏浏览器前进、后退按钮的正常功能&lt;/li&gt;
  &lt;li&gt;对搜索引擎的支持不足&lt;/li&gt;
  &lt;li&gt;开发和调试工具的缺乏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于JavaScript原生的写法可以看&lt;a href=&quot;http://wsztrush.github.io/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/09/JavaScript-Basic.html&quot;&gt;这里&lt;/a&gt;，在jQuery中的封装如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;load(url [,data] [, callback])&lt;/td&gt;
      &lt;td&gt;加载HTML文档并插入DOM中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get(url [,data] [, callback] [, type])&lt;/td&gt;
      &lt;td&gt;使用GET方式异步请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;post(url [,data] [, callback] [, type])&lt;/td&gt;
      &lt;td&gt;使用POST方式异步请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getScript()&lt;/td&gt;
      &lt;td&gt;加载脚本文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getJson()&lt;/td&gt;
      &lt;td&gt;加载JSON文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ajax()&lt;/td&gt;
      &lt;td&gt;最底层的实现，是其他方法的基础&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;方法ajax()的参数如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;url&lt;/strong&gt;：发送请求的地址&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;type&lt;/strong&gt;：请求方式（GET or POST）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;timeout&lt;/strong&gt;：请求超时时间（毫秒）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;：发送到服务端的数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;dataType&lt;/strong&gt;：预期服务器返回的数据类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;beforeSend&lt;/strong&gt;：发送请求前执行的函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;complete&lt;/strong&gt;：请求完成后的回调函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;success&lt;/strong&gt;：请求成功后的回调函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;error&lt;/strong&gt;：请求失败时的回调函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;global&lt;/strong&gt;：是否触发全局Ajax事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于巨大的表单在提交的时候获取参数是非常繁琐的，在jQuery做了简单的封装serialize()、serializeArray()、param()。在用上面的方法发送请求的过程中会触发事件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ajaxStart&lt;/li&gt;
  &lt;li&gt;ajaxSend&lt;/li&gt;
  &lt;li&gt;ajaxSuccess&lt;/li&gt;
  &lt;li&gt;ajaxComplete[](http://)&lt;/li&gt;
  &lt;li&gt;ajaxError&lt;/li&gt;
  &lt;li&gt;ajaxStop&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;利用这些事件我们可以很容易为请求的各个环节封装相同的响应！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;插件&lt;/h2&gt;

&lt;p&gt;jQuery的插件非常多，再很多地方（比如&lt;a href=&quot;http://www.htmleaf.com/&quot;&gt;这里&lt;/a&gt;）可以搜索，这里主要来看下自己如何造插件，涉及到的方法有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jQuery.extend( target [, object1 ] [, objectN… ] )
jQuery.extend( [ deep ], target , object1 [, objectN… ] )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;该方法用来将一个或者多个对象的成员属性和方法复制到指定的对象上，参数的含义为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;deep&lt;/strong&gt;：是否深度合并对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;target&lt;/strong&gt;：目标对象，其他对象的成员属性将被复制到该对象上&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;object1&lt;/strong&gt;：第一个被合并的对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;objectN&lt;/strong&gt;：第N个被合并的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个用来扩展jQuery对象方法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jQuery.fn.extend( object )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在可以编写插件了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
;(function($){
    // 封装jQuery对象方法
	$.fn.extend({
        &quot;color&quot; : function(value){/* 插件代码 */}
    })
    // 直接对jQuery对象进行扩展
    $.extend({
        ltrim : function(text) {
            return (text || &quot;&quot;)
        }
    })
})(jQuery);
&lt;/pre&gt;

&lt;p&gt;编写一些插件写法需要对jQuery本身的运行的机制由一定的了解~&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;jQuery主要是用来简化开发，对JavaScript做了一些封装，不需要再考虑很多兼容性的东西，而且代码也更加简洁，列出一些参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jquery.cuishifeng.cn/index.html&quot;&gt;api&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.365mini.com/doc&quot;&gt;codeplayer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.htmleaf.com/&quot;&gt;jquery之家&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html&quot;&gt;jquery最佳实践&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html&quot;&gt;jquery设计思想&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 16 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/09/16/Jquery.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/09/16/Jquery.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>Grunt</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://www.gruntjs.net/img/grunt-logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;WHY&lt;/h2&gt;

&lt;p&gt;在用Java写完源码之后需要编译成Class才能执行，其实前端也是类似的，需要压缩等操作才是真正的成品，况且现在前端的工具越来越多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;LESS&lt;/li&gt;
  &lt;li&gt;CoffeeScript&lt;/li&gt;
  &lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些都需要预处理成最终的CSS、JS才能被使用，而GRUNT则将这些过程管理起来，你只需要开开心心写代码就好了~&lt;/p&gt;

&lt;h2 id=&quot;how&quot;&gt;HOW&lt;/h2&gt;

&lt;p&gt;当然首先需要node.js，然后&lt;strong&gt;npm install -g grunt-cli&lt;/strong&gt;安装命令行工具，在工程下面配置两个文件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;package.json&lt;/strong&gt;：被npm用于存储项目元数据，以便将此项目发布为npm模块，可以在这里列出项目依赖的Grunt和Grunt插件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Gruntfile.js&lt;/strong&gt;：用来配置或定义任务并加载Grunt插件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;执行&lt;strong&gt;npm install&lt;/strong&gt;安装项目依赖的库，然后执行&lt;strong&gt;grunt&lt;/strong&gt;即可，package.json配置文件如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
{
    &quot;name&quot;: &quot;my-project-name&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;devDependencies&quot;: {
        &quot;grunt&quot;: &quot;~0.4.5&quot;,
        &quot;grunt-contrib-jshint&quot;: &quot;~0.10.0&quot;,
        &quot;grunt-contrib-nodeunit&quot;: &quot;~0.4.1&quot;,
        &quot;grunt-contrib-uglify&quot;: &quot;~0.5.0&quot;
    }
}
&lt;/pre&gt;

&lt;p&gt;可以通过命令&lt;strong&gt;npm install &amp;lt;module&amp;gt; –save-dev&lt;/strong&gt;安装插件的同时向文件中的devDependencies字段添加，&lt;a href=&quot;http://www.gruntjs.net/plugins&quot;&gt;这里&lt;/a&gt;有插件列表。&lt;/p&gt;

&lt;p&gt;文件Gruntfile.js由三部分组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;配置任务：grunt.initConfig&lt;/li&gt;
  &lt;li&gt;加载插件：grunt.loadNpmTasks&lt;/li&gt;
  &lt;li&gt;定义任务：grunt.registerTask&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本上配置好之后就可以跑起来了，更多看&lt;a href=&quot;http://www.gruntjs.ne&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2015/09/15/Grunt.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2015/09/15/Grunt.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>CSS基础和LESS入门</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s2921314.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看《CSS权威指南》的时候简单的整理了一些&lt;a href=&quot;http://naotu.baidu.com/file/ed1f91b9f4ba914a4d97e404acd71ee3?token=33581ba44ab41688&quot;&gt;笔记&lt;/a&gt;，有些东西比之前有了更深的理解，但是用这么厚的一本书来学CSS多少有些头大，只需要把一些关键的东西理解透彻，具体的设置查&lt;a href=&quot;http://www.w3chtml.com/css3/&quot;&gt;手册&lt;/a&gt;更快！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;布局和定位&lt;/h2&gt;

&lt;p&gt;原生的HTML中元素分为两种：&lt;strong&gt;块级元素&lt;/strong&gt;和&lt;strong&gt;行内元素&lt;/strong&gt;，而CSS中用display来影响元素的展示：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;none&lt;/td&gt;
      &lt;td&gt;隐藏对象并且不会保留物理空间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline&lt;/td&gt;
      &lt;td&gt;行内元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;block&lt;/td&gt;
      &lt;td&gt;块级元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline-block&lt;/td&gt;
      &lt;td&gt;行内块元素，也就是说横着排列的同时可以指定宽高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;box&lt;/td&gt;
      &lt;td&gt;弹性盒子模型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline-box&lt;/td&gt;
      &lt;td&gt;行内弹性盒子，和inline-block有点类似&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;直接使用top、right等是不会起作用的，想要起作用得用position来配合：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;static&lt;/td&gt;
      &lt;td&gt;不使用定位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;relative&lt;/td&gt;
      &lt;td&gt;相对于父节点的位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;absolute&lt;/td&gt;
      &lt;td&gt;绝对定位，会跟滚动条滚动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fixed&lt;/td&gt;
      &lt;td&gt;固定定位，不会跟随滚动&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当用relative有问题的时候可能是你的HTML结构错了导致父节点判断错误导致的:)用display+position可以把一个元素放到你想要的位置，但是一个块也不是简单的长方形，也有其结构：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;margin&lt;/td&gt;
      &lt;td&gt;外补白&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;padding&lt;/td&gt;
      &lt;td&gt;内补白&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;border&lt;/td&gt;
      &lt;td&gt;边框&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;外补白比较特殊一点：取的双方的是max而不是sum，在chrome控制台玩一下就能很好地理解这三个的用法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Css-Less.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直观上背景图片是用来做背景的，但是感觉现在都被大家玩坏了，比如经常把很多的图标放到一个图片上然后用&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
.x {
    background-image:url(img-url);
    background-position:-100px 100px;
}
&lt;/pre&gt;

&lt;p&gt;就可以在对应的DIV中展示出局部图片，这个局部就可能是某个ICON，感觉这完全是在当图片使用额~ 当内容超过限制的时候可以使用&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;overflow&lt;/li&gt;
  &lt;li&gt;overflow-x&lt;/li&gt;
  &lt;li&gt;overflow-y&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来进行控制，但是滚动条的默认样式实在是太丑了，在&lt;a href=&quot;http://www.webhek.com/scrollbar&quot;&gt;这里&lt;/a&gt;找到一种修改的方法，对于&lt;strong&gt;-webkit-&lt;/strong&gt;核的浏览器来说很简单，但是要去兼容IE+FX比较麻烦，可以考虑用&lt;a href=&quot;http://www.jqcool.net/demo/201404/jquery-jscrollpane/&quot;&gt;jQuery插件&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;变换和动画&lt;/h2&gt;

&lt;h2 id=&quot;less&quot;&gt;LESS&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://www.1024i.com/demo/less/images/logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然它的口号是&lt;strong&gt;LESS IS MORE, THAN CSS&lt;/strong&gt;，但是确实感觉LESS是在CSS的基础上增加了一些扩展&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;变量&lt;/li&gt;
  &lt;li&gt;继承&lt;/li&gt;
  &lt;li&gt;嵌套&lt;/li&gt;
  &lt;li&gt;运算&lt;/li&gt;
  &lt;li&gt;函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外LESS实际兼容CSS的（也就是说你可以在里面直接写CSS代码），实际使用时可以在后端将其打包（比如Grunt）成CSS文件之后再提供给前端，具体用法可以看&lt;a href=&quot;http://www.1024i.com/demo/less/index.html&quot;&gt;这里&lt;/a&gt;的中文文档。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Fri, 11 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/11/Css-Less.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/11/Css-Less.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>JavaScript基础知识</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s8958650.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先我并不是一个JavaScript高手，因为工作需要最近才开始学习，虽然之前陆陆续续地零碎看过一些，但是很不系统，这篇文章打算从一个门外汉的角度来分几步看，希望能对初学者有一些帮助~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;基本语法&lt;/h2&gt;

&lt;p&gt;JavaScript是弱类型的，有六种基本类型（用&lt;code&gt;typeof&lt;/code&gt;查看）：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;undefined/null&lt;/td&gt;
      &lt;td&gt;区别看&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html&quot;&gt;这里&lt;/a&gt;，可能结合Map比较好理解一些&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;boolean&lt;/td&gt;
      &lt;td&gt;需要注意从其他类型转换到Boolean的规则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;number&lt;/td&gt;
      &lt;td&gt;整数、浮点数、NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td&gt;字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;数据、对象的集合，是所有对象的基础&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;弱类型的强大之处在于将不同类型的数据进行比较的时候居然结果是一样的：&lt;code&gt;&quot;123&quot;==123&lt;/code&gt;，简直毁三观~~不过也提供了另外一种方式&lt;code&gt;&quot;123&quot;===123&lt;/code&gt;可以得到预期的结果。&lt;/p&gt;

&lt;p&gt;在需要连续操作一个对象的多个属性或者方法时可以用&lt;code&gt;with&lt;/code&gt;减少代码量：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
with(location){
    var a = search.substring(1); // var a = location.search.substring(1)
    var b = hostname;// var b = location.hostname
}
&lt;/pre&gt;

&lt;p&gt;在JavaScript中定义函数非常灵活&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;既不需要定义返回值，也不需要定义入参（简直比弱类型还随意…）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可以使用&lt;code&gt;arguments&lt;/code&gt;来获取所有的参数，这样看来参数的实现和&lt;strong&gt;Python&lt;/strong&gt;有点像，参数名称仅仅是用为了在代码中方便使用参数！&lt;/p&gt;

&lt;p&gt;在JavaScript中几乎所有的都是对象，第一种创建对象的方式为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var Cat = {
    name : '',
    color : ''
}
&lt;/pre&gt;

&lt;p&gt;这种方式在创建多个对象时非常麻烦，另外一种方法是：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function Cat(name, color){
    this.name = name;
    this.color = color;
}
&lt;/pre&gt;

&lt;p&gt;这样在创建对象的时候就很简单了：&lt;code&gt;new Cat('abc', 'white')&lt;/code&gt;，对象中有一些内部属性用来控制其行为：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;内部属性&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;configurable&lt;/td&gt;
      &lt;td&gt;能否通过&lt;code&gt;delete&lt;/code&gt;删除属性从而重新定义属性，能够修改属性的特性或者能否把属性修改为访问器属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;enumerable&lt;/td&gt;
      &lt;td&gt;能否通过&lt;code&gt;for-in&lt;/code&gt;循环返回属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;writable&lt;/td&gt;
      &lt;td&gt;能否修改属性的值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;value&lt;/td&gt;
      &lt;td&gt;包含这个属性的数据值&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var person = {};
Object.defineProperty(person, 'name', {
    writeable: false,
    value: 'abc'
});
&lt;/pre&gt;

&lt;p&gt;另外提供了&lt;code&gt;get、set&lt;/code&gt;方法，有了它们之后就可以很容易监听对象中每个属性的变化，在做数据绑定的时候比较好用：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var person = {name : 'abc'};
Object.defineProperty(person, 'name', {
    get: function(){
        return 'bcd';
    },
    set: function(newValue){
        console.log('hehe');
    }
});
console.log(person.name);// bcd
&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原型&lt;/h2&gt;

&lt;p&gt;习惯了&lt;strong&gt;class based programming&lt;/strong&gt;直接看&lt;strong&gt;prototype based programming&lt;/strong&gt;感觉有点诡异：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们创建的每个函数都有一个prototype属性，指向一个对象，其中包含了可以由特定类型的所有实例共享的属性和方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而作用则是：&lt;strong&gt;从当前对象中获取不到的属性可以尝试从prototype中获取&lt;/strong&gt;，只要记住这一点，很多问题就引刃而解！原型的用法很简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function Person(){}
Person.prototype.name = 'abc';
var person1 = new Person();
console.log(person1.name);//abc
&lt;/pre&gt;

&lt;p&gt;接着来看一些和原型相关的方法：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Person.isPrototypeOf(person1)&lt;/td&gt;
      &lt;td&gt;对象和对象之间是否存在原型链&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Object.getPrototypeOf(person1) == Person&lt;/td&gt;
      &lt;td&gt;获取原型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Person.prototype.constructor&lt;/td&gt;
      &lt;td&gt;指向prototype属性所在函数的指针（也就是构造函数）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;person1.hasOwnProperty(‘name’)&lt;/td&gt;
      &lt;td&gt;是否自己真的有，而不是从原型中获取&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;person1 instanceof Object&lt;/td&gt;
      &lt;td&gt;是否为指定类型&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以用原型来实现类似继承效果，直接设置prototype比较麻烦，最好封装一下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
var person = {
    name : 'abc'
}
var another_person = object(person);
&lt;/pre&gt;

&lt;p&gt;另外一种常见的写法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function extend(Child, Parent) {
    var F = function(){};
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.prototype.constructor = Child;
    Child.uber = Parent.prototype;
}
&lt;/pre&gt;

&lt;p&gt;其实原型就是原型，它本身的含义已经非常明确，如果非要和其他编程语言中的概念去做对比就容易把自己绕进去~&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html&quot;&gt;Javascript面向对象编程（一）：封装&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html&quot;&gt;Javascript面向对象编程（二）：构造函数的继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html&quot;&gt;Javascript面向对象编程（三）：非构造函数的继承&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/web/1304_zengyz_jsoo/&quot;&gt;全面理解面向对象的 JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;闭包&lt;/h2&gt;

&lt;p&gt;闭包是一个既神秘又绕，但其本质又非常简单的一个概念：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有权访问另一个函数作用域中的变量的函数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;赶紧来看一个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function createFunctions(){
    var result = new Array();
    for(var i = 0; i &amp;lt; 10; i++){
        result[i] = function(){
            return i;// 注意这里，访问了外部函数中的变量
        };
    }
    return result;
}
&lt;/pre&gt;

&lt;p&gt;直观感觉&lt;code&gt;result[0]()&lt;/code&gt;的返回值应该是0，实际上并非如此，内部函数可以访问外部函数作用域中的变量，但仅仅是包含一个引用而已，具体到执行的时候才去获取引用指向的值。&lt;/p&gt;

&lt;p&gt;闭包绕就绕在作用域上，当它和其他作用域也比较绕的东西勾搭在一起的时候就需要小心了，比如this：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当方法被某个对象调用时，this就等于那个对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们来比较下面两段代码体会一下就好了，第一段：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var name = &quot;the window&quot;;
var obj = {
    name : &quot;my object&quot;,
    getNameFunc : function(){
        return function(){
            return this.name;
        }
    }
}
console.log(obj.getNameFunc()()); // the window
&lt;/pre&gt;

&lt;p&gt;第二段：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var name = &quot;the window&quot;;
var obj = {
    name : &quot;my object&quot;,
    getNameFunc : function(){
    	var self = this;
        return function(){
            return self.name;
        }
    }
}
console.log(obj.getNameFunc()()); // my object
&lt;/pre&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html&quot;&gt;Javascript的this用法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html&quot;&gt;学习Javascript闭包（Closure）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.gracecode.com/posts/2385.html&quot;&gt;闭包的秘密&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;Private Members in JavaScript&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dombom&quot;&gt;DOM和BOM&lt;/h2&gt;

&lt;p&gt;作为网页脚本语言，需要频繁地和浏览器、文档打交道，&lt;strong&gt;BOM&lt;/strong&gt;提供了对象用来访问浏览器的功能：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;对象&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;window&lt;/td&gt;
      &lt;td&gt;提供浏览器大小、位置以及很多基础方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;localtion&lt;/td&gt;
      &lt;td&gt;加载文档的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;navigator&lt;/td&gt;
      &lt;td&gt;用来识别浏览器、检测插件、注册处理程序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;screen&lt;/td&gt;
      &lt;td&gt;显示器像素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;history&lt;/td&gt;
      &lt;td&gt;浏览器历史&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;而&lt;strong&gt;DOM&lt;/strong&gt;则是一个多层结构，其中节点类型包括：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Node&lt;/td&gt;
      &lt;td&gt;基类，统一维护了节点的层次结构&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Document&lt;/td&gt;
      &lt;td&gt;文档，提供读、写元素的操作，在JavaScript操作文档时经常用到&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Element&lt;/td&gt;
      &lt;td&gt;元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;文本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Comment&lt;/td&gt;
      &lt;td&gt;注释&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CDATASection&lt;/td&gt;
      &lt;td&gt;XML中的CDATA(这个就不用多说了)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DocumentType&lt;/td&gt;
      &lt;td&gt;文档类型，能够影响到浏览器渲染时的行为(一个热乎的坑)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Attr&lt;/td&gt;
      &lt;td&gt;元素的特性&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在判断节点类型中经常会用到&lt;code&gt;nodeName&lt;/code&gt;和&lt;code&gt;nodeType&lt;/code&gt;，另外有一个属性&lt;code&gt;childNodes&lt;/code&gt;保存子节点：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NodeList对象并不是Array，而是基于DOM结构动态查询得到的结果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他属性（以及其他类型节点特有的属性）就不一一说了，直接用一个图来描述：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JavaScript-Basic-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用jQuery操作DOM很方便的一个原因是CSS选择器，其实在原生的JavaScript中也有类似的接口：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;接口&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;querySelector&lt;/td&gt;
      &lt;td&gt;接收一个CSS选择符，返回与该模式匹配的第一个元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;querySelectorAll&lt;/td&gt;
      &lt;td&gt;返回所有匹配CSS选择符的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;matchesSelector&lt;/td&gt;
      &lt;td&gt;检测元素与CSS选择符是否匹配&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;HTML5规定可以为元素添加非标准的属性，但是要添加前缀&lt;code&gt;data-&lt;/code&gt;，目的是为元素提供渲染无关的信息，访问时可以使用&lt;code&gt;dataset&lt;/code&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;div id=&quot;myDiv&quot; data-appId=&quot;abc&quot; data-myName=&quot;bcd&quot;&amp;gt;&amp;lt;div&amp;gt;
var div = document.getElementById(&quot;myDiv&quot;);
var appId = div.dataset.appId;
var myName = div.dataset.myName;
&lt;/pre&gt;

&lt;h2 id=&quot;section-3&quot;&gt;事件&lt;/h2&gt;

&lt;p&gt;JavaScript可以操作DOM，反过来DOM也可以调用JavaScript，通过事件来实现，第一种绑定方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(){
    alert(&quot;Clicked&quot;);
}
&lt;/pre&gt;

&lt;p&gt;第二种绑定方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var btn = document.getElementById(&quot;myBtn&quot;);
btn.addEventListener(&quot;click&quot;, function(){
    alert(this.id);
}, false);
&lt;/pre&gt;

&lt;p&gt;在事件中最核心的两个概念是：&lt;strong&gt;捕获&lt;/strong&gt;和&lt;strong&gt;冒泡&lt;/strong&gt;，冒泡是指事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JavaScript-Basic-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另一种事件流就是捕获了：不太具体的节点更早地接收到事件，而最具体的节点最后收到事件，事件捕获的用意在于事件到达预定节点之前捕获它：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JavaScript-Basic-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了阻止事件的向上冒泡常用的方法有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;return false&lt;/td&gt;
      &lt;td&gt;阻止触发事件的元素的默认动作，并且阻止冒泡&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;preventDefault&lt;/td&gt;
      &lt;td&gt;阻止默认动作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;stopPragation&lt;/td&gt;
      &lt;td&gt;阻止冒泡&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最后，可以通过模拟事件来实现快捷键的功能~~&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/wang_yb/archive/2013/04/11/3014767.html&quot;&gt;javascript中return false;preventDefault();stopPragation()的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-4&quot;&gt;通信&lt;/h2&gt;

&lt;p&gt;网页和服务器异步通信的功能是必不可少的，代码如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(){ // 监听状态发生变化
    if(xhr.readyState == 4){// 完成
        if((xhr.status &amp;gt;= 200 &amp;amp;&amp;amp; xhr.status &amp;lt; 300) || xhr.status == 304){
            alert(xhr.responseText);
        } else{
            alert(xhr.status);
        }
    }
}
xhr.open(&quot;get&quot;, &quot;xxx.xxx.com&quot;, true);
xhr.send(null);
&lt;/pre&gt;

&lt;p&gt;JavaScript对请求限制必须是相同域名的（为了安全），但是跨域的需求也是刚需，那么大家只能八仙过海各显神通，常见的方式有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;图像Ping&lt;/li&gt;
  &lt;li&gt;JSONP&lt;/li&gt;
  &lt;li&gt;Comet&lt;/li&gt;
  &lt;li&gt;服务器发送事件（SSE）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;既然禁止跨域并不是合理的，那么就需要提供一套能够安全跨域的方案，于是有了CORS：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;发送请求时将页面的源信息设置到Origin中，服务器根据Origin来判断是否允许访问，如果允许，那么在返回的头中设置Access-Control-Allow-Origin&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;与源信息匹配或者其值为*的时候，浏览器就允许跨域访问了！&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS&quot;&gt;HTTP访问控制(CORS)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://yuguo.us/weblog/access-control-allow-origin/&quot;&gt;自定义Access-Control-Allow-Origin策略以解决字体文件跨域权限问题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-5&quot;&gt;离线&lt;/h2&gt;

&lt;p&gt;当在离线的情况下依然可以访问网页，那么Web页面和App的距离就更近一步了，而且HTML5中已经实现了，对于资源缓存使用&lt;code&gt;manifest&lt;/code&gt;搞定：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;html manifest=&quot;/example/demo.manifest&quot;&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在该文件中指定页面中资源的缓存策略：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
CACHE MANIFEST # 缓存的文件
CACHE
/theme.css
/logo.gif
/main.js
NETWORK: # 不缓存的文件
login.asp
FALLBACK: # 没有网络时的替代网页
/html5/ /404.html
&lt;/pre&gt;

&lt;p&gt;另外提供对应的JavaScript API &lt;code&gt;applicationCache&lt;/code&gt;来查看缓存的状态：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;状态值&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;无缓存，没有与页面相关的缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;闲置，应用缓存未得到更新&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;检查中，正在下载描述文件并检查更新&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;下载中，应用缓存正在下载描述文件中指定的资源&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;更新完成，应用缓存已经更新，而且所有的资源已下载完毕，可以通过swapCache来使用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;废弃，应用缓存的描述文件已经不存在，页面无法访问应用缓存&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;应用缓存还有相关的事件来表示状态的改变：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;事件&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;checking&lt;/td&gt;
      &lt;td&gt;浏览器为应用缓存查找更新时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;error&lt;/td&gt;
      &lt;td&gt;检查更新或下载资源期间发生错误时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;noupdate&lt;/td&gt;
      &lt;td&gt;检查描述文件发现无变化时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;downloading&lt;/td&gt;
      &lt;td&gt;开始下载应用缓存资源时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;progress&lt;/td&gt;
      &lt;td&gt;下载的应用缓存的过程中不断地触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;updateready&lt;/td&gt;
      &lt;td&gt;页面新的应用缓存下载完毕并且可以通过swapCache使用时触发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cached&lt;/td&gt;
      &lt;td&gt;在应用缓存完整可用时触发&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;需要注意应用缓存机制会自动缓存引用了manifest的页面，那么这个页面在manifest文件没有发生变更的情况下会一直保持不变，这个可以用一个&lt;code&gt;iframe&lt;/code&gt;间接缓存来解决。&lt;/p&gt;

&lt;p&gt;除了js、css等资源外还有其他数据需要缓存的话可以用下面几种方案来解决：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Cookie&lt;/li&gt;
  &lt;li&gt;Web Storage&lt;/li&gt;
  &lt;li&gt;IndexedDB&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这部分就略了。&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/web/1011_guozb_html5off/&quot;&gt;使用 HTML5 开发离线应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://foocoder.com/blog/web-appzhi-nan-zhi-gou-jian-html5chi-xian-ying-yong.html/&quot;&gt;Web App指南之构建html5离线应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://kb.cnblogs.com/page/76808/&quot;&gt;HTML5 缓存: cache manifest&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-6&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这篇笔记仅仅是对常用的功能做一些记录，另外对于CANVAS绘画等技术后面会有单独的文章来进行介绍，最后再次推荐《JavaScript高级程序设计》~~&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/09/JavaScript-Basic.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/09/JavaScript-Basic.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>解决运行Groovy脚本中的问题</title>
        <description>&lt;p&gt;在需要灵活配置时Groovy通常时一个不错的选择，但是问题比较多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;效率&lt;/li&gt;
  &lt;li&gt;垃圾回收&lt;/li&gt;
  &lt;li&gt;死循环&lt;/li&gt;
  &lt;li&gt;调用System.exit()等不安全的方法&lt;/li&gt;
  &lt;li&gt;拼命申请内存导致OOM：现在没有想到方案&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一、二中已经有比较成熟的方案，但是后面的两个问题就不那么好解决了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;死循环&lt;/h2&gt;

&lt;p&gt;执行Groovy脚本的时候我用的是下面的方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Class clazz = new GroovyClassLoader().parseClass(&quot;your code&quot;);
Method method = clazz.getMethod(&quot;xxxx&quot;);
method.invoke(null);
&lt;/pre&gt;

&lt;p&gt;如果用户编写的脚本是（能用技术解决的东西最好不要用价值观来保证）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
while(true){
	// do nothing.
}
&lt;/pre&gt;

&lt;p&gt;机器的CPU马上会飚的很高，可能你会想到用&lt;strong&gt;Thread.stop()&lt;/strong&gt;来终止这个罪恶的脚本，但是对于这个脚本：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
while(true){
	try{/* your code */}
    catch(Exception e){ }
}
&lt;/pre&gt;

&lt;p&gt;只能说根本停不下来。因为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thread.stop()仅仅是在线程的任意位置抛出ThreadDeath异常。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;况且Thread.stop很早就不建议使用了，而是用&lt;strong&gt;Thread.interrupt()&lt;/strong&gt;，但是简单来说中断仅仅是去通知一下目标线程，而不是真的去停掉它。&lt;/p&gt;

&lt;p&gt;那么，现在的目标就是如何将中断检查的代码插入到用户编写的脚本中：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void checkInterrupted() {
    if (Thread.currentThread().isInterrupted()) {
        throw new RuntimeException(&quot;task is interrupted!&quot;);
    }
}
&lt;/pre&gt;

&lt;p&gt;将输入的脚本作为字符串来处理，估计会累到吐血！接着自然想到先将源码结构化，那么自然想到在编译的过程中对语法树进行操作即可达到目的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static class SafeGroovyClassLoader extends GroovyClassLoader {
    protected CompilationUnit createCompilationUnit(CompilerConfiguration config, CodeSource source) {
    CompilationUnit compilationUnit = super.createCompilationUnit(config, source);
    compilationUnit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() {
        public void call(SourceUnit source) throws CompilationFailedException {
            ModuleNode ast = source.getAST();
            // 自定义visitor来操作
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;遍历时我们需要处理的节点包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;FOR&lt;/li&gt;
  &lt;li&gt;WHILE&lt;/li&gt;
  &lt;li&gt;DOWHILE&lt;/li&gt;
  &lt;li&gt;CATCH&lt;/li&gt;
  &lt;li&gt;FINALLY&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在这些块的开始位置插入&lt;strong&gt;checkInterrupted&lt;/strong&gt;方法的调用：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
private BlockStatement createCheckBlock(Statement statement) {
    if (statement instanceof BlockStatement) {
        BlockStatement blockStatement = (BlockStatement) statement;
        blockStatement.getStatements().add(0, checkInterruptedStatement);
        return blockStatement;
    } else if (statement instanceof EmptyStatement) {
        BlockStatement blockStatement = new BlockStatement();
        blockStatement.getStatements().add(checkInterruptedStatement);
        return blockStatement;
    } else {
        BlockStatement blockStatement = new BlockStatement();
        blockStatement.getStatements().add(checkInterruptedStatement);
        blockStatement.getStatements().add(statement);
        return blockStatement;
    }
}

public void visitCatchStatement(CatchStatement catchStatement) {
    catchStatement.getCode().visit(this);
    catchStatement.setCode(createCheckBlock(catchStatement.getCode()));
}
&lt;/pre&gt;

&lt;p&gt;你想的话可以在checkInterrupted中加入循环次数统计。现在线程可以中断，貌似问题已经解决了，但是谁来中断他？有三种方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用线程池来运行脚本，在外面用Future.get来等待（超时中断）&lt;/li&gt;
  &lt;li&gt;创建一个线程来join当前线程（超时中断）&lt;/li&gt;
  &lt;li&gt;执行任务前将当前线程插入到map中，然后用一个定时任务来扫描并将超时的中断&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一、二种方案每个请求都会创建多余一个线程（不划算），那就来看看第三种方案的实现方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 保存线程开始时间
Map&amp;lt;Thread, Long&amp;gt; threadCache = Maps.newHashMap();
// 执行前将线程插入
threadCache.put(Thread.currentThread(), System.currentTimeMillis());
// 遍历threadCache根据时间判断是否中断
&lt;/pre&gt;

&lt;p&gt;这种方案实现起来要好好考虑一下同步的问题！&lt;/p&gt;

&lt;h2 id=&quot;systemexit&quot;&gt;System.exit&lt;/h2&gt;

&lt;p&gt;在不做限制的情况下，执行上面方法系统直接就停止了，怎么办？办法很简单（当然不是靠价值观）：建立黑名单，在遍历语法树时是否调用了黑名单中的方法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;应用这么多，可能大家都需要用到一些脚本的功能，但是能也没有比较把这些都再各个系统里面去实现一把（没啥意义），如果有这么一个打通脚本与应用、数据的平台也不错！&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/08/Groovy.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/08/Groovy.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>编程语言实现模式</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img4.douban.com/mpic/s7661036.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很久之前已经把这本书看过一遍了，但是一直没有实践过!于是，拿出来再复习一遍，顺便记录笔记。关于这本书有几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ANTLR贯穿全书：作者是&lt;strong&gt;Terence Parr&lt;/strong&gt;，这点也就不奇怪了&lt;/li&gt;
  &lt;li&gt;ANTLR生成的代码是LL(K)的&lt;/li&gt;
  &lt;li&gt;偏重实践，原理很少，想看原理要去看&lt;a href=&quot;http://img3.douban.com/mpic/s3392161.jpg&quot;&gt;龙书&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，你应该先知道编译的过程大概分成哪几步骤以及为什么这样划分！废话少说，来看这本书的内容。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;解析输入&lt;/h2&gt;

&lt;p&gt;词法分析和语法分析很多地方都是相同的，解析器结构如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class G extends Parser {
    // 类型定义
    // 合适的构造函数
    // 规则对应的方法
}
&lt;/pre&gt;

&lt;p&gt;在一个规则中包含很多子规则时，根据向前看符号来决定使用哪个，这个逻辑的代码描述可以用if-else来做：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
if(向前看到alt1){
    // 匹配alt1
} else if(向前看到alt2){
    // 匹配alt1
}....
&lt;/pre&gt;

&lt;p&gt;当然这里也可以用switch做，在规则上定义的一些常见操作有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;(T)?：T可有可无&lt;/li&gt;
  &lt;li&gt;(T)+：多个T&lt;/li&gt;
  &lt;li&gt;(T)*：零个或多个T&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些操作的代码描述：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// (T)?
if(向前看到T){ match(T);}
// (T)+
do{
    match(T);
} while(向前看到T)
// (T)*
while(向前看到T){
    match(T);
}
&lt;/pre&gt;

&lt;p&gt;能利用好这三个操作大部分的规则都可以搞定了！词法分析相对语法分析了来说简单很多，Lexer会提供&lt;strong&gt;nextToken()&lt;/strong&gt;来供Parser使用来不断地获取TOKEN：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public Token nextToken(){
    while(lookahead-char != EOF) {
        switch(lookahead-char){
            case 空白字符: { consume(); continue; }
            case 字符后面可能是T1: return T1();
            case 字符后面可能是T2: return T2();
			// ...
            default:
                出错;
        }
    }
    return EOF;
}
&lt;/pre&gt;

&lt;p&gt;直观上来看用switch进行预测，相当于构造了一个状态机吧，其中&lt;strong&gt;consume()&lt;/strong&gt;方法自增下标并将下一个字符当做向前看字符（消费字符）。在仅使用一个向前看符来进行语法分析时，也就是LL(1)，对于下面语法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
list : '[' elements ']';
elements : element (',' element)*;
element : NAME | list;
&lt;/pre&gt;

&lt;p&gt;生成的Paser如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class ListParser extends Parser {
    public void list(){
        match(ListLexer.LBRACK); // 匹配并消耗词法单元
        elements();
        match(ListLexer.RBRACK);
    }
    public void elements(){
        element();
        while(lookahead.type == ListLexer.COMMA) {
            match(ListLexer.COMMA);
            element();
        }
    }
    public void element(){
        if(lookahead.type == ListLexer.NAME) match(ListLexer.NAME);
        else if(lookahead.type == ListLexer.LBRACK) list();
        else throw new Error(&quot;语法错误&quot;);
    }
}
&lt;/pre&gt;

&lt;p&gt;很简单的语法用LL(1)是没有问题的，对于稍微复杂一点的其预测能力差就暴露出来了，怎么办？当然是多拿几个进行预测！可以构造环形缓冲区来存放用来预测的TOKEN，另外增加两个方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;LA&lt;/strong&gt;：返回第k个向前看词法单元的类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LT&lt;/strong&gt;：返回第k个词法单元&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么文法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
element : NAME '=' NAME : NAME : list ;
&lt;/pre&gt;

&lt;p&gt;对应的程序描述就变为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void element(){
    if(LA(1) == LookaheadLexer.NAME &amp;amp;&amp;amp; LA(2) == LookaheadLexer.EQUALS) {
        match(LookaheadLexer.NAME);
        match(LookaheadLexer.EQUALS);
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.NAME) {
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.LBACK) {
        list();
    } else {
        throw new Error(&quot;语法错误!&quot;);
    }
}
&lt;/pre&gt;

&lt;p&gt;但是LL(K)也不是万能的，如果向前看k个解决不了问题，那么向前无限个总应该可以搞定了吧？回溯解析中使用递归尝试不同的规则，在发现无法匹配时把消费掉的TOKEN吐出来：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void rule() {
    if(speculate_alt1()){
        // 匹配alt1
    } else if(speculate_alt2()){
        // 匹配alt2
    } else { throw new Error(&quot;语法错误！&quot;); }
}
public boolean speculate_alt1() {
    boolean success = true;
    mark();// 标记当前位置，供release使用
    try{
        // 匹配alt1
    } catch(Exception e){ success = false; }
    release();// 将消费掉的TOKEN重新放回去
    return success;
}
&lt;/pre&gt;

&lt;p&gt;回溯解析最大的缺陷就是性能低，而其中一个原因则是做了不少重复工作，对于语法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
s : expr ':' | expr ';';
&lt;/pre&gt;

&lt;p&gt;在尝试第一个子规则失败时会去尝试第二个，那么expr就会被匹配两次！如果能把之前匹配过的结果记住就好了（参考&lt;a href=&quot;http://www.cnblogs.com/kedebug/archive/2013/04/07/3006493.html&quot;&gt;记忆化搜索&lt;/a&gt;），此时仅需要做一些很小的修改：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 每个规则有一个Map来保存结果
Map&amp;lt;Integer, Integer&amp;gt; list_memo = new HashMap&amp;lt;Integer, Integer&amp;gt;;
public void list(){
    boolean failed = false;
    int startTokenIndex = index();
    if(isSpeculating() &amp;amp;&amp;amp; aleadyParsedRule(list_memo)) return;
	try{_list();}
    catch(Exception e) {failed = true; throw e; }
    finally{
         if(isSpeculating())
             memoize(list_memo, startTokenIndex, failed);
    }
}
public void _list(){
    match(XXX);
    elements();
    match(XXX);
}
&lt;/pre&gt;

&lt;p&gt;简单说明下上面用到的几个方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;aleadyParsedRule&lt;/strong&gt;：使用缓存的结果：成功返回TRUE、失败抛异常、未处理过返回FALSE&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;memoize&lt;/strong&gt;：回溯时将结果记录到缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外需要清楚一个细节：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;推演时没有通过的try-catch逻辑在非推演时更不可能走到！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，在遇到上下文相关的语法时使用谓词是个不错的选择，用代码描述就是增加条件：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void rule(){
    if(向前看符号测试alt1 &amp;amp;&amp;amp; 谓词1) {
        // 匹配alt1
    } else if(向前看符号测试alt2 &amp;amp;&amp;amp; 谓词2) {
        // 匹配alt2
    } ...
}
while(对循环的alt进行向前看符号判断 &amp;amp;&amp;amp; 谓词判断) {
    子规则的代码用来匹配alt
}
&lt;/pre&gt;

&lt;p&gt;到这里解析输入的逻辑基本上就看完了，简单来说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Lexer产出Token流&lt;/li&gt;
  &lt;li&gt;Parser产出方法执行流&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来我们就需要在Parser产出的方法执行流上面来进行分析。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析输入&lt;/h2&gt;

&lt;p&gt;将源码结构化时一般用到两种方式：&lt;strong&gt;语法分析树&lt;/strong&gt;和&lt;strong&gt;抽象语法树&lt;/strong&gt;，从三个方面来看：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;紧凑：不含无用节点&lt;/li&gt;
  &lt;li&gt;易用：很容易遍历&lt;/li&gt;
  &lt;li&gt;显意：突出操作符、操作对象，以及它们互相间的关系，不再拘泥于文法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抽象语法树都要更优秀一些！程序实现时，我们在Parser匹配的过程中向方法中插入一些代码即可得到想要的树形结构：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void rule(){
    RuleNode r = new RuleNode(&quot;规则名&quot;);
    if(root == null) root = r;
    else currentNode.addChild(r);
    ParseTree _save = currentNode;
    // 原始的规则代码
    currentNode = _save;
}
&lt;/pre&gt;

&lt;p&gt;要比想象的简单很多，因为在LL的解析中：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;解析过程就可以看做是在语法分析树上做DFS，任意当前树节点的父亲必然是前面遍历过的某个节点！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同实现节点的方式后续树的遍历等都是有影响的，有如下方式：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;同型AST&lt;/td&gt;
      &lt;td&gt;只有一种节点类型AST，要依据TOKEN来区分不同类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;规范异型AST&lt;/td&gt;
      &lt;td&gt;从基类AST派生不同的节点类型，子节点列表统一&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;不规范异型AST&lt;/td&gt;
      &lt;td&gt;可以添加不同的子节点属性，能够让代码的可读性更高&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;好不容易拿到树形结构了，遍历它也不是一个轻松的活。回想大学用Java写二叉树遍历的时候通常是这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Node {
    Node left, right;
    void visit(){
        left.visit();
        right.visit();
    }
}
&lt;/pre&gt;

&lt;p&gt;把遍历操作嵌入节点内部最明显的缺点是：&lt;strong&gt;逻辑散落在各节点中操作起来很麻烦&lt;/strong&gt;，可以将遍历操作统一放到一个地方：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public abstract class VecMathNode extends HeteroAST {
    public abstract void visit(VecMathVisitor visitor);
}
public interface VecMathVisitor {
    void visit(AssignNode n);
    void visit(PrintNode n);
    void visit(StatListNode n);
    void visit(VarNode n);
    // ...
}
&lt;/pre&gt;

&lt;p&gt;在实现的时候在Visitor中将&lt;strong&gt;this&lt;/strong&gt;传递就可以达到遍历的目的了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class PrintVisitor implements VecMathVisitor {
    public void visit(AssignNode n){
        n.id.visit(this);// 看这里
        System.out.print(&quot;=&quot;);
        n.value.visit(this);
    }
}
&lt;/pre&gt;

&lt;p&gt;提到外面代码量并没有减少，但是这种代码很有规律，ANTLR可以大幅度地减少你的工作量！当然还有其他的方式来实现相同的目的，这里就不啰嗦了。&lt;/p&gt;

&lt;p&gt;遍历语法树的过程中要和两个东西打交道：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;操作&lt;/li&gt;
  &lt;li&gt;符号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;操作很简单，把子节点收集起来进行计算、处理就行了，但是符号就没那么随意，关键就是&lt;strong&gt;作用域&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 1
int x;
void f(){ // 2
    int y;
    { int i; } // 3
    { int j; } // 4
}
void g(){ // 5
    int i;
}
&lt;/pre&gt;

&lt;p&gt;嵌套的作用域更加容易理解，嵌套关系可以用树形结构来表示（这种作用域的特点是只有一个父节点），上面这段代码生成的作用域如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在遍历树的时候用一个栈来保存能访问到的作用域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-2.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个过程中用到的操作有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;push&lt;/td&gt;
      &lt;td&gt;向栈中压入作用域&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pop&lt;/td&gt;
      &lt;td&gt;作用域结束后，要将当前的作用域弹出栈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;def&lt;/td&gt;
      &lt;td&gt;在当前作用域中定义符号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;resolve&lt;/td&gt;
      &lt;td&gt;解析符号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;面向过程的变成语言很简单，这些已经够了，但是在面向对象编程的时候就不行了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 1 全局
class A {// 2
public :
    int x;
    void foo()// 3
    { ; } // 4
}
class B : public A {// 5
    int y;
    void foo()// 6
    {// 7
        int z =  x + y;
    }
}
&lt;/pre&gt;

&lt;p&gt;由于继承关系的存在，在查找符号的时候不仅是要在当前类中找，而且要去父类中找，也就是说此时的父节点就不止一个了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-3.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于像&lt;strong&gt;a.x = 3&lt;/strong&gt;这种访问对象属性的行为就不能按照上面套路来了，需要增加一个操作：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;resolveMemeber&lt;/td&gt;
      &lt;td&gt;解析成员，只会根据superClass递归查找&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;到这里还没完，Java中的Class的定义可以在使用之前，那么在上面的处理属性引用时发现还没定义！直观的解决方法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;预先遍历一次来定义类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里要小心处理好符号和作用域的关系。有了作用域和符号表之后需要对其进行简单的分析：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;计算表达式类型&lt;/td&gt;
      &lt;td&gt;操作的返回结果&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;自动类型提升&lt;/td&gt;
      &lt;td&gt;根据操作的对象来决定是否需要对其中低等级的进行提升&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;静态类型检查&lt;/td&gt;
      &lt;td&gt;操作的对象类型是否合法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;多态类型检查&lt;/td&gt;
      &lt;td&gt;面向对象中的父子关系&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;简单来说都是在遍历AST的时候完成的，下面来看如何运行程序~~&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;解释执行&lt;/h2&gt;

&lt;p&gt;经过上面这些步骤我们已经知道了源码所要表达的意思，那么就可以用代码来实现其逻辑（也就是解释执行），根据实现方式区分有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;语法制导解释器&lt;/strong&gt;：不会生成AST，在解析源码的过程中完成；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;基于树的解释器&lt;/strong&gt;：先构建AST，在遍历的过程中完成执行；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种方式很好理解，用1+2*3的例子玩一玩就可以了，感觉这部分讲的有点啰嗦。用上面的方式执行优点简单、粗暴，缺点是耦合太强了，为了化解便有了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;字节码汇编器&lt;/strong&gt;：将便于阅读的汇编语言翻译为二进制形式的字节码指令；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;栈式解释器&lt;/strong&gt;：执行指令时使用操作数栈存放临时变量；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;寄存器解释器&lt;/strong&gt;：执行指令时使用虚拟寄存器存放参数、局部变量和临时变量；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用中间指令（也可以理解为原子API）作为过渡，这样以后再有其他的DSL来了，只需要将其翻译为这种中间指令就可以了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;生成输出&lt;/h2&gt;

&lt;p&gt;要让自己定义的DSL可执行最简单的办法就是将其翻译为现有的一种语言，和各种CC干的差不多：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;比如ANTLR就是讲文法翻译为Java代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;语法制导&lt;/strong&gt;是最简单的方案，读入内容在解析的过程中完成输出，无法处理前向引用：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-4.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而&lt;strong&gt;基于规则&lt;/strong&gt;则是专注于指定一条一条的规则，在匹配到某条规则的时候执行（输出）对应的操作：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-5.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;工业界普遍流行的是&lt;strong&gt;模型驱动&lt;/strong&gt;翻译，先创建AST，然后在遍历的过程中生成代码：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-6.JPG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于简单的DSL可以使用模板（比如Velocity）来简化输出，但是难点并不在这里。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;这本书对于想实现DSL的人来说还是挺有作用的：例子、代码实现，但是想要学习理论的恐怕要失望了，因为这里几乎是没有的。&lt;/p&gt;

&lt;p&gt;看到网上有人评价这本书能超过龙书，不知道是从哪里看出来的，类型差别这么大如何比较的？&lt;/p&gt;
</description>
        <pubDate>Sun, 06 Sep 2015 00:00:00 +0800</pubDate>
        <link>/dsl/2015/09/06/Language-Implementation-Patterns.html</link>
        <guid isPermaLink="true">/dsl/2015/09/06/Language-Implementation-Patterns.html</guid>
        
        
        <category>dsl</category>
        
      </item>
    
      <item>
        <title>JavaScript模块化及SEA.JS的使用</title>
        <description>&lt;p&gt;最近因为缺前端，不得已要自学一下，囧~ 偶然在看到阮一峰很久之前关于模块化的文章：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&quot;&gt;模块的写法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html&quot;&gt;AMD规范&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/11/require_js.html&quot;&gt;require.js的用法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看完之后用来下玉伯的sea.js，感觉比较给力。&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;WHY&lt;/h2&gt;

&lt;p&gt;工程中前端开发的代码量早已与后端代码量差不了太多，如果将所有代码放到单个文件中是个头疼的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局变量互相影响&lt;/li&gt;
  &lt;li&gt;JS文件变大影响加载速度&lt;/li&gt;
  &lt;li&gt;结构混乱&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是比较悲剧：在JavaScript中并没有提供类、模块等封装的方法，那么就需要我们想办法利用现有的东西来做模块化。2009年Ryan Dahl创建了&lt;strong&gt;node.js&lt;/strong&gt;项目，将javascript用于服务器端编程，这标志”Javascript模块化编程”正式诞生。&lt;/p&gt;

&lt;h2 id=&quot;how&quot;&gt;HOW&lt;/h2&gt;

&lt;p&gt;为了避免上面的缺点以及为了不暴露私有成员，通常用&lt;a href=&quot;http://blog.csdn.net/qq838419230/article/details/8030078&quot;&gt;立即执行函数&lt;/a&gt;来搞定模块化的定义模块：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var module1 = (function(){
    var _count = 0;
    var m1 = function(){
        //...
    };
    var m2 = function(){
        //...
    };
    return {
        m1 : m1, m2 : m2
    };
})();
&lt;/pre&gt;

&lt;p&gt;大家定义出来的模块可能五花八门，如果都用统一的形式来定义那就可以很方便的引用了。目前常用规范有两种：&lt;strong&gt;CommonJS&lt;/strong&gt;和&lt;strong&gt;AMD&lt;/strong&gt;，node.js的模块系统就是参照CommonJS来实现的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var math = require('math');// 全局的require方法用来加载模块
math.add(2,3);
&lt;/pre&gt;

&lt;p&gt;其中math.add(2,3)要等到require完成之后才能执行，也就是说这是一个&lt;strong&gt;同步&lt;/strong&gt;的过程，在网络不好的环境中浏览器就会进入假死状态，体验极差，为了解决这个问题我们来看&lt;strong&gt;异步&lt;/strong&gt;的AMD规范(require.js)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
require(['math'], function (math) {// require([module], callback);
    math.add(2, 3);
});
&lt;/pre&gt;

&lt;p&gt;参数module是要加载模块的列表，callback则是加载成功之后回调函数。AMD规范中模块的写法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// math.js
define(function (){
    var add = function (x,y){
        return x+y;
    };
    return { add: add };
});
&lt;/pre&gt;

&lt;p&gt;另外可以用require.js来加载非规范AMD模块、文本、图片等，感觉略强大。&lt;/p&gt;

&lt;h2 id=&quot;seajs&quot;&gt;SEA.JS&lt;/h2&gt;

&lt;p&gt;CMD是sea.js使用的规范(所以这个术语貌似只有国人知道)，模块定义如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
define(function(require, exports, module) {
    var a = require('./a');
    a.doSomething();
    var b = require('./b');
    b.doSomething();
});
&lt;/pre&gt;

&lt;p&gt;是不是和AMD很像？通过&lt;strong&gt;require&lt;/strong&gt;在需要的时候引入依赖，通过&lt;strong&gt;exports&lt;/strong&gt;来暴露接口。AMD和CMD的区别可以看&lt;a href=&quot;http://www.zhihu.com/question/20351507/answer/14859415&quot;&gt;这里&lt;/a&gt;，还有&lt;a href=&quot;http://blog.chinaunix.net/uid-26672038-id-4112229.html&quot;&gt;这里&lt;/a&gt;。sea.js中常用的API有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/262&quot;&gt;seajs.config&lt;/a&gt;：配制&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/260&quot;&gt;seajs.use&lt;/a&gt;：在页面上加载模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;define&lt;/a&gt;：定义模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/259&quot;&gt;require&lt;/a&gt;：获取指定模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;require.async&lt;/a&gt;：在模块内部异步加载一个或多个模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;exports&lt;/a&gt;：在模块内部对外提供接口&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;module.exports&lt;/a&gt;：在模块内部对外提供接口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些API已经定义的足够简单，因此，例子就忽略了（你可以看&lt;a href=&quot;http://&quot;&gt;这里&lt;/a&gt;）。。。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;简单看下来，感觉很受用！不过…模块化的趋势貌似是&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/intro&quot;&gt;ECMAScript 6&lt;/a&gt;，ES6的目标是让JavaScript可以用来编写大型、复杂的应用程序，成为企业级开发语言！&lt;/p&gt;

&lt;p&gt;不过…&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;浏览器的支持程度&lt;/a&gt;比较堪忧。。。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/05/JavaScript-Sea.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/05/JavaScript-Sea.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
