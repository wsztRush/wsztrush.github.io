<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 07 Jun 2015 21:15:10 +0800</pubDate>
    <lastBuildDate>Sun, 07 Jun 2015 21:15:10 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Top</title>
        <description>&lt;p&gt;1、通过btreace打印所有的异常，无果。
2、通过jstat -gcutil查看内存使用情况及gc日志，正常。&lt;/p&gt;
</description>
        <pubDate>Sat, 30 May 2015 00:00:00 +0800</pubDate>
        <link>/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/2015/05/30/Top.html</link>
        <guid isPermaLink="true">/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/2015/05/30/Top.html</guid>
        
        
        <category>问题排查</category>
        
      </item>
    
      <item>
        <title>Guava</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;

&lt;h2 id=&quot;section-2&quot;&gt;学习&lt;/h2&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

</description>
        <pubDate>Sat, 30 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java枚举</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;在JDK 1.5之前通常用final来定义各种常量，现在新加了枚举类型，最简单的用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED,
    GREEN
}
&lt;/pre&gt;

&lt;p&gt;还可以像普通的类那样自己定义属性和方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED(&quot;red&quot;),
    GREEN(&quot;green&quot;);
    String name;

    Color(String name) {
        this.name = name;
    }

    public String toString(){
        return name;
    }
}
&lt;/pre&gt;

&lt;p&gt;甚至enum还可以去实现接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color implements Comparable&amp;lt;Color&amp;gt; {
    RED,
    GREEN;
}
&lt;/pre&gt;

&lt;p&gt;在使用的时候，枚举可以用来比较：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
if(c == Color.GREEN){
    // ...
}
&lt;/pre&gt;

&lt;p&gt;也可以用来switch：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
switch (c) {
    case RED:
    case GREEN:
}
&lt;/pre&gt;

&lt;p&gt;而且你可以很方便的变量一个枚举类型中所有的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
for (Color c : Color.values()) {
    System.out.println(c);
}
&lt;/pre&gt;

&lt;p&gt;甚至在你只知道枚举的变量名的时候也能拿到对应的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
System.out.println(Color.valueOf(&quot;RED&quot;));
&lt;/pre&gt;

&lt;p&gt;看下来，枚举在定义常量上面做了不少友好的封装。&lt;/p&gt;

&lt;h2 id=&quot;vs&quot;&gt;枚举VS常量&lt;/h2&gt;

&lt;p&gt;首先不同的枚举类是不同的类型，而你用final static修饰的一般都是int等基本类型，这样很难做类型检查，这算是Enum比较大的一个优势的优势，在写代码的时候不会传错参数：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void check(Color c){

}
&lt;/pre&gt;

&lt;p&gt;当你传入其他类型参数时会编译出错。&lt;/p&gt;

&lt;h2 id=&quot;enum&quot;&gt;enum到底是什么&lt;/h2&gt;

&lt;p&gt;在编译之后会有一个Color.class文件，使用javap查看：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
final class Color extends java.lang.Enum implements java.lang.Comparable{
    public static final Color RED;
    public static final Color GREEN;
    public static Color[] values();
    public static Color valueOf(java.lang.String);
    static {};
}
&lt;/pre&gt;

&lt;p&gt;该类继承自&lt;strong&gt;java.lang.Enum&lt;/strong&gt;，然后通过&lt;strong&gt;javap -c Color&lt;/strong&gt;来看初始化的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static {};
  Code:
   0:   new     #4; //class Color
   3:   dup
   4:   ldc     #7; //String RED
   6:   iconst_0
   7:   invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   10:  putstatic       #9; //Field RED:LColor;
   13:  new     #4; //class Color
   16:  dup
   17:  ldc     #10; //String GREEN
   19:  iconst_1
   20:  invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   23:  putstatic       #11; //Field GREEN:LColor;
   26:  iconst_2
   27:  anewarray       #4; //class Color
   30:  dup
   31:  iconst_0
   32:  getstatic       #9; //Field RED:LColor;
   35:  aastore
   36:  dup
   37:  iconst_1
   38:  getstatic       #11; //Field GREEN:LColor;
   41:  aastore
   42:  putstatic       #1; //Field $VALUES:[LColor;
   45:  return
&lt;/pre&gt;

&lt;p&gt;这里大家可能会对枚举switch有疑问，我们写代码来看下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void func(Color c){
        switch(c){
            case RED:
            case GREEN:
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;然后用javap -c查看，得到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void func(Color);
  Code:
   0:   getstatic       #2; //Field Test$1.$SwitchMap$Color:[I
   3:   aload_1
   4:   invokevirtual   #3; //Method Color.ordinal:()I
   7:   iaload
   8:   lookupswitch{ //2
                1: 36;
                2: 36;
                default: 36 }
   36:  return
}
&lt;/pre&gt;

&lt;p&gt;可以看到这里switch的其实还是enum类中的ordinal（int），和之前我们对switch的认识是一致的。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 May 2015 04:34:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的ThreadLocal</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;多个线程在调用同一个方法的时候，会有并发问题，解决这种问题最简单的办法就是将数据保存在Thread的自己的结构中，也就是ThreadLocal的作用了。用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class JavaBean {
    static ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;Integer&amp;gt;();

    public void prepare() {
        threadLocal.set(0);
    }

    public void work() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            int val = threadLocal.get();
            val++;
            threadLocal.set(val);
        }
        System.out.println(threadLocal.get());
    }
}

class Worker extends Thread {
    JavaBean bean;

    public Worker(JavaBean bean) {
        this.bean = bean;
    }

    public void run() {
        bean.prepare();
        bean.work();
    }
}

public class ThreadLocalDemo {
    public static void main(String[] args) {
        JavaBean bean = new JavaBean();
        for (int i = 0; i &amp;lt; 100; i++) {
            new Worker(bean).start();
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;从输出中可以看到，多个线程操作同一个threadLocal时，结果并不会出错。&lt;/p&gt;

&lt;p&gt;可以将ThreadLocal看做是对&lt;strong&gt;Thread.threadLocals&lt;/strong&gt;的封装，况且在程序中也是不能直接访问到Thread.threadLocals。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;下面简单看ThreadLocal的原理，在Thread中保存了一个Map，类型可以认为是&lt;strong&gt;Map&amp;lt;ThreadLocal, T&amp;gt;&lt;/strong&gt;，其中T是要保存数据的类型。当要从中取出数据时，调用的流程如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Thread.currentThread().threadLocals.getEntry(threadLocal).value
&lt;/pre&gt;

&lt;p&gt;这样，不同的线程在执行的时候在同一个threadLocal上获取到的是不同的数据，线程之间的隔离性是通过”各自保存不同的Map”来实现的，而看到的threadLocal对象其实是&lt;strong&gt;KEY&lt;/strong&gt;，在操作前get到的是&lt;strong&gt;VALUE&lt;/strong&gt;。其实自己动手做一个线程安全的数据保存的解决方法也是这个思路。&lt;/p&gt;

&lt;p&gt;在ThreadLocalMap中使用的并不是普通的引用保存数据，而是使用&lt;strong&gt;WeakReference&lt;/strong&gt;来做：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;gt; {
    Object value;
    Entry(ThreadLocal k, Object v) {
        super(k);
        value = v;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样如果ThreadLocal被释放了，那么ThreadLocalMap中的Entry也会被释放，不至于造成内存泄露。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java对象占用了多少空间？</title>
        <description>&lt;p&gt;在Java中没有sizeof运算符，所以没办法知道一个对象到底占用了多大的空间，但是在分配对象的时候会有一些基本的规则，我们根据这些规则大致能判断出来对象大小。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;对象头&lt;/h2&gt;

&lt;p&gt;对象的头部至少有两个WORD，如果是数组的话，那么三个WORD，内容如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的HashCode，锁信息等&lt;/li&gt;
  &lt;li&gt;到对象类型数据的指针&lt;/li&gt;
  &lt;li&gt;数组的长度（如果是数组的话）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;规则&lt;/h2&gt;

&lt;p&gt;首先，任何对象都是8字节对齐，属性按照[long,double]、[int,float]、[char,short]、[byte,boolean]、reference的顺序存放，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    byte a;
    int b;
    boolean c;
    long d;
    Object e;
}
&lt;/pre&gt;

&lt;p&gt;如果这个对象的属性按照顺序存放的话，要占用的空间为：head(8) + a(1) + padding(3) + b(4) + c(1) + padding(7) + d(8) + e(4) + padding(4) = 40。但是按照这个规则得到：head(8) + d(8) + b(4) + a(1) + c(1) + padding(2) + e(4) + padding(4) = 32。可以看到节省了不少空间。&lt;/p&gt;

&lt;p&gt;在涉及继承关系的时候有一个最基本的规则：首先存放父类中的成员，接着才是子类中的成员，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    long a;
    int b;
    int c;
}
class B extends A {
    long d;
}
&lt;/pre&gt;

&lt;p&gt;这样存放的顺序及占用空间如下：head(8) + a(8) + b(4) + c(4) + d(8) = 32。那如果父类中的属性不够八个字节怎么办？这样就有了新的一条规则：父类中最后一个成员与子类的第一个成员的间隔如果不够4个字节，此时需要扩展到4个字节的基本单位，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    byte b;
}
&lt;/pre&gt;

&lt;p&gt;那么此时占用的空间如下：head(8) + a(1) + padding(3) + b(1) + padding(3) = 16。显然这种方式比较浪费空间，那么就有了：如果子类的第一个成员是double或者long，并且父类并没有用完8个字节，JVM会破坏规将较小的数据填充到该空间，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    long b;
    short c;
    byte d;
}
&lt;/pre&gt;

&lt;p&gt;此时占用的空间如下：head(8) + a(1) + padding(3) + c(2) + d(1) + padding(1) + b(8) = 24。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的泛型</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;什么是泛型&lt;/h2&gt;

&lt;p&gt;泛型是JDK 1.5中引入的特性，允许在定义类、接口、方法的时候使用类型参数，声明的类型参数在使用时用具体的类型替换。从好的方面来看，泛型的引入可以在编译时刻就发现很多明显的错误。从不好的方面，为了保证与旧有版本的兼容性，Java泛型的实现上存在一些不优雅的地方。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;最常见的使用场景是泛型类或者接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
interface TestInterface&amp;lt;T&amp;gt; {
}
class TestClass&amp;lt;T&amp;gt; {
    T data;
}
&lt;/pre&gt;

&lt;p&gt;看以看到泛型的好处能节省我们的代码量，当&lt;strong&gt;data&lt;/strong&gt;的类型变化的时候，我们不需要去写不同的接口或者类。当然有时候你需要指定多个类型，那么可以：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&amp;lt;K, V, OTHER&amp;gt; {
    K     key;
    V     value;
    OTHER other;
}
&lt;/pre&gt;

&lt;p&gt;有时候我们希望只支持Number类型，那么可以：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&amp;lt;T extends Number&amp;gt; {
    T data;
}
&lt;/pre&gt;

&lt;p&gt;当然，泛型也可以用在方法上，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public &amp;lt;T&amp;gt; T doSth(T a){
    return a;
}
&lt;/pre&gt;

&lt;p&gt;你可能会比较好奇如果同时在方法和类上面使用泛型的话会出现什么情况：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&amp;lt;T&amp;gt; {
    T data;
    @SuppressWarnings(&quot;hiding&quot;)
    public &amp;lt;T&amp;gt; T doSth(T a) {
        return a;
    }

    public static void main(String[] args) {
        Test&amp;lt;String&amp;gt; t = new Test&amp;lt;String&amp;gt;();
        System.out.println(t.doSth(123));
        t.data = &quot;123&quot;;
    }
}
&lt;/pre&gt;

&lt;p&gt;结论是方法上的用方法的，其他的用类上的，如果方法上没有，方法用类上的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;多想一点&lt;/h2&gt;

&lt;p&gt;现在想一下泛型具体是如何实现的，用&lt;strong&gt;javap Test&lt;/strong&gt;看doSth的方法声明如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Object doSth(java.lang.Object);
&lt;/pre&gt;

&lt;p&gt;如果是受限的泛型，比如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&amp;lt;T extends Number&amp;gt; {
    public T doSth(T a) {
        return a;
    }
}
&lt;/pre&gt;

&lt;p&gt;那么得到的结果则是：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Number doSth(java.lang.Number);
&lt;/pre&gt;

&lt;p&gt;如果限制类型有两个（比如&amp;lt;T extends Comparable &amp;amp; Serializable&amp;gt;）则生成的字节码中选用第一个（Comparable）。Java中的泛型是伪泛型，在运行期间，所有的泛型信息都会被擦除。也就是说在生成的Java字节码中没有包含泛型中的类型信息。那么在重载的时候会有什么影响，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void doSth(List&amp;lt;Integer&amp;gt; list) { }
    public void doSth(List&amp;lt;String&amp;gt; list) { }
}
&lt;/pre&gt;

&lt;p&gt;现在应该会猜到：&lt;strong&gt;因为类型擦除，这个类是不能被编译通过的。&lt;/strong&gt;那么下面这段代码呢？&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public Integer doSth(List&amp;lt;Integer&amp;gt; list) { return null; }
    public String doSth(List&amp;lt;String&amp;gt; list) { return null; }
}
&lt;/pre&gt;

&lt;p&gt;编译通过了。这貌似与我们之前对重载的认识不相同：函数之间的区分是依据参数和方法名，返回值并不参与。上面这段代码中常在不是根据返回值来判断的，但是增加不同类型的返回值是的这两个方法能够共存在同一个Class文件中：
&amp;gt; 重载要求方法有不同的方法签名，而返回值并不在方法签名中。但是在Class文件格式中，只要描述符不是完全一致的方法就可以共存，也就是说：返回值也能影响方法能不能共存在同一个Class中。
可以通过javap -s Test看到方法签名。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;获取泛型的类型&lt;/h2&gt;

&lt;p&gt;首先来看通过&lt;strong&gt;ParameterizedType&lt;/strong&gt;获取类型的方法，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public List&amp;lt;String&amp;gt; list;

    public static void main(String[] args) throws Exception {
        ParameterizedType pt = (ParameterizedType) Test.class.getField(&quot;list&quot;).getGenericType();
        System.out.println(pt.getActualTypeArguments()[0]);
    }
}
&lt;/pre&gt;

&lt;p&gt;其中getGenericType方法返回一个Type对象，如果是一个参数化类型，那么返回的Type会反映源码中使用的实际参数类型，实际的参数类型通过getActualTypeArguments获取。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Linux内存管理</title>
        <description>&lt;p&gt;现在的服务器大部分都是运行在Linux上面的，所以，作为一个程序员有必要简单地了解一下系统是如何运行的。对于内存部分需要知道：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;地址映射&lt;/li&gt;
  &lt;li&gt;内存管理的方式&lt;/li&gt;
  &lt;li&gt;缺页异常&lt;/li&gt;
  &lt;li&gt;文件映射&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先来看一些基本的知识，在进程看来，内存分为内核态和用户态两部分，经典比例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-虚拟地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从用户态到内核态一般通过系统调用、中断来实现。用户态的内存被划分为不同的区域用于不同的目的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-用户区分段.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然内核态也不会无差别地使用，所以，其划分如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-内核地址空间划分.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面来仔细看这些内存是如何管理的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;地址&lt;/h2&gt;

&lt;p&gt;在Linux内部的地址的映射过程为&lt;strong&gt;逻辑地址&lt;/strong&gt;–&amp;gt;&lt;strong&gt;线性地址&lt;/strong&gt;–&amp;gt;&lt;strong&gt;物理地址&lt;/strong&gt;，物理地址最简单：地址总线中传输的数字信号，而线性地址和逻辑地址所表示的则是一种转换规则，线性地址规则如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-线性地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部分由MMU完成，其中涉及到主要的寄存器有CR0、CR3。机器指令中出现的是逻辑地址，逻辑地址规则如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-逻辑地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Linux中的逻辑地址等于线性地址，也就是说Inter为了兼容把事情搞得很复杂，Linux简化顺便偷个懒。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内存管理的方式&lt;/h2&gt;

&lt;p&gt;在系统boot的时候会去探测内存的大小和情况，在建立复杂的结构之前，需要用一个简单的方式来管理这些内存，这就是&lt;strong&gt;bootmem&lt;/strong&gt;，简单来说就是位图，不过其中也有一些优化的思路。&lt;/p&gt;

&lt;p&gt;bootmem再怎么优化，效率都不高，在要分配内存的时候毕竟是要去遍历，&lt;strong&gt;buddy&lt;/strong&gt;系统刚好能解决这个问题：在内部保存一些2的幂次大小的空闲内存片段，如果要分配3page，去4page的列表里面取一个，分配3个之后将剩下的1个放回去，内存释放的过程刚好是一个逆过程。用一个图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-伙伴系统.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到0、4、5、6、7都是正在使用的，那么，1、2被释放的时候，他们会合并吗？&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static inline unsigned long
__find_buddy_index(unsigned long page_idx, unsigned int order)
{
    return page_idx ^ (1 &amp;lt;&amp;lt; order);// 更新最高位，0～1互换
}
&lt;/pre&gt;

&lt;p&gt;从上面这段代码中可以看到，0、1是buddy，2、3是buddy，虽然1、2相邻，但他们不是。内存碎片是系统运行的大敌，伙伴系统机制可以在一定程度上防止碎片~~另外，我们可以通过cat /proc/buddyinfo获取到各order中的空闲的页面数。&lt;/p&gt;

&lt;p&gt;伙伴系统每次分配内存都是以页（4KB）为单位的，但系统运行的时候使用的绝大部分的数据结构都是很小的，为一个小对象分配4KB显然是不划算了。Linux中使用&lt;strong&gt;slab&lt;/strong&gt;来解决小对象的分配：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-SLAB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在运行时，slab向buddy“批发”一些内存，加工切块以后“散卖”出去。随着大规模多处理器系统和NUMA系统的广泛应用，slab终于暴露出不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复杂的队列管理&lt;/li&gt;
  &lt;li&gt;管理数据和队列存储开销较大&lt;/li&gt;
  &lt;li&gt;长时间运行partial队列可能会非常长&lt;/li&gt;
  &lt;li&gt;对NUMA支持非常复杂&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这些高手们开发了&lt;strong&gt;slub&lt;/strong&gt;：改造page结构来削减slab管理结构的开销、每个CPU都有一个本地活动的slab(kmem_cache_cpu)等。对于小型的嵌入式系统存在一个slab模拟层&lt;strong&gt;slob&lt;/strong&gt;，在这种系统中它更有优势。&lt;/p&gt;

&lt;p&gt;小内存的问题算是解决了，但还有一个大内存的问题：用伙伴系统分配10 x 4KB的数据时，会去16 x 4KB的空闲列表里面去找（这样得到的物理内存是连续的），但很有可能系统里面有内存，但是伙伴系统分配不出来，因为他们被分割成小的片段。那么，&lt;strong&gt;vmalloc&lt;/strong&gt;就是要用这些碎片来拼凑出一个大内存，相当于收集一些“边角料”，组装成一个成品后“出售”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-非连续内存.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前的内存都是直接映射的，第一次感觉到页式管理的存在:D 另外对于高端内存，提供了&lt;strong&gt;kmap&lt;/strong&gt;方法为page分配一个线性地址。&lt;/p&gt;

&lt;p&gt;进程由不同长度的段组成：代码段、动态库的代码、全局变量和动态产生数据的堆、栈等，在Linux中为每个进程管理了一套&lt;strong&gt;虚拟地址空间&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-进程虚拟内存.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在我们写代码malloc完以后，并没有马上占用那么大的物理内存，而仅仅是维护上面的虚拟地址空间而已，只有在真正需要的时候才分配物理内存，这就是&lt;strong&gt;COW&lt;/strong&gt;（COPY-ON-WRITE:写时复制）技术，而物理分配的过程就是最复杂的缺页异常处理环节了，下面来看!&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缺页异常&lt;/h2&gt;

&lt;p&gt;在实际需要某个虚拟内存区域的数据之前，和物理内存之间的映射关系不会建立。如果进程访问的虚拟地址空间部分尚未与页帧关联，处理器自动引发一个缺页异常。在内核处理缺页异常时可以拿到的信息如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cr2：访问到线性地址&lt;/li&gt;
  &lt;li&gt;err_code：异常发生时由控制单元压入栈中，表示发生异常的原因&lt;/li&gt;
  &lt;li&gt;regs：发生异常时寄存器的值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;处理的流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-缺页异常.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发生缺页异常的时候，可能因为不常使用而被swap到磁盘上了，swap相关的命令如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;swapon&lt;/td&gt;
      &lt;td&gt;开启swap&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;swapoff&lt;/td&gt;
      &lt;td&gt;关闭swap&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>歌德尔不完备定理</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;希尔伯特&lt;/strong&gt;是19世纪和20世纪初最具影响力的数学家之一，在严格化的大纷争中，他带领的形式主义派系技压群雄，得到许多当时有名望的数学家的支持。希尔伯特打算通过形式化的手段，将证明抽象成一堆符号的转换。令人惊奇的是这似乎真的可行！为此，希尔伯特希望能够证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，对任意的陈述，都能判断出真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，这一企图被&lt;strong&gt;哥德尔&lt;/strong&gt;的博士论文《论数学原理及有关系统中不可判定命题》无情击碎，不完备性定理揭示：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任意一个无矛盾的形式系统中，存在命题，无法证明其真伪。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这在当时的数学界掀起轩然大波，它不仅具有数学意义，还蕴含着深刻的哲学意义。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;证明&lt;/h2&gt;

&lt;p&gt;不能判断出真伪，自然就想到古老的悖论：&lt;strong&gt;这句话是假的&lt;/strong&gt;（说它真也不行，说它假也不行！）。1905年法国数学家&lt;strong&gt;理查德&lt;/strong&gt;在数学系统中构造出来这样的悖论：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用语言描述自然数的性质；&lt;/li&gt;
  &lt;li&gt;将性质的描述语言映射到一个自然数；&lt;/li&gt;
  &lt;li&gt;如果自然数不符合对应的性质，则称其具有理查兹性，该自然数称为理查德数；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理查兹性也是一个自然数的性质，对应的编号为N，那么N是理查德数吗？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;理查德悖论&lt;/strong&gt;是有瑕疵的：自然数的性质应该是“能被2整除”、“大于100”等，而理查兹性质则把性质和描述性质的语言纠缠在一起了！&lt;/p&gt;

&lt;p&gt;罗素和一些人认为如果把对象语言和讨论对象语言的&lt;strong&gt;元语言&lt;/strong&gt;区分开来就能避免这种问题。希尔伯特用精确的形式语言构建的形式公理系统，已经严格区分了数学和元数学，建立起隔离墙，堵住了这个漏洞。哥德尔要想把&lt;strong&gt;这个公式是不可证明的&lt;/strong&gt;放在系统里，必须绕过这堵墙，用数学语言来描述即证明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在任何相容的形式系统，只要蕴含皮亚诺算术公理，就可以在其中构造在体系中不能被证明的命题，因此通过推演不能得到所有的真命题（即体系是不完备的）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓&lt;strong&gt;相容&lt;/strong&gt;，就是不矛盾，所谓&lt;strong&gt;完备&lt;/strong&gt;，就是所有的真理都能被形式证明，所谓&lt;strong&gt;皮亚诺算术公理&lt;/strong&gt;是指意大利数学家&lt;strong&gt;皮亚诺&lt;/strong&gt;提出的关于自然数的五条公理系统：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;1是自然数&lt;/li&gt;
  &lt;li&gt;每一个确定的自然数a都有一个确定的后继数a’&lt;/li&gt;
  &lt;li&gt;当且仅当b’=c’时有b=c&lt;/li&gt;
  &lt;li&gt;1不是任何自然数的后继数&lt;/li&gt;
  &lt;li&gt;任意关于自然数的命题，如果证明1是对的，并且假设n对的情况下n’也是对的，那么所有的自然数都是对的（数学归纳法）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据这五条公理系统可以建立起一阶算术系统。&lt;/p&gt;

&lt;p&gt;我们来看哥德尔的证明，首先他将命题映射成自然数，现在搞计算机的一看可能觉得用Unicode不就完了？但是这个论文比计算机早了很多年，可以了解一下&lt;strong&gt;哥德尔编码&lt;/strong&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;G(F)：命题F(x)的哥德尔数。
P(x)：在系统中哥德尔数x对应的命题是可证明的。
SU(z)：对于F(x)有z=G(F)，设y是命题F(G(F))的哥德尔数，则有~P(y)成立。
p：SU(G(SU))。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当问到p是否为真的时候，我们其实就是在问&lt;strong&gt;不可证这个特性本身是不可证的吗？&lt;/strong&gt;这样就造成了矛盾（这是Wikipedia上面给出的）。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;意义&lt;/h2&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</link>
        <guid isPermaLink="true">/%E6%95%B0%E5%AD%A6/2015/05/13/Incompleteness-Theorems.html</guid>
        
        
        <category>数学</category>
        
      </item>
    
      <item>
        <title>2015/5~2015/7</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;计划&lt;/h2&gt;

&lt;h3 id=&quot;section-1&quot;&gt;工作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;拣选单执行情况实时计算完成&lt;/li&gt;
  &lt;li&gt;大宝监控方案设计&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;生活&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一周最少五天晨跑(2KM)&lt;/li&gt;
  &lt;li&gt;五月份每周一次10KM晨跑，六月份每周一次半马(21KM)&lt;/li&gt;
  &lt;li&gt;结婚&lt;/li&gt;
  &lt;li&gt;找个避暑的地方玩一把&lt;/li&gt;
  &lt;li&gt;放弃DOTA &amp;gt;_&amp;lt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;读书&amp;amp;学习&lt;/h3&gt;

&lt;p&gt;读一些开阔视野但是不需要深入思考的书：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s1331728.jpg&quot; alt=&quot;费马大定理&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s3010562.jpg&quot; alt=&quot;哥德尔证明&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s10685385.jpg&quot; alt=&quot;自控力&quot; /&gt;
&lt;img src=&quot;http://img3.douban.com/mpic/s1055134.jpg&quot; alt=&quot;晚清七十年&quot; /&gt;&lt;/p&gt;

&lt;p&gt;精读并实践进而转化成自己的技能的书：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s7661036.jpg&quot; alt=&quot;编程语言实现模式&quot; /&gt;
&lt;img src=&quot;http://img5.douban.com/mpic/s24436529.jpg&quot; alt=&quot;The Definitive ANTLR 4 Reference&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;完成情况&lt;/h2&gt;

</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/13/15-5-6.html</link>
        <guid isPermaLink="true">/%E9%87%8C%E7%A8%8B%E7%A2%91/2015/05/13/15-5-6.html</guid>
        
        
        <category>里程碑</category>
        
      </item>
    
      <item>
        <title>Java 解惑</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img5.douban.com/mpic/s1491187.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这本书给我们列举了很多Java编程中容易产生迷惑的地方，先看几个例子：&lt;/p&gt;

&lt;p&gt;1、在刚开始学编程的时候都会遇到swap操作，开始作为一个新手老老实实地用另外一个变量tmp来存，偶然看到用异或来实现感觉好牛逼，不过这种方式在Java上行不通：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
int x = 1;
int y = 2;
x ^= y ^= x ^= y;
System.out.println(&quot;x = &quot; + x + &quot; y = &quot; + y);
&lt;/pre&gt;

&lt;p&gt;出乎意料地是这段代码执行的结果是x = 0 y = 1，而不是希望的x = 2 y = 1，接下来从字节码（javap -c）中找答案：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
   0:   iconst_1
   1:   istore_1
   2:   iconst_2
   3:   istore_2
   4:   iload_1
   5:   iload_2
   6:   iload_1
   7:   iload_2
   8:   ixor
   9:   dup
   10:  istore_1
   11:  ixor
   12:  dup
   13:  istore_2
   14:  ixor
   15:  istore_1
&lt;/pre&gt;
&lt;p&gt;原来执行过程竟然是这样的，为了更清晰给一个图来看栈帧的变化：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Java解惑-Stack.png&quot; alt=&quot;栈帧的变化&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Java语言规范描述中：操作符的操作数是从左到右求值的，对于x^=expr的表达式，x的值是在计算expr之前被提取的，那么因此也就有了上面这个结果。&lt;/p&gt;

&lt;p&gt;2、在做ACM的时候经常会用到位操作，但是被下面这个代码还是惊了一下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
int i = 0;
while (-1 &amp;lt;&amp;lt; i != 0)
    i++;
System.out.println(i);// 没输出，死循环啦。
&lt;/pre&gt;

&lt;p&gt;对于-1直观的想法是在i=32的时候&lt;strong&gt;-1&amp;lt;&amp;lt;i==0&lt;/strong&gt;，因为左移了32位嘛，随便什么数都成0了。&lt;/p&gt;

&lt;p&gt;原因很简单：对于太大的数位操作会取模，比如int来说移位数为&lt;strong&gt;i&amp;amp;31&lt;/strong&gt;，对于long来说移位数为&lt;strong&gt;i&amp;amp;63&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;3、对于初始化顺序大家应该都是知道的，但是当看到下面这段代码输出9900的时候还是得仔细看一下：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestMain {
    static {
        initializeIfNecessary();
    }
    private static int sum;

    public static int getSum() {
        initializeIfNecessary();
        return sum;
    }

    private static boolean initialized = false;// 这里会设置成false。

    private static synchronized void initializeIfNecessary() {
        if (!initialized) {
            for (int i = 0; i &amp;lt; 100; i++)
                sum += i;
            initialized = true;
        }
    }

    public static void main(String[] args) {
        System.out.println(TestMain.getSum());
    }
}
&lt;/pre&gt;
&lt;p&gt;在加载的时候会先分配内存，然后依次执行static，而其顺序和申明的顺序一致，那么这个结果自然就明白了。&lt;/p&gt;

&lt;p&gt;4、第一眼看去这段代码重写的equals，而且非常正确，但是输出却是&lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class Name {
	private String first, last;
	public Name(String first, String last) {
		this.first = first;
		this.last = last;
	}
	public boolean equals(Object o) {
		if (!(o instanceof Name))
			return false;
		Name n = (Name)o;
		return n.first.equals(first) &amp;amp;&amp;amp; n.last.equals(last);
	}
	public static void main(String[] args) {
		Set s = new HashSet();
		s.add(new Name(&quot;Mickey&quot;, &quot;Mouse&quot;));
		System.out.println(
		s.contains(new Name(&quot;Mickey&quot;, &quot;Mouse&quot;)));
	}
}
&lt;/pre&gt;
&lt;p&gt;这就是没有仔细思考的结果，想一下&lt;strong&gt;HashSet.contains()&lt;/strong&gt;的运行机制就会焕然大悟：肯定是先比较hashCode，相同的情况下才调用equals。所以：&lt;strong&gt;无论何时，只要你覆盖了equals方法，就同时必须覆盖hashCode方法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;5、对于这段代码可能会直观的顺着代码写的顺序去执行，但是非常容易忽略掉一点&lt;strong&gt;static是类初始化的一部分&lt;/strong&gt;，当执行到t.join()的时候貌似主线程在等待t执行完成，但是此时主线程也在等待自己执行完成，所以&lt;strong&gt;死锁&lt;/strong&gt;了。。。&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public class Lazy {
	private static boolean initialized = false;
	static {
	Thread t = new Thread(new Runnable() {
		public void run() {
			initialized = true;
		}
	});
	t.start();
		try{
			t.join();
		}catch (InterruptedException e){
			throw new AssertionError(e);
		}
	}
	public static void main(String[] args){
		System.out.println(initialized);
	}
}
&lt;/pre&gt;

&lt;p&gt;当然书中的例子并不只上面几个（一共有95个），总体来看有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;小心溢出以及浮点精度&lt;/li&gt;
  &lt;li&gt;NaN是个奇葩&lt;/li&gt;
  &lt;li&gt;继承中的各种陷阱，比如：
    &lt;ul&gt;
      &lt;li&gt;覆写：完全相同的方法。&lt;/li&gt;
      &lt;li&gt;隐藏：完全相同，但是为private。&lt;/li&gt;
      &lt;li&gt;重载：参数类型不同。&lt;/li&gt;
      &lt;li&gt;遮蔽：外面相同名字的变量被里面的变量遮蔽。&lt;/li&gt;
      &lt;li&gt;遮掩：用变量名和类名冲突。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;泛型擦除术&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;不可否认看完这本书的很多例子能帮助我们写出更高质量的代码（比如覆写equels不覆写hashCode），不过很多例子（尤其是继承）编写很多年的工程代码都不会遇到。&lt;/p&gt;

&lt;p&gt;看完这本书最大的收获就是对Java有了更深的理解。另外，像位移这种反直觉的设计真的好吗？&lt;/p&gt;
</description>
        <pubDate>Mon, 11 May 2015 15:22:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/11/Java-Puzzlers.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/05/11/Java-Puzzlers.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
  </channel>
</rss>
