<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 11 Jul 2015 19:10:11 +0800</pubDate>
    <lastBuildDate>Sat, 11 Jul 2015 19:10:11 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>SpringMVC</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概念&lt;/h2&gt;

&lt;p&gt;在MVC中最基本的概念就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Model&lt;/li&gt;
  &lt;li&gt;View&lt;/li&gt;
  &lt;li&gt;Controller&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在SpringMVC中对这些结构进行了封装：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ModelAndView&lt;/td&gt;
      &lt;td&gt;在同一个地方可以同时操作Model和View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ModelMap&lt;/td&gt;
      &lt;td&gt;数据承载对象，用于到后面渲染View，在RequestMapping的时候很有用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当然对处理流程也进行了封装：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;DispatcherServlet&lt;/td&gt;
      &lt;td&gt;前置分发控制器，请求统一交给它处理&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VelocityViewResolver&lt;/td&gt;
      &lt;td&gt;通过name查找View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HandlerInterceptor&lt;/td&gt;
      &lt;td&gt;拦截器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DefaultAnnotationHandlerMapping&lt;/td&gt;
      &lt;td&gt;类级别的@RequestMapping&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AnnotationMethodHandlerAdapter&lt;/td&gt;
      &lt;td&gt;方法级别的@RequestMapping&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HandlerMethodArgumentResolver&lt;/td&gt;
      &lt;td&gt;参数解析器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping&lt;/td&gt;
      &lt;td&gt;映射规则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Controller&lt;/td&gt;
      &lt;td&gt;注入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@ModelAttribute&lt;/td&gt;
      &lt;td&gt;被注释的方法在Controller中处理请求的方法之前执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@PathVariable&lt;/td&gt;
      &lt;td&gt;获取路径上的变量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;处理请求&lt;/h2&gt;

&lt;p&gt;用的最多的情况就是用户输入URL你给他返回一个&lt;strong&gt;页面&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@RequestMapping(value = &quot;/abc&quot;)
public ModelAndView handle() throws Exception {
    ModelAndView mv = new ModelAndView(&quot;abc&quot;);
    mv.addObject(&quot;key&quot;, &quot;abc&quot;);
    return mv;
}
&lt;/pre&gt;

&lt;p&gt;在很多请求的时候需要返回&lt;strong&gt;JSON&lt;/strong&gt;数据，只需要将字符串写出即可：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@RequestMapping(value = &quot;/abc&quot;)
public void handle(HttpServletResponse response) throws Exception {
    Map map = Maps.newHashMap();
    map.put(&quot;123&quot;, 123);
    response.getOutputStream().write(JSON.toJSONString(map).getBytes());
    response.getOutputStream().flush();
}
&lt;/pre&gt;

&lt;p&gt;对于&lt;strong&gt;文件&lt;/strong&gt;下载的场景也是类似的，不同之处是要指定文件名等：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@RequestMapping(value = &quot;/abc&quot;)
public void handle(HttpServletResponse response) throws Exception {
    OutputStream os = response.getOutputStream();
    response.reset();
    response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=file.txt&quot;);
    response.setContentType(&quot;application/octet-stream; charset=utf-8&quot;);
    os.write(&quot;hello&quot;.getBytes());
    os.flush();
    os.close();
}
&lt;/pre&gt;

&lt;p&gt;从上面可以看到拿到&lt;strong&gt;HttpServletResponse&lt;/strong&gt;之后就可以完全控制住返回值了，在SpringMVC中最简单、直接的获取方式是入参，&lt;strong&gt;HandlerMethodArgumentResolver&lt;/strong&gt;会在解析参数的时候进行处理。在网上有看到用&lt;strong&gt;ModelAttribute&lt;/strong&gt;的方式，这样貌似不是线程安全的吧~&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;HttpServletRequest&lt;/strong&gt;更简单一些，可以使用RequestContextListener或者RequestContextFilter来做，另外更简单的可以直接注入：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Resource
HttpServletRequest  request;
&lt;/pre&gt;

&lt;p&gt;看起来很诡异，这个是如何注入的？其实这里的request只是一个代理，真正的处理过程可以看：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ObjectFactoryDelegatingInvocationHandler&lt;/li&gt;
  &lt;li&gt;RequestObjectFactory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是找了一圈没找到Response有类似的方法，所以，这种方式对Response可能行不通。其实我们自己也可以实现类似的功能，比如用&lt;strong&gt;HandlerInterceptor&lt;/strong&gt;来搞：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface HandlerInterceptor {
    // 在方法之前执行
    boolean preHandle(HttpServletRequest request,
        HttpServletResponse response,
        Object handler) throws Exception;
    // 在方法之后执行
    void postHandle(HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        ModelAndView modelAndView) throws Exception;
    // 在请求处理完成的时候执行
    void afterCompletion(HttpServletRequest request,
        HttpServletResponse response,
        Object handler,
        Exception ex) throws Exception;
&lt;/pre&gt;

&lt;p&gt;我们在preHandle的时候将Request、Response写入ThreadLocal，用FactoryBean来在注入的时候生成代理对象，在调用代理对象的时候先从ThreadLocal中获取对象，再反射调用对象的方法。&lt;/p&gt;

&lt;p&gt;从URL到Controller中的方法的映射也是一个需要注意的地方：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;设置&lt;/th&gt;
      &lt;th&gt;匹配&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(value = “/abc”)&lt;/td&gt;
      &lt;td&gt;/abc、/abc.*、/abc/&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestParam(“id”)&lt;/td&gt;
      &lt;td&gt;限制参数中必须有id，并将其放到入参中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(value = “/abc/{id}”)&lt;/td&gt;
      &lt;td&gt;REST风格，用@PathVariable(“id”)放到入参&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(value = “/{path:[0-9a-z-]+}”)&lt;/td&gt;
      &lt;td&gt;支持正则表达式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(method = RequestMethod.GET)&lt;/td&gt;
      &lt;td&gt;方法过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(params = “123”)&lt;/td&gt;
      &lt;td&gt;参数过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(headers = “abc”)&lt;/td&gt;
      &lt;td&gt;头信息过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(consumes = “application/json”)&lt;/td&gt;
      &lt;td&gt;处理请求的提交内容类型过滤&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@RequestMapping(produces = “application/json”)&lt;/td&gt;
      &lt;td&gt;返回的内容类型过滤&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在SpringMVC中整体的处理逻辑都在&lt;strong&gt;DispatcherServlet&lt;/strong&gt;中完成，处理逻辑如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;处理multipart类型的请求&lt;/li&gt;
  &lt;li&gt;获取处理链HandlerExecutionChain，其中封装了拦截器和处理器&lt;/li&gt;
  &lt;li&gt;执行拦截器的preHandle方法&lt;/li&gt;
  &lt;li&gt;执行处理器&lt;/li&gt;
  &lt;li&gt;设置View&lt;/li&gt;
  &lt;li&gt;执行拦截器的postHandle方法&lt;/li&gt;
  &lt;li&gt;渲染&lt;/li&gt;
  &lt;li&gt;执行拦截器的afterCompletion方法&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;总体看下来比webx简单、好用一些。&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/11/SpringMVC.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/11/SpringMVC.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>《Redis设计与实现》</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img4.douban.com/mpic/s27297117.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;这本书主要是讲Redis底层的实现，总体上分为四部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据结构与对象&lt;/li&gt;
  &lt;li&gt;单机数据库的实现&lt;/li&gt;
  &lt;li&gt;多机数据库的实现&lt;/li&gt;
  &lt;li&gt;独立功能的实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个顺序和作者自己学习的顺序应该是一致的，但是感觉有一点不合理：在刚开始看的时候一直比较着急，因为是在对Redis整体上没有概念的情况下看细节。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;学习笔记&lt;/h2&gt;

&lt;p&gt;在Redis中键为字符串、值为对象，底层处理用到的数据结构有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;动态字符串：使用预分配和惰性释放来减少内存操作次数&lt;/li&gt;
  &lt;li&gt;链表&lt;/li&gt;
  &lt;li&gt;字典：渐进式rehash防止卡住&lt;/li&gt;
  &lt;li&gt;跳跃表&lt;/li&gt;
  &lt;li&gt;整数集合：有序、不重复的整数集合，在必要的时候升级来节约内存&lt;/li&gt;
  &lt;li&gt;压缩列表：连续内存保存整数或字节的列表，通过压缩来节省内存&lt;/li&gt;
  &lt;li&gt;对象：在Redis中都是对象，实现基于上面的数据结构&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由于Redis是用C编写的，没有垃圾回收机制，因此在对象系统中构建了一个&lt;strong&gt;引用计数&lt;/strong&gt;实现内存回收器，通过该机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。&lt;/p&gt;

&lt;p&gt;有了这些基础就可以开始看Redis作为一个服务器是如何工作的：&lt;/p&gt;

&lt;pre&gt;
                  +-------------+                   
                  | redisServer |                   
                  +------+------+                   
                         |                          
+-----------+     +------+------+      +-----------+
|redisClient+-----+   redisDb   +--+---+    dict   |
+-----------+     +-------------+  |   +-----------+
                  |   redisDb   |  |                
                  +-------------+  |   +-----------+
                  |   redisDb   |  +---+  expires  |
                  +-------------+      +-----------+

&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;dict&lt;/strong&gt;：键空间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;expires&lt;/strong&gt;：键的过期时间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有另外一种做过期时间的方法是：对dict上的键做扩展，增加过期时间字段。和Redis的做法相比可能有几个缺点：浪费空间、遍历时浪费时间、结构不清晰。过期键的删除有三种策略：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;定时删除&lt;/strong&gt;：在设置键的过期时间时创建Timer，当Timer运行时执行删除操作&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;：在取值时判断是否过期，如果过期则删除&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;定期删除&lt;/strong&gt;：每隔一段时间对数据库进行检查扫描，删除里面过期的键&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定时删除显然不靠谱，在Redis中同时使用了&lt;strong&gt;定期删除&lt;/strong&gt;和&lt;strong&gt;惰性删除&lt;/strong&gt;，当然在持久化程序中也需要考虑过期时间。&lt;/p&gt;

</description>
        <pubDate>Wed, 08 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/07/08/Redis.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/07/08/Redis.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>Cookie</title>
        <description>&lt;p&gt;为什么需要Cookie
Cookie的属性、类型、流程
在登录的时候如何使用Cookie&lt;/p&gt;

</description>
        <pubDate>Sat, 04 Jul 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/04/Cookie.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/07/04/Cookie.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>拣选单执行情况总结</title>
        <description>&lt;p&gt;数据处理方案有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;离线计算：Hadoop&lt;/li&gt;
  &lt;li&gt;实时计算：Spark&lt;/li&gt;
  &lt;li&gt;流计算：Storm&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这离线计算有点是吞吐量大、逻辑简单，但时效太差，在仓库里面出现问题的时候一个小时（甚至一天）之后才汇报给管理员，估计没人会用了。&lt;/p&gt;

&lt;p&gt;很多人都会讲实时计算和流计算放在一起，他们还是有区别的：Spark可以看成是内存版的Hadoop，把数据放到内存里面可以提高处理速度。另外&lt;strong&gt;ADS&lt;/strong&gt;（阿里云的一个产品）可能做的更优秀一些，在大量的数据上面做统计。而&lt;strong&gt;Storm&lt;/strong&gt;则是监听变化来统计&lt;strong&gt;结果&lt;/strong&gt;，处理的是增量的数据。&lt;/p&gt;

&lt;p&gt;总体上根据读、写的比例，不同的方式各有优劣！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;项目背景&lt;/h2&gt;

&lt;p&gt;本项目的目的是为仓库管理系统（WMS）做一个作业执行情况监控的功能，WMS里面的概念繁多，项目中核心包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;拣选单&lt;/strong&gt;：在拣选单上面有一些要去拣选的商品及数据，库工拿着它推着小车去拿东西&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;包裹&lt;/strong&gt;：一个拣选单对应多个包裹，弄完之后包裹会称重-&amp;gt;包装-&amp;gt;发货-&amp;gt;出库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后希望通过下面两个维度来进行展示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;统计拣选单上面各状态的包裹数&lt;/li&gt;
  &lt;li&gt;统计各库区的未拣选完的拣选单数、包裹数、商品数及品种数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个维度用来看单个拣选单的执行情况，其实把所有拣选单都列出来之后也能够反映出整个仓库的执行情况。&lt;/p&gt;

&lt;p&gt;第二个维度则用来看是否某个库区中的拣选工作量太大，比如为拣选完成的商品数太多就说明是这种情况，此时仓库管理员可以从其他不怎么忙的库区抽调一些人去帮忙。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;技术方案&lt;/h2&gt;

&lt;p&gt;前段时间看了一些JSTORM（一个类似STORM东西，用JAVA重写的）的东西，这次就用它来搞，总体上是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/拣选单-总结-架构.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中几个关键部分用到了公司的中间件：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;中间件&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;DRC&lt;/td&gt;
      &lt;td&gt;监听数据库的变化并存储下来，供各种应用进行消费，后发生的消息ID更大&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OTS&lt;/td&gt;
      &lt;td&gt;类似HBase，不过现在太挫了&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在系统中的机器上的缓存也是用DRC来实现了，每台机器都会消费DRC的消息，然后根据更新来对本地的缓存进行更新，但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在流计算中，每个变更消息只需要被一台机器消费！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在公司内部貌似没有什么工具能做很灵活的路由，而恰巧JSTORM里面的&lt;strong&gt;fieldsGrouping&lt;/strong&gt;刚好可以轻松解决掉，可以在Spout根据指定的Field将Tuple发送给Bolt进行处理，这样只需要指定Field为拣选单ID就可以将相同的拣选单发送给同一个Task进行处理。&lt;/p&gt;

&lt;p&gt;多台机器随机消费DRC消息的时候，如果同一个拣选单相关的消息落在不同的机器上面，此时对应的Task要更新拣选单状态时必须要通过分布式锁来保证状态的准确性！这个麻烦也被顺带着解决了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-E.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;即便是相同的拣选单都落在同一个机器上面，但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息到达的顺序可能是乱序的！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看DRC文档之后发现在变更的消息中有字段ID，越晚的更新ID越大。接收到的消息虽然是乱序的，但是毕竟是在同一个Task中，那么解决办法就简单了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从OTS中取出单据状态&lt;/li&gt;
  &lt;li&gt;比较记录的ID与变更消息的ID比较&lt;/li&gt;
  &lt;li&gt;如果变更消息更小，则放弃&lt;/li&gt;
  &lt;li&gt;如果变更消息更大，那么更新单据状态，然后将其放入OTS&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在OTS中永远保存单据最新的状态不会有错！但是这又有什么意义？如果光是为了取正确的状态直接去数据库好了啊！要想通过SQL获取记录少量还可以，如果多了基本上铁定会超时（因为要联表）。在流计算中要想达到联表的效果很不容易：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不同任务执行速度不同，如果直接联表可能出现当前数据与10分钟前另一份数据关联！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这问题解决起来比较容易，有两个任务同时消费拣选单、包裹的变更消息，每消费完成一分钟的数据，那么就将其保存一个版本，而在他们都完成某个时间点的变更之后，再将他们联表！&lt;/p&gt;

&lt;p&gt;看似很美好，其实有个大问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当一个任务半天没有接收到消息的时候，可能是把本分钟的消息消费完了，也有可能是消息还没来！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再次翻DRC的文档发现它有一个心跳消息，这种心跳消息和我们通常理解的完全不同！在收集binlog的时候就已经将它插入到持久化存储中。在拉取消息的时候，同时也会拉取到对应时间点的心跳记录。&lt;/p&gt;

&lt;p&gt;那么此时要做的就是：如果没有拉取到消息，并且已经接收到下一分钟的心跳消息，那么本分钟的所有的消息都已经处理过了。但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;处理过了并不代表都处理成功了！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Spout端emit给Bolt出里之后，如果成功就会ack，如果失败则fail。他们都会通过acker任务通知给Spout进行统计或者重试。那么我们可以利用这个规则来判断：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在emit时all计数加一&lt;/li&gt;
  &lt;li&gt;在ack时success数加一&lt;/li&gt;
  &lt;li&gt;在fail时all加一并重新发送消息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样在完成所有的消息消费时应该有&lt;strong&gt;all == success&lt;/strong&gt;，综合上面的判断就可以知道某分钟是否全部成功处理。&lt;/p&gt;

&lt;p&gt;即便是能保证消息按照我们设计的数据一分钟一分钟地写入数据库，但是写入过程仍然是需要时间的（不可能一瞬间完成），那么：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写入与读取同时进行的话，可能读取到的一部分是老版本、一部分是新版本！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说仅仅将数据读出来展示倒是问题不大，但如果要再其上面做进一步的加工，那么就完蛋了！先不管用户看到的数据有多大影响，光让测试去验证系统的准确性都是一个非常头疼的问题了！&lt;/p&gt;

&lt;p&gt;解决这种问题基本上都是用版本来搞，比如HBase中的&lt;strong&gt;timestamp&lt;/strong&gt;就可以轻松搞定，但是HBase这货查询起来太麻烦了。当然你可能想到用&lt;strong&gt;Phoenix&lt;/strong&gt;来搞，复杂性和效率先不说，关键是公司的PE已经不给HBase资源了，主推OTS！&lt;/p&gt;

&lt;p&gt;无奈跑去问OTS的负责人，得到答复：&lt;strong&gt;支持SQL不在考虑之中&lt;/strong&gt;~~~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-A.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没办法只能放到MySQL里面了，如果每个版本记录都有一条记录，有两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据库中的记录会变成实际数据量的N倍&lt;/li&gt;
  &lt;li&gt;查询复杂&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有天睡觉醒来突然想到一个解决办法！如果将所有的版本都记录下来，其实起作用的最多只有两个版本，那么：&lt;strong&gt;对每条数据只记录两个版本的数据即可&lt;/strong&gt;。在更新某条数据时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从DB中取出所有版本（最多两条）&lt;/li&gt;
  &lt;li&gt;如果有两条
    &lt;ul&gt;
      &lt;li&gt;取出版本较大的一条记录&lt;/li&gt;
      &lt;li&gt;将较小的版本的ID给他&lt;/li&gt;
      &lt;li&gt;更新数据库&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果有一条或者根本没有
    &lt;ul&gt;
      &lt;li&gt;创建新对象并插入数据库中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在取数据的时候需要加上简单的版本限制：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
(_version &amp;lt;= #currVersion# AND (_max_version = _version OR _max_version &amp;gt;= #currVersion#))
&lt;/pre&gt;

&lt;p&gt;这种效率显然比联表查效率会高很多！&lt;/p&gt;

&lt;p&gt;一般流数据只关心从现在开始发生的变化，但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如何历史数据也很重要，需要更更实时的数据合并怎么办！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仔细想一下，其实也是有办法的，在流计算运行之前做一次数据初始化即可！将所有的数据当前的状态当做的一个时间点变更的结果插入OTS中，然后让OTS来进行消费。在持久化DRC消息到OTS的任务中，设置DRC启动的时间点稍前一些，这样的话增量和全量直接就有覆盖，如果当前状态是4，那么覆盖的过程可能是：4-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;···这样就构成了一个环，中间状态的累加并不会出错！&lt;/p&gt;

&lt;p&gt;哎，饶了这么多的弯，就是为了能够给用户看到一份准确的数据！开始干活！！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开发过程&lt;/h2&gt;

&lt;p&gt;在开始写代码的时候，很多的事情还没有想清楚，但是如果一直因为没有想清楚不开工的话就太傻逼了！光想是没办法永远都想清楚的！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Move Fast And Break Things.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说干就干！刚开始看到包裹里面的有area_id的时候以为是库区ID，然后也没当回事，过了两天仔细一看完全不是那么回事，因为获取不到库区歇菜了？&lt;/p&gt;

&lt;p&gt;请教同事之后发现包裹占用表上有pick_area_id，我只能说当初添加这个字段的哥们太聪明了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-E.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了一下线下的数据库，发现这个字段很多为空！心想应该是大家在日常数据滥用的结果，赶紧到线上看一下，发现这个字段在所有记录里面全部为空！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-D.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;坑到了！但回头一想：肯定有个地方是有位置信息的，这时候看到了占用表中有货位的编码，样子大概是&lt;strong&gt;A0-B0-C0&lt;/strong&gt;，而第一个为A0则为库区编码，这时候仿佛看到了希望，赶紧找别人确认一下！我去，这种规则是仓库自己配的，他们想怎么配怎么配，完全不可靠!!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-D.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没办法，注意到占用表里面还有一个货位ID，货位必然属于某个库区，在系统中肯定有地方维护这个关系！请教对应同事之后果然如此，这个问题算是搞定了。&lt;/p&gt;

&lt;p&gt;之前一直以为DRC中的心跳消息可以分割不同时间段的消息，比如收到10分钟的消息，那么它之前的就全部是十分钟之前的，它之后就全部是十分钟之后的，而这个项目也是建立在这个基础上的！但是突然有一天他们团队的人跑过来说并不是这样！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-A.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个团队的人怎么能说话都不一致！在以为又被坑大了的时候，仔细思考：其实这个项目对心跳记录的要求并没有这么高，只需要保证在接收到消息之后，它之前的数据一定消费完了，而至于有没有消费它之后的数据则并没有那么大的关系！再次去跟他们确认，得到的答复确实是这样的！哈哈哈~~&lt;/p&gt;

&lt;p&gt;开发到后期，商品品种数成了麻烦，因为是品种数所以不能简单的进行累加（不然就变成商品数了）！马上想到一个最简单的解决办法：在OTS中保存一个Map来记录！但是OTS中的值有大小限制，赶紧去问同事一个拣选单中商品数最多有多少个！结果是没有限制….&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-A.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;真的无解了么？仔细想了一番，想到一种解决方法：为每个itemId建一个key，value为其对应的包裹数！在有包裹创建的时候value++，而在包裹删除的时候value–。那么可以在从0变1的时候增加品种数，从1变0的时候减少品种数！&lt;/p&gt;

&lt;p&gt;纠结了两个小时，感觉这种做法太复杂，而且效率也非常低！这时候想可能线上每个拣选单的商品品种数根本就很少！赶紧去线上捞了一把，果然如此！另外发现包裹删除是发生在拆包的情况，而此时仅仅是将包裹一拆为二，里面的品种数并没有发生变化！这样直接在OTS中保存一个itemId的SET即可！&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;现存问题&lt;/h2&gt;

&lt;p&gt;系统虽然上线了，但是还有一些问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;处理效率不高&lt;/li&gt;
  &lt;li&gt;对OTS的依赖太大&lt;/li&gt;
  &lt;li&gt;全量数据和增量数据合并还是可能导致结果出错，原因和解决办法都比较简单&lt;/li&gt;
  &lt;li&gt;在Jstorm中获取数据是通过SQL来的，这样增加了DB的连接数&lt;/li&gt;
  &lt;li&gt;对Jstorm依赖太重，而Jstorm有自身的缺陷&lt;/li&gt;
  &lt;li&gt;每次开发需求都要做代码开发&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，流计算本身就是监控（或者说是报表）的一部分，但是这应该把监控当做一个产品来考虑！最近也在想一些为来的计划：&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;未来计划&lt;/h2&gt;

&lt;p&gt;既然要做，就做到最屌！现在公司内部并没有一个面向&lt;strong&gt;用户的监控&lt;/strong&gt;系统，面向小二的倒是一大堆。另外，面向小二的也做的并不怎么完善，很多都没有当做一个产品来做，那么接下来要做的就是把监控、数据报表分块并一一解决掉：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通知模块：维护用户、组的信息，可以向组、用户发送消息，支持推拉两种方式&lt;/li&gt;
  &lt;li&gt;数据打通：打通数据计算模块和各个模块之间的数据访问&lt;/li&gt;
  &lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E6%B5%81%E6%B0%B4%E8%B4%A6/2015/06/19/Pickbill-Monitor.html</link>
        <guid isPermaLink="true">/%E6%B5%81%E6%B0%B4%E8%B4%A6/2015/06/19/Pickbill-Monitor.html</guid>
        
        
        <category>流水账</category>
        
      </item>
    
      <item>
        <title>VIM</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/VIM-LOGO.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很早之前就知道VIM很厉害，不过作为一个Java攻城狮，用起来实在是不方便，完全没有Eclipse或者IDEA写代码顺畅，比如代码提示等（怀疑自己配置有问题-.-!）。最近对golang非常感兴趣，然而默认的IDE实在是太丑了，所以决心把VIM捡起来。&lt;/p&gt;

&lt;p&gt;周围用Emacs的同事越来越多，但是简单用了几次，总觉得不怎么顺手，也就不了了之。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;插件管理器&lt;/h2&gt;

&lt;p&gt;相比现代编辑器，VIM缺乏默认的插件管理功能，之前在配置时不停地从网上收集插件，然后粘贴到对应的目录下。这个过程相当地考验耐心，以及人品。&lt;/p&gt;

&lt;p&gt;最近无意间发现了一个插件管理工具：&lt;strong&gt;vundle&lt;/strong&gt;。玩了一下感觉还不错，首先从github上下载:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后修改&lt;strong&gt;vimrc&lt;/strong&gt;文件：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
set nocompatible &quot;关闭兼容模式
filetype off &quot;
set rtp+=~/.vim/bundle/Vundle.vim &quot; 写自己安装的目录
call vundle#begin() &quot;

Bundle 'gmarik/Vundle.vim' &quot; 插件列表
&quot; ... 插件列表

call vundle#end() &quot;
filetype plugin indent on
&lt;/pre&gt;

&lt;p&gt;如果是&lt;strong&gt;vim-scripts&lt;/strong&gt;下面的插件直接写名字就好了，否则为&lt;strong&gt;用户名/插件&lt;/strong&gt;的格式，使用时用到的几个命令如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleList&lt;/td&gt;
      &lt;td&gt;列举出列表中(.vimrc中)配置的所有插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall&lt;/td&gt;
      &lt;td&gt;安装列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall!&lt;/td&gt;
      &lt;td&gt;更新列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch foo&lt;/td&gt;
      &lt;td&gt;查找foo插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch! foo&lt;/td&gt;
      &lt;td&gt;刷新foo插件缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean!&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;写代码之前&lt;/h2&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Golang入门</title>
        <description>&lt;p&gt;虽然Go已经不算是一个很新的语言了，但是现在非常地火！一般来说语言本身没有什么好讲究的，能快速编程、少点坑就算是一门好的语言了。但是，如果语言火了之后，其周围的工具发展起来之后，能用它做的事情就太多了~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;环境搭建&lt;/h2&gt;

&lt;p&gt;因为我仅仅打算在ubuntu上面进行golang的开发，所以其他的系统后面用过了再来补充！配置来说相当容易：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载golang的包解压安装，如果官网上的访问不到就到&lt;a href=&quot;http://www.golangtc.com/&quot;&gt;golang中国&lt;/a&gt;找个版本下载&lt;/li&gt;
  &lt;li&gt;在/etc/profile中配置&lt;strong&gt;PATH&lt;/strong&gt;、&lt;strong&gt;GOROOT&lt;/strong&gt;、&lt;strong&gt;GOPATH&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;配置你的IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面就开始GOLANG的学习。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基础语法&lt;/h2&gt;

&lt;p&gt;按照惯例，来看Hello World代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
package main

import &quot;fmt&quot;

func main(){
    fmt.Println(&quot;Hello World&quot;);
}
&lt;/pre&gt;

&lt;p&gt;使用&lt;strong&gt;go run hello.go&lt;/strong&gt;即可执行，也可以使用&lt;strong&gt;go build hello.go&lt;/strong&gt;打包完成之后在运行，所有的命令作用如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;build&lt;/td&gt;
      &lt;td&gt;用于测试编译&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clean&lt;/td&gt;
      &lt;td&gt;移除当前源码包里面编译生成的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;env&lt;/td&gt;
      &lt;td&gt;环境变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fix&lt;/td&gt;
      &lt;td&gt;修复以前老版本的代码到新版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fmt&lt;/td&gt;
      &lt;td&gt;代码格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;generate&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get&lt;/td&gt;
      &lt;td&gt;动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;install&lt;/td&gt;
      &lt;td&gt;生成结果文件(可执行文件或者.a包)，把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;list&lt;/td&gt;
      &lt;td&gt;列出当前全部安装的package&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;run&lt;/td&gt;
      &lt;td&gt;编译并运行Go程序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tool&lt;/td&gt;
      &lt;td&gt;运行对应的工具类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;version&lt;/td&gt;
      &lt;td&gt;版本号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;码代码最基本的是变量和常量，在Go中的定义方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var a string = &quot;initial&quot;  /* 变量 */
const s string = &quot;initial&quot; /* 常量 */
&lt;/pre&gt;

&lt;p&gt;另外一些基本的控制结构也基本一致，简单来看就是省略了不少的括号：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// FOR
for i &amp;lt;= 3
for i := 1; i &amp;lt;= 3; i++
for
// IF
if 8%4 == 0
if num := 9; num &amp;lt; 0
// SWITCH
switch time.Now().Weekday() {
    case time.Saturday, time.Sunday:
    default:
}
&lt;/pre&gt;

&lt;p&gt;Go中的集合用起来感觉跟Python中的有点像：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// ARRAY:数组
var a [5]int
b := [5]int{1, 2, 3, 4, 5}
var c [2][3]int

// SLICES:跟数组很像，不过区间操作非常方便
s := make([]string, 10)
l := s[2:5]
l := s[2:]
l := s[:5]

// RANGE:更方便地遍历，数组的话返回下标和值，MAP返回KEY、VALUE
for _,num := nums {
    sum += num;
}

// MAP:这个没什么好说的
m := make(map[string]int)
m[&quot;a&quot;] = 1
m[&quot;b&quot;] = 2
&lt;/pre&gt;

&lt;p&gt;在Go中定义方法也是比较奇葩的语法，用过的其他语言大部分把返回值写在前面，而它是写在后面，不过应该也没有谁优谁劣，而且在Go中方法可以返回多个值(尤其是在后面会用来返回错误)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func vals() (int, int) {// 普通函数：a, b := vals()
    return 1, 2;
}
func sum(nums ...int) {// 可变参数：sum(1, 2)   sum(1, 2, 3)
}
func zeroptr(iptr *int) {// 参数类型为指针
    *iptr = 0
}
func intSeq() func() int {// 闭包
    i := 0
    return func() int {
        i += 1
        return i
    }
}
&lt;/pre&gt;

&lt;p&gt;在Go中所有的面向对象就是&lt;strong&gt;struct&lt;/strong&gt;了，是不是感觉有点简单？或者有点low？另外在Go中定义了一个奇葩的&lt;strong&gt;interface&lt;/strong&gt;，感觉有点像是一个方法的集合：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
type method interface {
    output();
}

type person struct {
    name string
    age  int
}

func (p *person) output(){// 定义方法，再次吐槽：是不是跟Python很像
    fmt.Println(p.name, p.age);
}

func f(m method) { // 为不同对象定义相同的方法，用这个来实现泛型的话，额~~
	fmt.Println(m);
    m.output();
}

func f1(arg int) (int, error) {
    return -1, errors.New(&quot;i can't work！&quot;); // 返回错误
}

// 调用方法
fmt.Println(person{&quot;Bob&quot;, 20})
fmt.Println(person{name: &quot;Alice&quot;, age: 30})
&lt;/pre&gt;

&lt;p&gt;在Go中比较吸引人的应该就是&lt;strong&gt;goroutines&lt;/strong&gt;，面向并发的语言自然要最大程度的简化对应的代码才算合格。在Go中任意一个方法都可以使用&lt;strong&gt;go&lt;/strong&gt;这个关键字来当做一个协程进行处理：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;go func(“abc”)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仅仅这样是不够的，在Go中又提供了&lt;strong&gt;channel&lt;/strong&gt;用来做消息传递，这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;消息传递&lt;/li&gt;
  &lt;li&gt;共享内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种方式在Go里面就凑齐了，另外&lt;strong&gt;select&lt;/strong&gt;也大大简化了IO时候的操作，代码减了多少并不重要，关键是代码与其含义更加地贴近：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
messages := make(chan string)
messages := make(chan string, 2)

messages &amp;lt;- &quot;buffered&quot; // 写入
msg := &amp;lt;-messages // 读取

select {
    case msg := &amp;lt;-messages:
        fmt.Println(&quot;received message&quot;, msg)
    default:// 这样就不会阻塞了
        fmt.Println(&quot;no message received&quot;)
}
&lt;/pre&gt;

&lt;p&gt;总是感觉select与switch很像，不仅仅是写法上面，另外连TimeOut的写法能很简单、粗暴地搞定：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
select {
    case res := &amp;lt;-c1:
        fmt.Println(res)
    case &amp;lt;-time.After(time.Second * 1):
        fmt.Println(&quot;timeout 1&quot;)
    }
&lt;/pre&gt;

&lt;p&gt;用这种方式能设置延迟，在需要重复的场景下可以用&lt;strong&gt;ticker := time.NewTicker(time.Millisecond * 500)&lt;/strong&gt;来解决。&lt;/p&gt;

&lt;p&gt;在Go语言中不支持传统的try-catch-finally这种异常机制，因为Go的设计者认为可能程序员经常会滥用，所以在大部分的情况都通过返回多个值、其中一个为&lt;strong&gt;ERROR&lt;/strong&gt;的办法来处理，只有在真正异常的情况下才使用Go的Exception机制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;defer&lt;/strong&gt;：为函数添加结束时执行的语句&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;panic&lt;/strong&gt;：非常严重的不可恢复的错误&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;recover&lt;/strong&gt;：从错误中恢复&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看简单的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func f() (result int) {// 返回值为1，只有defer执行后才有效
    defer func() {
        result++
    }()
    return 0;
}
panic(&quot;problem&quot;);// 在这个地方程序就挂掉了

func a(){
    panic(&quot;a---error&quot;);
}
func b(){
    panic(&quot;b---error&quot;);
}
func(){
    def func(){
        if r:= recover(); r != nil {
            log.Printf(&quot;caught: %v&quot;, r);
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;用recover的方法有点像缩水版的try-catch，最后，在Go中居然支持&lt;strong&gt;goto&lt;/strong&gt;，虽然我觉得goto还是挺好用的。&lt;/p&gt;

&lt;p&gt;简单把Go的语法过了一遍，总体的感觉就是简单、面向工程开发，没有很多的废话，也没有太多学术上很有用、工程上用的不多的细节。基本语法的例子都可以在&lt;a href=&quot;https://gobyexample.com/&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;工程开发&lt;/h2&gt;

</description>
        <pubDate>Tue, 09 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Spring</title>
        <description>&lt;p&gt;如今作为一个Java程序员，如果没用过Spring的话基本上没法混了~ 这里就不再啰嗦如何如何从EJB走到了Spring(毕竟咱也没经历过那些个艰难的时代)，直接来看它带给我们哪些东西：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;IoC&lt;/li&gt;
  &lt;li&gt;Aop&lt;/li&gt;
  &lt;li&gt;SpringMVC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面分几个部分很粗地描述一下Spring~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;控制反转&lt;/h2&gt;

&lt;p&gt;要看控制反转，那么我们先看看没有反转的时候是什么样子的，当自己的服务依赖于别人的实现时，在其使用之前选择合适的服务实现对其进行初始化：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    private XXService xxService;
    public MyService(){
        this.xxService = new XXServiceImpl();/* 利用合适的实现进行初始化 */
    }
    // ...
}
&lt;/pre&gt;

&lt;p&gt;程序可以正常运行，但是当你有几十个类中使用了XXService，而某一天发现XXServiceImpl是有BUG的，你想换个实现类，那就傻逼了~~&lt;/p&gt;

&lt;p&gt;用IoC最原始的配置方式就可以将这个问题引刃而解：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean id=&quot;myService&quot; class=&quot;com.test.MyService&quot;&amp;gt;
    &amp;lt;property name=&quot;xxService&quot; ref=&quot;xxService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;xxService&quot; class=&quot;com.test.XXServiceImpl&quot;/&amp;gt;&amp;lt;!-- 改这里 --&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在配置文件中搞定他们之间的依赖关系，在使用前，需要用&lt;strong&gt;BeanFactory&lt;/strong&gt;来构建其中的Bean，在需要时，调用&lt;strong&gt;getBean&lt;/strong&gt;取得实例，然后就可以继续后面的操作了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
BeanFactory factory = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
MyService myService = (MyService)factory.getBean(&quot;myService&quot;);
&lt;/pre&gt;

&lt;p&gt;可能“顽固派”会说：干嘛要怎么麻烦，把你要使用的类包装一下再交给MyService使用就可以了啊！确实可以解决问题，但是思路决定出路，这种解决方法确实解决了上面的问题，但是下面&lt;strong&gt;ApplicationContext&lt;/strong&gt;的登场，使得这种依赖管理变得异常简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    @Resource /* 利用注解完成注入 */
    private XXService xxService;
    // ...
}
@Component(&quot;xxService&quot;) /* 声明一个Bean */
public class XXServiceImpl{
    // ...
}
&lt;/pre&gt;

&lt;p&gt;一直感觉注解在Java中的作用就是将配置信息植入到代码文件里面，现在在依赖管理中注解再一次发挥了巨大的威力。到这里基本上满足大部分的需求了，但是Spring提供的功能可能远超过了你需要的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BeanFactoryAware：获取BeanFactory实例&lt;/li&gt;
  &lt;li&gt;BeanPostProcessor：在afterPropertiesSet的方法前后执行&lt;/li&gt;
  &lt;li&gt;InitializingBean：完成一些初始化动作&lt;/li&gt;
  &lt;li&gt;BeanFactoryPostProcessor:处理Bean的定义，也就是BeanDefinition&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有很多其他的扩展点，下面重点看下Bean的生命周期：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Spring-Bean生命周期.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外IoC里面有很多的细节点，逐步整理中：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;byType/byName&lt;/td&gt;
      &lt;td&gt;根据类型/名字注入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;scope(singleton/prototype)&lt;/td&gt;
      &lt;td&gt;单例还是每次都生成一个新的Bean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;factory-bean/FactoryBean&lt;/td&gt;
      &lt;td&gt;工厂类型的Bean，getBean时会调用其getObject方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Resource&lt;/td&gt;
      &lt;td&gt;默认byName，找不到的时候就byType(指定name就只能byName了)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Autowire&lt;/td&gt;
      &lt;td&gt;默认byType，可以配合@Qualifier变为byName&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lazy-init&lt;/td&gt;
      &lt;td&gt;只对singleton的Bean起作用，效果是在getBean的时候才初始化&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;面向切面编程&lt;/h2&gt;

&lt;p&gt;面向切面编程(Aspect Oriented Programming)提供了另外一个角度来考虑程序结构，在介绍AOP的时候几乎都会介绍&lt;strong&gt;打日志&lt;/strong&gt;的需求，当然除此之外还有很多的场景，这里就不赘述。简单来说Spring的AOP提供了拦截一批方法的手段。&lt;/p&gt;

&lt;p&gt;其实我们自己也可以利用&lt;strong&gt;BeanFactoryPostProcessor&lt;/strong&gt;来实现类似的功能，但在Spring中AOP强大的地方是提供了很多种方便的配置方式。第一种是用XML的配置方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect id=&quot;logaop&quot; ref=&quot;allLogAdvice&quot;&amp;gt;&amp;lt;!--处理类 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.test.MyService.*(..))&quot; /&amp;gt;&amp;lt;!-- 方法 --&amp;gt;
        &amp;lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&amp;gt;&amp;lt;!-- 方式及调用方法 --&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;

&lt;p&gt;另外一种个人感觉比较好用的就是&lt;strong&gt;@Aspect&lt;/strong&gt;方式，这种方式把方法和它要拦截的方法放在一个地方，比较自然一点：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class MyAspect {
    @Pointcut(&quot;execution(* com.test.MyService.*(..))&quot;)
    private void aspectjMethod(){};

    @Before(&quot;service()&quot;)
    private void aroundMethod(){ /* code */ }
}
&lt;/pre&gt;

&lt;p&gt;在使用前需要配置&lt;strong&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/strong&gt;，第二种方式确实有一些进步，但是考虑注解之后，AOP的功能开始变得有点IMBA了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class LocalCacheAspect {
    @Pointcut(&quot;@annotation(localCache)&quot;)
    public void getLocalCacheAnnotation(LocalCache localCache) {}

    @Around(&quot;getLocalCacheAnnotation(localCache)&quot;)
    public Object handleCache(ProceedingJoinPoint joinPoint, LocalCache localCache) throws Throwable {
        /* code */
    }
}
&lt;/pre&gt;

&lt;p&gt;这样当你在Spring的某个方法上加注解&lt;strong&gt;@LocalCache&lt;/strong&gt;后，就可以被handleCache拦截了，在这里需要注意一下大小写。在具体实现的时候AOP利用了两种技术：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JDK动态代理&lt;/li&gt;
  &lt;li&gt;CGLIB字节码生成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想选择cglib需要配置文件中加上&lt;strong&gt;&amp;lt;aop:aspectj-autoproxy proxy-target-class=”true”/&amp;gt;&lt;/strong&gt;。
AOP中涉及到的细节整理如下(不断更新中)：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Pointcut&lt;/td&gt;
      &lt;td&gt;通常使用正则表达式来描述切入的点(拦截哪些方法)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Advice&lt;/td&gt;
      &lt;td&gt;在特定的Pointcut执行的动作：around、before、throws等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Joinpoint&lt;/td&gt;
      &lt;td&gt;具体运行时拦截到的信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;

&lt;p&gt;细想一下大部分的Java程序员应该都在直接或者间接的做页面开发，那么这里就涉及到分层的概念了，当然这里不会讲这些东西。在WEB应用作用，不能不提&lt;strong&gt;web.xml&lt;/strong&gt;,其中需要清楚&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;listener&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;servlet&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它们的作用以及运行机制，在通过SpringMVC来开发Web应用前，需要配置：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.htm&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/pre&gt;

&lt;p&gt;这样就把所有以&lt;strong&gt;.htm&lt;/strong&gt;结尾的请求都交给&lt;strong&gt;DispatcherServlet&lt;/strong&gt;进行具体的处理并返回，过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常用的&lt;strong&gt;handleMapping&lt;/strong&gt;的方式有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SimpleUrlHandlerMapping&lt;/li&gt;
  &lt;li&gt;DefaultAnnotationHandlerMapping&lt;/li&gt;
  &lt;li&gt;AnnotationMethodHandlerAdapter&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用注解的方式更直观一些，在代码中直接就可以明白你正在处理什么样的请求，最简单的一个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Controller
@RequestMapping(&quot;/helloAnnoController.html&quot;)
public class AnyTypeYouLikeController{
    @RequestMapping(method={RequestMethod.GET,RequestMethod.POST})
    public String processWebRequest(){
        return &quot;anno/helloAnnController&quot;;
    }
}
&lt;/pre&gt;

&lt;p&gt;PS：现在各种WEB框架非常多，关键是了解它们运行机制，在遇到问题的时候可以DEBUG去找到解决办法，对某个框架有哪些“奇技淫巧”就不说了，细节太多了···&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;数据访问&lt;/h2&gt;

&lt;p&gt;首先想想要想是的访问数据更方便，Spring应该做什么事情？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;统一的异常处理&lt;/li&gt;
  &lt;li&gt;将相同（类似）操作进行封装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果直接用JDBC来完成数据访问，大致如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    Connection connection = getDataSource().getConnection();
    Statement statement = connection.createStatement();
    // TODO 执行数据库操作
    statement.executeUpdate(&quot;sql...&quot;);
    statement.close();
}finally{
    statement.close();
    connection.close();
}
&lt;/pre&gt;

&lt;p&gt;显然在使用JDBC API处理数据的时候会有大量相似的代码，不仅增加了代码量，而且使得业务
逻辑不清晰、工程难维护。在Spring中用&lt;strong&gt;JdbcTemplate&lt;/strong&gt;通过模板方式来解决这些问题：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class JdbcTemplate {
    public Object execute(StatementCallback action) throws DataAccessException
    {
       // 将连接数据库等操作抽取出来
    }
}
&lt;/pre&gt;

&lt;p&gt;在JdbcTemplate中定义了很多queryXXX和updateXXX的方法，其本质上还是&lt;strong&gt;Callback&lt;/strong&gt;的方
式实现的，定义出来方便我们使用：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
JdbcTemplate jdbcTemplate = new JdbcTemplate();
jdbcTemplate.setDataSource(ds);
jdbcTemplate.execute(new StatementCallback(){
    public Object doInStatement(Statement stmt) throws SQLException {
        stmt.execute(&quot;your sql&quot;);
        return ret;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样编码起来方便了很多，但是接着会想如果我们把SQL写到单独的文件里面，这样剥离开应该
会更好一下吧，这样就有了各种ORM，比如&lt;strong&gt;iBatis&lt;/strong&gt;和&lt;strong&gt;Hibernate&lt;/strong&gt;，在iBatis中用SqlMapClient
来访问数据，通常访问的方式有三种：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
//1、基于SqlMapCLient的自动提交事务型简单数据访问
Map parameters = new HashMap();
parameters.put(&quot;param1&quot;, value);
// ..
Object ret = sqlMap.queryForObject(&quot;sql_id&quot;, parameters);
// 2、基于SqlMapClient的非自动提交事务型数据访问
try{
    sqlMap.startTransaction();
    sqlMap.update(&quot;....&quot;);
    sqlMap.commitTransaction();
} finally {
    sqlMap.endTransaction();
}
// 3、基于SqlMapSession的数据访问
SqlMapSession session = null;
try{
    session = sqlMap.openSession();
    session.startTransaction();
    session.update(&quot;...&quot;);
    session.commitTransaction();
} finally {
    session.endTransaction();
}
&lt;/pre&gt;

&lt;p&gt;因为Spring在集成iBatis的时候要考虑将事务控制也纳入进来，所以使用基于SqlMapSession
的数据访问方式对iBatis进行集成，这种方式更灵活，可以将iBatis内部直接指定的数据源和事
务管理器等转由外部提供（IoC），&lt;strong&gt;SqlMapClientTemplate&lt;/strong&gt;是Spring为iBatis的数据访问操
作提供的模板方法类：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class SqlMapClientTemplate {
    public Object execute(SqlMapClientCallback action) throws DataAccessException {
        // ...
    }
}
&lt;/pre&gt;

&lt;p&gt;SqlMapClientCallback可以完成任何基于iBatis的数据访问操作，比如要向一个数据库批量提
交更新数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
protected void batchInsert(final List beans) {
    sqlMapClientTemplate.execute(new SqlMapClientCallback() {
        public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
            executor.startBatch();
            Interator iter = beans.iterator();
            while(iter.hasNext()) {
                Bean bean = (Bean) iter.next();
                executor.insert(&quot;insert_name&quot;, bean);
            }
            executor.executeBatch();
            return null;
        }
    });
}
&lt;/pre&gt;

&lt;p&gt;最后来看事务处理，局部事务的话用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    transaction = session.beginTransaction();
    // TODO 操作数据
    session.flush();
    transaction.commit();
} catch (Exception e){
    transaction.rollback(); // 回滚
} finally {
    session.close();
}
&lt;/pre&gt;

&lt;p&gt;因为JDBC的局部事务控制是由同一个Connection来完成的，所以要保证两个DAO的数据访问
方式处于一个事务中，我们就得保证他们使用的是同一个Connection，要做到这一点，通常采
用称为connection-passing的方式，即为同一个事务中的各个DAO的数据访问传递当前事务对
应的同一个Connection。&lt;/p&gt;

&lt;p&gt;我们可以直接使用PlatformTransactionManager，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
definition.setXXX();
definition.setXXX();
TransactionStatus status = transactionManager.getTransaction(definition);
try {
    // TODO 业务逻辑
} catch (Exception e) {
    transactionManager.roolback(status);
}
transactionManager.commit(status);
&lt;/pre&gt;

&lt;p&gt;可以看到上面有很多重复的操作，接着用TransactionTemplate对事务的管理进行模板化。而
基于申明式的事务有四种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ProxyFactory + TransactionInterceptor&lt;/li&gt;
  &lt;li&gt;TransactionProxyFactoryBean&lt;/li&gt;
  &lt;li&gt;BeanNameAutoProxyCreator&lt;/li&gt;
  &lt;li&gt;Spring 2.x申明事务配置方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然也可以通过注解&lt;strong&gt;@Transactional&lt;/strong&gt;来申明事务。&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Guava</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;

&lt;h2 id=&quot;section-2&quot;&gt;学习&lt;/h2&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

</description>
        <pubDate>Sat, 30 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java枚举</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;在JDK 1.5之前通常用final来定义各种常量，现在新加了枚举类型，最简单的用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED,
    GREEN
}
&lt;/pre&gt;

&lt;p&gt;还可以像普通的类那样自己定义属性和方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED(&quot;red&quot;),
    GREEN(&quot;green&quot;);
    String name;

    Color(String name) {
        this.name = name;
    }

    public String toString(){
        return name;
    }
}
&lt;/pre&gt;

&lt;p&gt;甚至enum还可以去实现接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color implements Comparable&amp;lt;Color&amp;gt; {
    RED,
    GREEN;
}
&lt;/pre&gt;

&lt;p&gt;在使用的时候，枚举可以用来比较：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
if(c == Color.GREEN){
    // ...
}
&lt;/pre&gt;

&lt;p&gt;也可以用来switch：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
switch (c) {
    case RED:
    case GREEN:
}
&lt;/pre&gt;

&lt;p&gt;而且你可以很方便的变量一个枚举类型中所有的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
for (Color c : Color.values()) {
    System.out.println(c);
}
&lt;/pre&gt;

&lt;p&gt;甚至在你只知道枚举的变量名的时候也能拿到对应的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
System.out.println(Color.valueOf(&quot;RED&quot;));
&lt;/pre&gt;

&lt;p&gt;看下来，枚举在定义常量上面做了不少友好的封装。&lt;/p&gt;

&lt;h2 id=&quot;vs&quot;&gt;枚举VS常量&lt;/h2&gt;

&lt;p&gt;首先不同的枚举类是不同的类型，而你用final static修饰的一般都是int等基本类型，这样很难做类型检查，这算是Enum比较大的一个优势的优势，在写代码的时候不会传错参数：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void check(Color c){

}
&lt;/pre&gt;

&lt;p&gt;当你传入其他类型参数时会编译出错。&lt;/p&gt;

&lt;h2 id=&quot;enum&quot;&gt;enum到底是什么&lt;/h2&gt;

&lt;p&gt;在编译之后会有一个Color.class文件，使用javap查看：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
final class Color extends java.lang.Enum implements java.lang.Comparable{
    public static final Color RED;
    public static final Color GREEN;
    public static Color[] values();
    public static Color valueOf(java.lang.String);
    static {};
}
&lt;/pre&gt;

&lt;p&gt;该类继承自&lt;strong&gt;java.lang.Enum&lt;/strong&gt;，然后通过&lt;strong&gt;javap -c Color&lt;/strong&gt;来看初始化的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static {};
  Code:
   0:   new     #4; //class Color
   3:   dup
   4:   ldc     #7; //String RED
   6:   iconst_0
   7:   invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   10:  putstatic       #9; //Field RED:LColor;
   13:  new     #4; //class Color
   16:  dup
   17:  ldc     #10; //String GREEN
   19:  iconst_1
   20:  invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   23:  putstatic       #11; //Field GREEN:LColor;
   26:  iconst_2
   27:  anewarray       #4; //class Color
   30:  dup
   31:  iconst_0
   32:  getstatic       #9; //Field RED:LColor;
   35:  aastore
   36:  dup
   37:  iconst_1
   38:  getstatic       #11; //Field GREEN:LColor;
   41:  aastore
   42:  putstatic       #1; //Field $VALUES:[LColor;
   45:  return
&lt;/pre&gt;

&lt;p&gt;这里大家可能会对枚举switch有疑问，我们写代码来看下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void func(Color c){
        switch(c){
            case RED:
            case GREEN:
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;然后用javap -c查看，得到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void func(Color);
  Code:
   0:   getstatic       #2; //Field Test$1.$SwitchMap$Color:[I
   3:   aload_1
   4:   invokevirtual   #3; //Method Color.ordinal:()I
   7:   iaload
   8:   lookupswitch{ //2
                1: 36;
                2: 36;
                default: 36 }
   36:  return
}
&lt;/pre&gt;

&lt;p&gt;可以看到这里switch的其实还是enum类中的ordinal（int），和之前我们对switch的认识是一致的。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 May 2015 04:34:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的ThreadLocal</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;多个线程在调用同一个方法的时候，会有并发问题，解决这种问题最简单的办法就是将数据保存在Thread的自己的结构中，也就是ThreadLocal的作用了。用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class JavaBean {
    static ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;Integer&amp;gt;();

    public void prepare() {
        threadLocal.set(0);
    }

    public void work() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            int val = threadLocal.get();
            val++;
            threadLocal.set(val);
        }
        System.out.println(threadLocal.get());
    }
}

class Worker extends Thread {
    JavaBean bean;

    public Worker(JavaBean bean) {
        this.bean = bean;
    }

    public void run() {
        bean.prepare();
        bean.work();
    }
}

public class ThreadLocalDemo {
    public static void main(String[] args) {
        JavaBean bean = new JavaBean();
        for (int i = 0; i &amp;lt; 100; i++) {
            new Worker(bean).start();
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;从输出中可以看到，多个线程操作同一个threadLocal时，结果并不会出错。&lt;/p&gt;

&lt;p&gt;可以将ThreadLocal看做是对&lt;strong&gt;Thread.threadLocals&lt;/strong&gt;的封装，况且在程序中也是不能直接访问到Thread.threadLocals。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;下面简单看ThreadLocal的原理，在Thread中保存了一个Map，类型可以认为是&lt;strong&gt;Map&amp;lt;ThreadLocal, T&amp;gt;&lt;/strong&gt;，其中T是要保存数据的类型。当要从中取出数据时，调用的流程如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Thread.currentThread().threadLocals.getEntry(threadLocal).value
&lt;/pre&gt;

&lt;p&gt;这样，不同的线程在执行的时候在同一个threadLocal上获取到的是不同的数据，线程之间的隔离性是通过”各自保存不同的Map”来实现的，而看到的threadLocal对象其实是&lt;strong&gt;KEY&lt;/strong&gt;，在操作前get到的是&lt;strong&gt;VALUE&lt;/strong&gt;。其实自己动手做一个线程安全的数据保存的解决方法也是这个思路。&lt;/p&gt;

&lt;p&gt;在ThreadLocalMap中使用的并不是普通的引用保存数据，而是使用&lt;strong&gt;WeakReference&lt;/strong&gt;来做：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;gt; {
    Object value;
    Entry(ThreadLocal k, Object v) {
        super(k);
        value = v;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样如果ThreadLocal被释放了，那么ThreadLocalMap中的Entry也会被释放，不至于造成内存泄露。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
