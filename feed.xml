<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 08 Oct 2016 22:21:48 +0800</pubDate>
    <lastBuildDate>Sat, 08 Oct 2016 22:21:48 +0800</lastBuildDate>
    <generator>Jekyll v3.3.0</generator>
    
      <item>
        <title>用HESSIAN时的属性丢失</title>
        <description>&lt;p&gt;在使用hessian将一个对象序列化、反序列化之后，发现原本有值的一个属性变成了NULL，观察发现在子类、父类有同名属性时会出现。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;问题重现&lt;/h2&gt;

&lt;p&gt;构造测试类：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 父类
class A implements Serializable {
    public Integer a;
}
// 子类
class B extends A {
    public Integer a;
}
&lt;/pre&gt;

&lt;p&gt;序列化方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static byte[] serialize(Object obj) throws IOException {
    ByteArrayOutputStream os = new ByteArrayOutputStream();
    HessianOutput ho = new HessianOutput(os);
    ho.writeObject(obj);
    return os.toByteArray();
}
&lt;/pre&gt;

&lt;p&gt;反序列化方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static Object deserialize(byte[] by) throws IOException {
    ByteArrayInputStream is = new ByteArrayInputStream(by);
    HessianInput hi = new HessianInput(is);
    return hi.readObject();
}
&lt;/pre&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Test
public void testHessian() throws Exception {
    B obj = new B();
    obj.a = 0;
    byte[] bytes = serialize(obj); // 序列化
    obj = (B) deserialize(bytes); // 反序列化
    System.out.println(obj.a); // null
}
&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原因分析&lt;/h2&gt;

&lt;p&gt;首先看序列化的过程，在构造&lt;strong&gt;UnsafeSerializer&lt;/strong&gt;时会遍历类及其父类的所有属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
protected void introspect(Class&amp;lt;?&amp;gt; cl) {
    ArrayList&amp;lt;Field&amp;gt; primitiveFields = new ArrayList&amp;lt;Field&amp;gt;();
    ArrayList&amp;lt;Field&amp;gt; compoundFields = new ArrayList&amp;lt;Field&amp;gt;();
    // 遍历所有父类
    for (; cl != null; cl = cl.getSuperclass()) {
        // 通过反射获取所有的属性
        Field[] fields = cl.getDeclaredFields();
        for (int i = 0; i &amp;lt; fields.length; i++) {
            Field field = fields[i];
            // 忽略transient和static的变量
            if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers()))
                continue;
            field.setAccessible(true);
            // 基本类型和复杂类型分开（这段代码是不是写残了）
            if (field.getType().isPrimitive() || (field.getType().getName().startsWith(&quot;java.lang.&quot;) &amp;amp;&amp;amp; !field.getType().equals(Object.class)))
                primitiveFields.add(field);
            else
                compoundFields.add(field);
        }
    }
    ArrayList&amp;lt;Field&amp;gt; fields = new ArrayList&amp;lt;Field&amp;gt;();
    fields.addAll(primitiveFields);
    fields.addAll(compoundFields);
    _fields = new Field[fields.size()];
    fields.toArray(_fields);
    _fieldSerializers = new FieldSerializer[_fields.length];
    // 构造序列化实现类
    for (int i = 0; i &amp;lt; _fields.length; i++) {
        _fieldSerializers[i] = getFieldSerializer(_fields[i]);
    }
}
&lt;/pre&gt;

&lt;p&gt;然后，遍历序列化各个属性字段来分别进行序列化：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
protected void writeObject10(Object obj, AbstractHessianOutput out) throws IOException {
    // 遍历属性
    for (int i = 0; i &amp;lt; _fields.length; i++) {
        Field field = _fields[i];
        out.writeString(field.getName());
        _fieldSerializers[i].serialize(out, obj); // 序列化
    }
    out.writeMapEnd();
}
&lt;/pre&gt;

&lt;p&gt;处理完的结果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/tianchi.gzt/note/3851da49069dca6c95d6d59ef9f729f2/image.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来看反序列化，拿到值之后设置属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public Object readMap(AbstractHessianInput in, Object obj) throws IOException {
    // ....
    // 循环读取序列化的内容。
    while (!in.isEnd()) {
        Object key = in.readObject();
        // 相同名字的两个属性，拿到的是同一个desrializer。
        FieldDeserializer deser = (FieldDeserializer) _fieldMap.get(key);
        if (deser != null)
            deser.deserialize(in, obj); // 在这里拿到value后设置到对应的属性中。
        else
            in.readObject();
    }
    // .....
}
&lt;/pre&gt;

&lt;p&gt;序列化之后字节中对属性a有两个值，第一个非空，第二个空，那么在反序列化时会对a做两次赋值，第一次的结果为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/tianchi.gzt/note/5dfebe57b317a098df5d26982e3fbc65/image.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第二次的结果为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/tianchi.gzt/note/d33314b2337611bd8f20e709e23435c7/image.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到这里，就已经知道了为啥属性值会丢了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决方法&lt;/h3&gt;

&lt;p&gt;比较简单的办法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;避免在子类中出现与父类同名的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然并卵，现实中往往还是会出现，再想想办法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;找一个没有BUG得HESSION版本或者自己动手改改代码重新打个包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相对简单的改法是：在出现同名时，如果子类中已经有了，那么父类中对应属性直接忽略，代码量很少，只需要加一个&lt;strong&gt;continue&lt;/strong&gt;即可，但是这样改容易挖坑。&lt;/p&gt;

&lt;p&gt;最笨的一个解决办法是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直接用Java原生的序列化方法&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
B obj = new B();
obj.setA(0);
// 序列化
ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
objectOutputStream.writeObject(obj);
// 反序列化
ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
obj = (B) objectInputStream.readObject();
System.out.println(obj.a); // 0
&lt;/pre&gt;

&lt;p&gt;貌似原生的实现效率还是蛮高的，为啥现在都喜欢用hessian呢？&lt;/p&gt;
</description>
        <pubDate>Sat, 08 Oct 2016 00:00:00 +0800</pubDate>
        <link>/%E5%A1%AB%E5%9D%91%E8%AE%B0/2016/10/08/HESSIAN-BUG.html</link>
        <guid isPermaLink="true">/%E5%A1%AB%E5%9D%91%E8%AE%B0/2016/10/08/HESSIAN-BUG.html</guid>
        
        
        <category>填坑记</category>
        
      </item>
    
      <item>
        <title>JSTORM-概述</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/JSTORM-1-1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常见的实时计算方面有两种方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在线分析型数据库（OLAP）&lt;/li&gt;
  &lt;li&gt;流计算&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用阿里云的ADS做OLAP还是很不错的，但是消耗的资源比较大，而流计算的方案则相对比较廉价。因为工作中用JSTORM做实时计算比较多，而且去年JSTORM也正式加入了APACHE（说明其实力不一般啊），所以最近打算总结一下。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;编程&lt;/h2&gt;

&lt;p&gt;消息从源头（spout）流出来以后，流入处理节点（bolt），在处理节点完成之后有可能产生新的消息并流到后面的处理节点，如下图：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt; 
           +-------+    +------+    +------+    
message---&amp;gt;| spout |---&amp;gt;| bolt |---&amp;gt;| bolt |---&amp;gt;
           +-------+    +------+    +------+    
&lt;/pre&gt;

&lt;p&gt;在spout节点需要实现的方法（以IRichSpout为例）如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MySpout implements IRichSpout{
    public void open(Map map, TopologyContext topologyContext, SpoutOutputCollector spoutOutputCollector){
        // 初始化
    }
    public void nextTuple(){
        // 发送消息
    }
    public void ack(Object messageId){
        // 消息消费成功
    }
    public void fail(Object messageId){
        // 消息消费失败
    }
}
&lt;/pre&gt;

&lt;p&gt;相应的bolt节点需要实现的方法（以IRichBolt为例）就要少一些：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyBolt implements IRichBolt {
    public void prepare(Map map, TopologyContext topologyContext, OutputCollector outputCollector) {
        // 初始化
    }
	public void execute(Tuple tuple) {
        // 处理消息
    }
}
&lt;/pre&gt;

&lt;p&gt;在框架中通过调用指定的main方法来创建任务（Topology），下面来看个在本地运行的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void main(String[] args) throws Exception {
    // 开始构建任务结构
    TopologyBuilder builder = new TopologyBuilder();
    builder.setSpout(&quot;my_spout&quot;, new MySpout(), 10); // 设置源头节点及其并发度
    builder.setBolt(&quot;my_bolt&quot;, new MyBolt(), 10).shuffleGrouping(&quot;my_spout&quot;);// 设置处理节点及其并发度
    
    // 伪集群方式运行
    LocalCluster cluster = new LocalCluster();
    cluster.submitTopology(&quot;my_topology&quot;, config, builder.createTopology());

    // 执行一段时间后停止
    Thread.sleep(6000000);
    cluster.shutdown();
}
&lt;/pre&gt;

&lt;p&gt;到这里就明白最简单的JSTORM的任务的在编程时的结构了，下面可以来看其整体上的架构。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;架构&lt;/h2&gt;

</description>
        <pubDate>Thu, 25 Feb 2016 00:00:00 +0800</pubDate>
        <link>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/02/25/JSTORM-1.html</link>
        <guid isPermaLink="true">/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/02/25/JSTORM-1.html</guid>
        
        
        <category>学习笔记</category>
        
      </item>
    
      <item>
        <title>SSL/TLS与安全</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/SSL-2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;坏蛋不会放过任何一丝作恶的机会，当信息在互联网上裸奔时，可能被：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;窃听&lt;/li&gt;
  &lt;li&gt;篡改&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;于是有了SSL(Secure Sockets Layer)及TLS(Transport Layer Security)对数据的传输进行加密。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;数字证书&lt;/h2&gt;

&lt;p&gt;在网络中可能有人冒充服务器：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
客户 to 冒牌服务器：你好
冒牌服务器 to 客户：你好，我是服务器
客户 to 冒牌服务器：我的密码是xxx  
&lt;/pre&gt;

&lt;p&gt;现在悲剧了：密码告诉别人等于把所有的信息都告诉了别人。&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Feb 2016 00:00:00 +0800</pubDate>
        <link>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/02/22/SSL.html</link>
        <guid isPermaLink="true">/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/02/22/SSL.html</guid>
        
        
        <category>学习笔记</category>
        
      </item>
    
      <item>
        <title>在velocity中自定义标签</title>
        <description>&lt;p&gt;用velocity搞html页面很好用，通过一些标签：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;#if&lt;/li&gt;
  &lt;li&gt;#set&lt;/li&gt;
  &lt;li&gt;#foreach&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;几乎能实现所有需要的渲染逻辑。但是，如果能自定义一些标签，就可以更灵活地在vm中玩耍了，尤其是在实现工具的时候。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;自定义标签&lt;/h2&gt;

&lt;p&gt;标签的定义是用velocity的属性来控制的，默认标签的定义存放在：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;org/apache/velocity/runtime/defaults/directive.properties&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中内容为（分别对应&lt;code class=&quot;highlighter-rouge&quot;&gt;#foreach&lt;/code&gt;等标签、属性值为处理类名）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
directive.1=org.apache.velocity.runtime.directive.Foreach
directive.2=org.apache.velocity.runtime.directive.Include
directive.3=org.apache.velocity.runtime.directive.Parse
directive.4=org.apache.velocity.runtime.directive.Macro
directive.5=org.apache.velocity.runtime.directive.Literal
directive.6=org.apache.velocity.runtime.directive.Evaluate
directive.7=org.apache.velocity.runtime.directive.Break
directive.8=org.apache.velocity.runtime.directive.Define
&lt;/pre&gt;

&lt;p&gt;标签（自定义 or 系统的）对应的处理类都需要继承：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;org.apache.velocity.runtime.directive.Directive&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;并实现三个方法：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;getName&lt;/td&gt;
      &lt;td&gt;返回标签名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getType&lt;/td&gt;
      &lt;td&gt;类型，分为LINE和BLOCK两种&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;render&lt;/td&gt;
      &lt;td&gt;渲染方法，所有的实现逻辑在这里实现&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;类型为&lt;strong&gt;LINE&lt;/strong&gt;的标签在使用时不需要&lt;code class=&quot;highlighter-rouge&quot;&gt;#end&lt;/code&gt;来标记结束，而且标签的内容可以分在多行：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
#test(123 \n2)
&lt;/pre&gt;

&lt;p&gt;类型为&lt;strong&gt;BLOCK&lt;/strong&gt;则需要用#end结尾：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
#test(123) abc #end
&lt;/pre&gt;

&lt;p&gt;要想让自己定义的标签生效，需要在velocity初始化时设置属性：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;属性名：&lt;strong&gt;userdirective&lt;/strong&gt;（在velocity中写死的）&lt;/li&gt;
  &lt;li&gt;属性值：你实现的Directive的类全路径&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在我们来看个最简单的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static class Test extends Directive {
    public String getName() {
        return &quot;test&quot;;
    }
    public int getType() {
        return LINE;
    }
    public boolean render(InternalContextAdapter context, 
        Writer writer, 
        Node node) throws IOException, ResourceNotFoundException, ParseErrorException, MethodInvocationException {
        writer.write(&quot;abc&quot;);// 啥都不做，直接输出abc
        return true;
    }
}
&lt;/pre&gt;

&lt;p&gt;然后初始化一个VelocityEngine测试&lt;code class=&quot;highlighter-rouge&quot;&gt;#test&lt;/code&gt;标签：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
VelocityEngine engine = new VelocityEngine();
//.. 省略若干属性设置
engine.addProperty(&quot;userdirective&quot;, &quot;Test&quot;);

Template template = engine.getTemplate(&quot;#test&quot;);
StringWriter writer = new StringWriter();
template.merge(new EasydtContext(), writer);
System.out.println(writer.toString()); // 输出：abc
&lt;/pre&gt;

&lt;p&gt;用标签来实现的功能无非是做一些字符串的处理，处理过程中能拿到的信息都在render方法参数中：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;context&lt;/td&gt;
      &lt;td&gt;保存上下文&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;writer&lt;/td&gt;
      &lt;td&gt;用来输出字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;node&lt;/td&gt;
      &lt;td&gt;抽象语法树中和当前位置对应的节点&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以从节点（node）中拿到一些有意思的信息，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;模板名称&lt;/li&gt;
  &lt;li&gt;行号&lt;/li&gt;
  &lt;li&gt;列号&lt;/li&gt;
  &lt;li&gt;子节点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了这些信息类似&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-velocity/&quot;&gt;这里&lt;/a&gt;实现#cache时就不需要手动传入key了。回到正题，render其实是在抽象语法树上递归下降的过程，比如#foreach中：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// render方法中
node.jjtGetChild(3).render(context, writer);
&lt;/pre&gt;

&lt;p&gt;当然我们也可以继续用上面的例子测试，修改render方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
render(/* ... */){
    StringWriter tmpWriter = new StringWriter();
    node.jjtGetChild(0).render(context, tmpWriter); // 递归执行
    writer.write(tmpWriter.toString());
    return true;
}
&lt;/pre&gt;

&lt;p&gt;测试使用的模板为&lt;code class=&quot;highlighter-rouge&quot;&gt;#test()#if(true)abc#end#end&lt;/code&gt;，输出结果依然是abc。&lt;/p&gt;

&lt;h2 id=&quot;webx&quot;&gt;在webx中扩展&lt;/h2&gt;

&lt;p&gt;在springmvc中设置velocity的属性还是非常简单的（略），但是webx做了相当多的约定性质的扩展（&lt;a href=&quot;http://openwebx.org/docs/springext.html&quot;&gt;参考&lt;/a&gt;），下面来看在webx中自定义velocity标签以及其他扩展的方法，创建文件：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;/META-INF/services-template-engines-velocity-plugins.bean-definition-parsers&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中的内容为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
my-support=com.xxx.MySupportDefinitionParser
&lt;/pre&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;属性：标签名称&lt;/li&gt;
  &lt;li&gt;值：解析实现类，用来解析配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;编辑&lt;strong&gt;my-support.xsd&lt;/strong&gt;，格式可以参考&lt;a href=&quot;http://wsztrush.github.io/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/14/Xml-Schema.html&quot;&gt;这里&lt;/a&gt;，这里就不写了，然后需要实现：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;com.xxx.MySupport&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在其初始化方法（init）中可以对velocity的属性进行设置，具体的实现逻辑可以参考EscapeSupport，最后将添加到webx的配置中：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;services:template xmlns=&quot;http://www.alibaba.com/schema/services/template/engines&quot; searchExtensions=&quot;true&quot;&amp;gt;
    &amp;lt;velocity-engine&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;vm-plugins:my-support/&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/velocity-engine&amp;gt;
&amp;lt;/services:template&amp;gt;
&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;思考和总结&lt;/h2&gt;

&lt;p&gt;自定义标签的功能像是在velocity中开了一个口子，让我们实现自己的逻辑，甚至可以在vm中嵌套使用渲染引擎（在上面的例子中可以看出来这点吧）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用velocity渲染&lt;/li&gt;
  &lt;li&gt;使用自定义的引擎渲染，将最终的结果写到writer中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果将这种看作是在velocity处理后扩展，那么：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有没有办法在velocity之前进行扩展？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答案是肯定的，现在想到的比较简单的方式是在ResourceLoader上做手脚，应该还有其他的思路。&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016/01/21/VELOCITY-DIRECTIVE.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016/01/21/VELOCITY-DIRECTIVE.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>InnoDB</title>
        <description>&lt;p&gt;在用到数据库的时候，很少有人怀疑数据的一致性，更多的是怀疑性能（为此经常在数据库上面加一层缓存）。对数据库的实现比较好奇，所以最近刷了本书：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s26684551.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看完后之前模糊的地方清晰了一些。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;写&lt;/h2&gt;

&lt;p&gt;为了让数据持久化下来，需要将写操作落到磁盘，这样做到数据准确比较简单，但是性能会非常差：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;逻辑复杂&lt;/li&gt;
  &lt;li&gt;磁盘的随机读、写就是性能的噩梦&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;写内存是最快的，但一断电就悲剧了（先忽略带电池的内存），那还得写磁盘。不过现在不是去更新数据，而是&lt;strong&gt;顺序&lt;/strong&gt;地记日志，只要把信息记录下来就可以恢复数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
              +-------------+               
              |    WRITE    |               
              +------+------+               
                     |                      
       +-------------+--------------+       
       |                            |       
+------+------+              +------+------+
|    CACHE    |              |     LOG     |
+-------------+              +-------------+
&lt;/pre&gt;

&lt;p&gt;断电重新开机之后，根据日志里面记录的操作再来一遍就可以把数据还原到内存，恢复完成后继续提供服务。刚才的问题解决了，但是缺点也很明显：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;日志占用空间越来越大&lt;/li&gt;
  &lt;li&gt;恢复时间越来越长&lt;/li&gt;
  &lt;li&gt;内存中不可能存放所有的数据（或者恢复到磁盘上？）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;后台线程在脏页太多、关机、定时触发（等）时把CACHE中的脏页刷到磁盘上，刷完之后就形成一个版本（在InnoDB中有LSN来标记版本号），该版本之前的日志已经不再需要了，这就是&lt;strong&gt;checkpoint&lt;/strong&gt;技术。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;读&lt;/h2&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/01/18/INNODB.html</link>
        <guid isPermaLink="true">/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/2016/01/18/INNODB.html</guid>
        
        
        <category>学习笔记</category>
        
      </item>
    
      <item>
        <title>进入Linux的世界</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/LINUX-MINT-1.png&quot; width=&quot;500px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;断断续续地用过一段时间&lt;strong&gt;Ubuntu&lt;/strong&gt;，但也只是玩玩而已，一直没有勇气抛弃&lt;strong&gt;Windows&lt;/strong&gt;。后来公司要求安装的软件越来越多（各种杀毒、监控）、开机速度越来越慢、看着越来越红的C盘，是时候开启Linux了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;的界面有点丑，于是这次尝试用&lt;strong&gt;Linux Mint Cinnamon&lt;/strong&gt;，安装方式很常规：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载镜像&lt;/li&gt;
  &lt;li&gt;用dd命令刻录到U盘&lt;/li&gt;
  &lt;li&gt;按照提示一路设置就可以了&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来开始安装需要的软件。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一、文本编辑&lt;/h3&gt;

&lt;p&gt;自带的vi和gedit能用，但需要更强大的（VIM）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install vim
&lt;/pre&gt;

&lt;p&gt;关于VIM的用法可以看&lt;a href=&quot;http://wsztrush.github.io/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html&quot;&gt;《VIM入门》&lt;/a&gt;，虽然强大但现在并不熟练，于是想起来在Windows上用的挺爽的&lt;strong&gt;sublime text&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install sublime-text
&lt;/pre&gt;

&lt;p&gt;结果发现和Windows版的有点区别：无法输入中文。感兴趣的可以看&lt;a href=&quot;http://jingyan.baidu.com/article/f3ad7d0ff8731609c3345b3b.html&quot;&gt;这里&lt;/a&gt;，不过由于&lt;strong&gt;VSCODE&lt;/strong&gt;突然火了一把赶紧从&lt;a href=&quot;https://www.visualstudio.com/&quot;&gt;官网&lt;/a&gt;下载，用着还不错，到现在还用它来开发前端代码。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、浏览器&lt;/h3&gt;

&lt;p&gt;自带的火狐还不错，但是团队做的系统目前只考虑兼容Chrome，只好去下载个。。。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、前端开发环境&lt;/h3&gt;

&lt;p&gt;对前端来说&lt;strong&gt;nodejs&lt;/strong&gt;是必须的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install nodejs
sudo apt-get install npm
&lt;/pre&gt;

&lt;p&gt;为了顺畅使用可以考虑切成&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;淘宝镜像&lt;/a&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
npm config set registry https://registry.npm.taobao.org
&lt;/pre&gt;

&lt;p&gt;打包工具使用&lt;a href=&quot;http://www.gruntjs.net/&quot;&gt;Grunt&lt;/a&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
npm install -g grunt-cli
&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;四、后端开发环境&lt;/h3&gt;

&lt;p&gt;工作中后端开发使用的是Java，貌似系统自带了JDK不过不全，只能自己动手：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install openjdk-7-jdk
&lt;/pre&gt;

&lt;p&gt;记得在&lt;strong&gt;~/.bashrc&lt;/strong&gt;设置变量：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH
&lt;/pre&gt;

&lt;p&gt;另外maven是少不了的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install maven2
&lt;/pre&gt;

&lt;p&gt;代码编辑使用IDEA，直接从官网下载就可以了（14一直有BUG，现在用的是13）。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;五、输入法&lt;/h3&gt;

&lt;p&gt;用过搜狗，但是偶尔BUG，现在用ibus：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
sudo apt-get install ibus-rime ibus-gtk* ibus-qt4
&lt;/pre&gt;

&lt;p&gt;下载之后学了一段时间双拼，后来想想为啥要在这上面浪费时间，于是果断换回全拼，囧。在排查线上问题的时候需要用到很多命令，在压力巨大的情况下不一定能打出来，那么可以在输入法上做一点文章：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/LINUX-MINT-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在【Edit custom phrase】里面加入：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gc=jstat -gcutil&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在可以“临危不乱”了:)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/LINUX-MINT-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其实之前一直觉得配上机械键盘敲键盘熟练地敲命令挺爽的，但是最近登录跳板的那么一大串命令实在是有点烦了。。。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;六、聊天工具&lt;/h3&gt;

&lt;p&gt;工作一直用旺旺，但Linux上这货BUG太多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;刚启动CPU一直是100%&lt;/li&gt;
  &lt;li&gt;用一段时间界面就乱了，测试了下关闭一些特效会稍微好点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了旺旺尝试过用&lt;strong&gt;Oracle VM VirtualBox&lt;/strong&gt;装Windows虚拟机，但是没搞定（囧），以后有时间继续。好在公司现在要转钉钉，有WEB版，幸福感飙升。。。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;七、图片&lt;/h3&gt;

&lt;p&gt;用Visio画图很方便，可惜Linxu上没有，可以考虑用yEd，从&lt;a href=&quot;http://www.yworks.com/&quot;&gt;官网&lt;/a&gt;下载后执行脚本：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;xxxxxxx_setup.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然你可以可以考虑用VIM来画图（可以看&lt;a href=&quot;http://wsztrush.github.io/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2016/01/05/VIM-PAINT.html&quot;&gt;这里&lt;/a&gt;），用来对付简单的图还是比较给力的。&lt;/p&gt;

&lt;p&gt;之前一直使用旺旺的截图，现在不行来，感觉&lt;strong&gt;shutter&lt;/strong&gt;还是不错的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo apt-get install shutter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-7&quot;&gt;八、博客&lt;/h3&gt;

&lt;p&gt;博客使用jekyll来搞的，需要安装ruby（因为jekyll对ruby版本有要求，只能下源码搞了）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
tar xzvf ruby-2.2.2.tar.gz 
cd ruby-2.2.2
./configure –prefix=/usr/local/ruby  
make &amp;amp;&amp;amp; make install
&lt;/pre&gt;

&lt;p&gt;刚开始因为python3没有向后兼容一直报错，把版本退回去才搞定。。。同样如果你是墙内用户可以考虑用淘宝的源：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
gem sources --remove https://rubygems.org/
gem sources -a http://ruby.taobao.org/
&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;九、总结&lt;/h3&gt;

&lt;p&gt;用了有几个月了，平常的使用已经慢慢熟悉起来了，而且感觉【工作区】的功能还是挺炫的（Ctrl+Alt+【方向键】），也比较实用。而且使用Linux会让你有一种&lt;strong&gt;everything is under control&lt;/strong&gt;的错觉:)&lt;/p&gt;

&lt;p&gt;总的来说：值得拥有！&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E4%BD%9C/2016/01/17/LINUX.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E4%BD%9C/2016/01/17/LINUX.html</guid>
        
        
        <category>工作</category>
        
      </item>
    
      <item>
        <title>必然</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s28377994.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;还没看过《失控》有点遗憾，再加上罗胖极力推荐，于是带着很大的期望来看《必然》。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;内容&lt;/h2&gt;

&lt;p&gt;对未来三十年的一些预测，通过十二个关键字来概括。&lt;/p&gt;

&lt;h3 id=&quot;becoming&quot;&gt;一、形成（Becoming）&lt;/h3&gt;

&lt;p&gt;技术不断的发展，每天都在变得更好一点，但是这种进步通常不被察觉，在不断的升级中我们将永远都是菜鸟，所谓的“进乌托邦”。&lt;/p&gt;

&lt;h3 id=&quot;cognifying&quot;&gt;二、知化（Cognifying）&lt;/h3&gt;

&lt;p&gt;在各个领域出现高度的智能化：医学、化学实验等，机器人将代替绝大多数的机械劳动。&lt;/p&gt;

&lt;h3 id=&quot;flowing&quot;&gt;三、流动（Flowing）&lt;/h3&gt;

&lt;p&gt;一个东西一旦可以复制，那么很快就会变得廉价甚至免费（想想你产出的东西是不是可复制的），比免费更重要的一些属性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;及时性&lt;/li&gt;
  &lt;li&gt;个性化&lt;/li&gt;
  &lt;li&gt;解释性：比如给你DNA序列也没用啊，你需要的是如何去解释这个序列&lt;/li&gt;
  &lt;li&gt;可靠性&lt;/li&gt;
  &lt;li&gt;获取权：获取服务&lt;/li&gt;
  &lt;li&gt;实体化&lt;/li&gt;
  &lt;li&gt;可赞助&lt;/li&gt;
  &lt;li&gt;可寻性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流动意味着处理的将不再是静止的，会具有更高的实时性，以后我们更多的是会去面对信息流。&lt;/p&gt;

&lt;h3 id=&quot;screening&quot;&gt;四、屏读（Screening）&lt;/h3&gt;

&lt;p&gt;可以通过屏幕获取几乎所有需要的信息。&lt;/p&gt;

&lt;h3 id=&quot;accessing&quot;&gt;五、使用（Accessing）&lt;/h3&gt;

&lt;p&gt;简单来说就是：租比买好！在提供服务上有几个趋势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;减物质化&lt;/li&gt;
  &lt;li&gt;去中心化&lt;/li&gt;
  &lt;li&gt;即时性&lt;/li&gt;
  &lt;li&gt;平台协同&lt;/li&gt;
  &lt;li&gt;云&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用可以是按需获取到更优质的服务（所以罗胖卖房？）。&lt;/p&gt;

&lt;h3 id=&quot;sharing&quot;&gt;六、共享（Sharing）&lt;/h3&gt;

&lt;p&gt;由很多人来共同完成看似不可能的事情：维基百科（或者linux？）。&lt;/p&gt;

&lt;h3 id=&quot;filtering&quot;&gt;七、过滤（Filtering）&lt;/h3&gt;

&lt;p&gt;信息产生的速度飞快，过滤意味着让用户更好的选择感兴趣的信息，而我们则需要花心思让用户注意到我们。&lt;/p&gt;

&lt;h3 id=&quot;remixing&quot;&gt;八、重混（Remixing）&lt;/h3&gt;

&lt;p&gt;对已有的事物的重新排列和再利用（在视频剪切中非常常见）。&lt;/p&gt;

&lt;h3 id=&quot;interacting&quot;&gt;九、互动（Interacting）&lt;/h3&gt;

&lt;p&gt;虚拟现实会带来非常好的互动效果，不能互动的东西在未来将被认为是坏的。&lt;/p&gt;

&lt;h3 id=&quot;tracking&quot;&gt;十、追踪（Tracking）&lt;/h3&gt;

&lt;p&gt;通过硬件、互联网来“追踪”获取信息，通过人工智能来“追踪”信息的价值。&lt;/p&gt;

&lt;h3 id=&quot;questioning&quot;&gt;十一、提问（Questioning）&lt;/h3&gt;

&lt;p&gt;每找到一个答案的时候就会产生两个新的问题，互联网会有很多很多的不可能，在网络上找到答案的成本很低，好的问题价值非常大。&lt;/p&gt;

&lt;h3 id=&quot;beginning&quot;&gt;十二、开始（Beginning）&lt;/h3&gt;

&lt;p&gt;所有的都已经开始，但也仅仅是个开始。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;书中的很多内容其实有想过（或者跟别人聊过），未来已来，只是尚未流行。以后需要多接触新的东西，并思考这些新东西的本质。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;可能跟翻译也有点关系，感觉有点乱（读起来不是很顺畅），不过还是值得一读。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/10/THE-INEVITABLE.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/10/THE-INEVITABLE.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>创造:只给勤奋者的创新书</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.doubanio.com/mpic/s28351737.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;公司里面比较鼓励员工写专利（有奖金），但是，看了很多通过的专利文档后简直颠覆了对专利的看法：怎么什么都能申请专利？如果你有一样的想法，看完这本书可能就没了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;内容&lt;/h2&gt;

&lt;p&gt;书的原名叫《How To Fly A Horse》，译者翻译为《创造》虽然很朴实但挺准确的，这本书整本都围绕着创造（或者创新）。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;一、创造很寻常&lt;/h3&gt;

&lt;p&gt;爱德蒙（一个十二岁的非洲奴役）解决了难倒欧洲几百年的香草授粉的难题，可见创造本身并没有特别的门槛！我们知道“爱德蒙手势”，但并不知道：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;是谁第一次发现兰花的果实可以加工变成美味。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这难道不是创造吗？还有很多很多的了不起的发现不为所知，但是并不代表它们不存在。现在有了专利系统可以统计一下创造发明的情况：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每4000个美国人就有一个人申请专利。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;可见专利（或者创造）并不是极少数精英的专属领域（把创造者拉下神坛），那么再回过头来看什么是创造：&lt;strong&gt;创造就是工作&lt;/strong&gt;（把创造拉下神坛）。特曼搞优生学，想搞个实验来证明智商是门槛，结果却是打脸（用这个例子来证明IO和创造没关系，逻辑性不是特别强吧）。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;二、思考就像散步&lt;/h3&gt;

&lt;p&gt;思考过程是一步一个脚印（遇到问题、解决问题、遇到问题..）的，就像散步！用&lt;strong&gt;利用图钉、火柴把蜡烛固定在墙上&lt;/strong&gt;实验来证明思考的过程，并对一些“顿悟”提出质疑：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阿基米德洗澡的时候想到鉴别皇冠的方法&lt;/li&gt;
  &lt;li&gt;忽必烈的诗是在梦中想到的&lt;/li&gt;
  &lt;li&gt;梦中发现苯的环状结构&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用爱因斯坦的话来将问题的解决就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我是一步一步朝它迈进的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所以不要太期望在睡梦中孵化出“啊哈！时刻”，你应该花尽量多的时间思考！&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;三、遇见逆境&lt;/h3&gt;

&lt;p&gt;在福克曼利用杀死肿瘤周围的血管来饿死癌细胞的方法解救了詹妮弗的下巴之前：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不能出版文章&lt;/li&gt;
  &lt;li&gt;不能收到资助&lt;/li&gt;
  &lt;li&gt;不能做外科手术&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;甚至被除名，当他成功以后却成了哈佛大学的骄傲。在创造的过程中会遇到很多的逆境和失败，需要非常坚韧地去坚持，去证明自己是正确的。&lt;/p&gt;

&lt;p&gt;如果不想着证明自己但却到处喊口号，可能会像赛迈尔维斯那样，虽然拯救了无数孕妇的生命，但结局却是在精神病院里被打死，而更重要的是错过了细菌的发现：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;非同寻常的发现需要非同寻常的证明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;遇到逆境有时候要以退为进，反思自己的思路是否正确（不反思的下场就是跳伞摔死的瑞切特）。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;四、如何去看&lt;/h3&gt;

&lt;p&gt;有时候重大的发现就在眼皮低下，但就是没人看到，比如&lt;strong&gt;幽门螺旋杆菌&lt;/strong&gt;（传统认为胃酸里面不可能存在细菌）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我倾向于相信我的眼睛，而不是医学教材或者医学界同仁！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在眼睛看到图像交给大脑的过程中，会对信息利用已有的知识做一系列的过滤，以至于我们只能看到关心的东西：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;医学专家能看一眼X光片就知道出了什么问题，但没发现其中的猩猩&lt;/li&gt;
  &lt;li&gt;国际大师下象棋时只需要考虑很少的可能走法，而新手需要考虑更多的可能性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一种高效的机制（很有好处），但是会阻碍发现新的东西：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;技艺的真正秘诀是永远当一个初学者！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;所谓的“不忘初心”？&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;五、应授予荣誉时&lt;/h3&gt;

&lt;p&gt;罗莎琳德·富兰克林是发现DNA双螺旋结构过程中最重要的一环，但是荣誉却给了沃森和克里克，一直以来女性都不公平！这章有点像在讲野史。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;六、结果之链&lt;/h3&gt;

&lt;p&gt;创造新事物的链条长的不可预测（可口可乐的生产过程），而创造的结果更难预测。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;七、创造的动力&lt;/h3&gt;

&lt;p&gt;伍迪·艾伦获得过很多的奥斯卡，但是都没有去领奖（领完奖可能就写不出来了）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当你真正坐下来写作时，感觉就像在吃一顿你在厨房里花一整天做出来的饭。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内在因素（感觉有点像兴趣的力量）才是创造真正的动力，而外在（比如钱）的常常会形成阻碍。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;八、创造型组织&lt;/h3&gt;

&lt;p&gt;二战期间Skonk工厂用184天造出来喷气式飞机：8-80流星战斗机，创造型组织在有不同的观点产生时应该给它们机会，当：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;约翰逊认为飞机模型不稳定的时候&lt;/li&gt;
  &lt;li&gt;里奇设计出隐形飞机的时候&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给他们&lt;strong&gt;证明给你看&lt;/strong&gt;的机会，当然是用行动而不是嘴巴去证明！&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;九、再见了，天才&lt;/h3&gt;

&lt;p&gt;没有天才，每个人都有天赋。&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;思考&lt;/h2&gt;

&lt;p&gt;整体上看内容并没有安排的特别清晰，不同章节想要表达的意思重复，内容有点冗余。不过，里面穿插了很多不错的故事。看完这本书之后一个感觉就是让你：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不要在想“我做不到”、“我创造不出什么”！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;你可以的！有点鸡汤的味道。。而创造需要的是什么？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;激情&lt;/li&gt;
  &lt;li&gt;高度的专注和大量的时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而不是做着白日梦等待顿悟，不过在作者看来潜意识对思考好像没什么作用，创新都是靠着一步一步思考出来的，这一点我还是持怀疑的态度。另外，虽然看完这本说，我还是觉得世界上存在天才:-)&lt;/p&gt;

&lt;p&gt;作为一个程序猿如何创造？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;专业知识&lt;/li&gt;
  &lt;li&gt;不要为了做项目而做项目&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不要在开发的过程中把现有的框架当成理所当然（当成初学者），去思考问题的本质是什么，去思考如何解决问题！&lt;/p&gt;

&lt;h2 id=&quot;section-11&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;逻辑不强，故事不错，值得一读（快读）。&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/09/HOW-TO-FLY-A-HORSE.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2016/01/09/HOW-TO-FLY-A-HORSE.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>用VIM画图</title>
        <description>&lt;p&gt;在Linux上其实并不缺少画图软件（比如yEd等），那么为什么还需要用VIM来画图：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;更轻，不需要安装太多东西&lt;/li&gt;
  &lt;li&gt;更小，就是一些文本，比图片什么的小多了，使用起来也更简单&lt;/li&gt;
  &lt;li&gt;更有逼格&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先，在VIM中安装DrawIt插件（可以参考&lt;a href=&quot;http://wsztrush.github.io/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html&quot;&gt;这里&lt;/a&gt;），然后就可以开始画图之旅，在命令模式下使用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\di&lt;/code&gt;：开启DrawIt&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;\ds&lt;/code&gt;：关闭DrawIt&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开启之后有两种模式：&lt;strong&gt;画图&lt;/strong&gt;和&lt;strong&gt;擦除&lt;/strong&gt;，他们之间通过&lt;strong&gt;空格&lt;/strong&gt;来切换。可以使用按键来控制向八个方向画线（或者擦除）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;方向键的上、下、左、右分别对应其四个方向&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pgup&lt;/strong&gt;：上右&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Pgdn&lt;/strong&gt;：下右&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Home&lt;/strong&gt;：左上&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;End&lt;/strong&gt;：左下&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如下图（其实也不需要记，和键盘上的位置是一致的）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
                         Home    Up   Pgup
                             \   |   / 
                              \  |  / 
                               \ | / 
                                \|/ 
                        Left----------Right
                                /|\
                               / | \
                              /  |  \
                             /   |   \
                          End   Down  Pgdn

&lt;/pre&gt;

&lt;p&gt;箭头的画法也很直观，简单的箭头用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;^&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt;就搞定了，粗的箭头可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;\&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\&amp;lt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\^&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;\v&lt;/code&gt;来弄（感觉粗的箭头不太好控制）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
 &amp;gt; &amp;lt; ^ v  |&amp;gt; &amp;lt;|
              
   _ _      . 
   \ /     /_\
    '         
&lt;/pre&gt;

&lt;p&gt;用鼠标可以选择块，这对后面的操作有一定的简化，利用用&lt;code class=&quot;highlighter-rouge&quot;&gt;\a&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;\l&lt;/code&gt;不带箭头）来根据选中的块来画线：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
-------                               
       \-----------                   
                   \-----------       
                               \-----&amp;gt;
&lt;/pre&gt;

&lt;p&gt;或用&lt;code class=&quot;highlighter-rouge&quot;&gt;\b&lt;/code&gt;来画矩形框或者用&lt;code class=&quot;highlighter-rouge&quot;&gt;\e&lt;/code&gt;来画椭圆：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
+--------------------+          *************      
|                    |      ****             ****  
|                    |    **                     **
+--------------------+    *                       *
                          **                     **
                            ****             ****  
                                *************      
&lt;/pre&gt;

&lt;p&gt;完事了可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;\f&lt;/code&gt;来对图形进行填充：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
+------------------+
|##################|
|##################|
|##################|
+------------------+
&lt;/pre&gt;

&lt;p&gt;位置有一些偏差是常有的事情，这时候不要急着重画：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用鼠标选中要移动的块，然后按住ctrl并拖动鼠标。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当要擦除一整快的内容时，用方向键来搞也比较蛋疼，可以用：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用鼠标选中要擦除的部分，然后执行r &amp;lt;space&amp;gt;（相当于用空格替换）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外需要注意：ubuntu和mint上安装到VIM默认是不支持&lt;strong&gt;系统剪贴板&lt;/strong&gt;的，需要安装：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;sudo apt-get install vim-gnome&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单体验下来，如果能灵活运用VIM本身的强大功能（复制、粘贴等），DrawIt用起来还是挺给力的！&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Jan 2016 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2016/01/05/VIM-PAINT.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2016/01/05/VIM-PAINT.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>NETTY基础知识</title>
        <description>&lt;p&gt;网络IO总体上分为（&lt;a href=&quot;http://www.cnblogs.com/Anker/p/3254269.html&quot;&gt;这里&lt;/a&gt;的比喻不错）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阻塞&lt;/li&gt;
  &lt;li&gt;非阻塞&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;阻塞的方式写起来很简单：当链接可读的时候就读一些，不可读的时候就等待：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ServerSocket serverSocket = new ServerSocket(8787);
while (true) {
    Socket socket = serverSocket.accept();
    // TODO 交给线程池进行处理。
}
&lt;/pre&gt;

&lt;p&gt;网络情况不好时阻塞的方式用起来有点蠢，用NIO（有点像SELECT/EPOLL）会靠谱些，当有链接可读时让工作线程来拿数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Selector selector = Selector.open();

ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
serverSocketChannel.socket().bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 8787));
serverSocketChannel.configureBlocking(false);
serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);

while (true) {
    selector.select();
    Set&amp;lt;SelectionKey&amp;gt; selectionKeySet = selector.selectedKeys();
    Iterator&amp;lt;SelectionKey&amp;gt; iterator = selectionKeySet.iterator();
    while (iterator.hasNext()) {
        SelectionKey selectionKey = iterator.next();
        if (selectionKey.isAcceptable()) {
            ServerSocketChannel channel = (ServerSocketChannel) selectionKey.channel();
            SocketChannel socketChannel = channel.accept();
            socketChannel.configureBlocking(false);
            socketChannel.register(selector, SelectionKey.OP_READ);
        }
        if (selectionKey.isReadable()) {
            SocketChannel socketChannel = (SocketChannel) selectionKey.channel();
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
            int size = socketChannel.read(byteBuffer);
            if (size &amp;lt; 0) {
                selectionKey.cancel();
                socketChannel.close();
            }
            for (int i = 0; i &amp;lt; size; i++) {
                System.out.print((char) byteBuffer.get(i));
            }
        }
        iterator.remove();
    }
}
&lt;/pre&gt;

&lt;p&gt;写最简单的功能都要这么多代码，维护起来也比较痛苦，下面来看如何用NETTY简化开发！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;下面的代码用来实现上面的功能：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
EventLoopGroup bossGroup = new NioEventLoopGroup();
EventLoopGroup workerGroup = new NioEventLoopGroup();
ServerBootstrap bootstrap = new ServerBootstrap();
bootstrap.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, 1024)
        .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
            protected void initChannel(SocketChannel ch) throws Exception {
                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
                        ByteBuf buffer = (ByteBuf) msg;
                        int size = buffer.readableBytes();
                        for (int i = 0; i &amp;lt; size; i++) {
                            System.out.print((char) buffer.getByte(i));
                        }
                    }
                });
            }
        });
ChannelFuture future = bootstrap.bind(8787).sync();
future.channel().closeFuture().sync();
&lt;/pre&gt;

&lt;p&gt;看起来也不怎么直观，不要急，先来了解一些NETTY中的概念：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;概念&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Bootstrap/ServerBootstrap&lt;/td&gt;
      &lt;td&gt;配置netty（添加组件、设置参数）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Channel&lt;/td&gt;
      &lt;td&gt;定义I/O操作&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ChannelHandlerContext&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ChannelHandler&lt;/td&gt;
      &lt;td&gt;处理感兴趣的事件（read、readomplete、bind、flush等）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ChannelPipeline&lt;/td&gt;
      &lt;td&gt;ChannelHandler的容器&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EventLoop/EventLoopGroup&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Future/Promise&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unsafe&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ByteBuf&lt;/td&gt;
      &lt;td&gt;处理缓存的工具，比byte[]或者java.nio.ByteBuffer好用一些&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Tue, 29 Dec 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/29/NETTY-BASIC.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/29/NETTY-BASIC.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
