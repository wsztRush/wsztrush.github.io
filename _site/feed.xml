<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 21 Dec 2015 14:58:44 +0800</pubDate>
    <lastBuildDate>Mon, 21 Dec 2015 14:58:44 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>从下向上来开发</title>
        <description>&lt;p&gt;因为在公司接触业务比较少，更多的是在想办法做一些工具来帮助快速开发，过程中感觉做业务的思路与做工具（系统）的思路差别比较大。下面分享一下在两个模块中的思考过程。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;获取数据&lt;/h2&gt;

&lt;p&gt;团队做的业务复杂无比，几百张的数据表导致有非常非常多的报表，通常的做法是这样的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;iBatis(SQL)&lt;/li&gt;
  &lt;li&gt;DAO+DO&lt;/li&gt;
  &lt;li&gt;Manager&lt;/li&gt;
  &lt;li&gt;Web+VO&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;几十张报表开发起来非常痛苦，而且大部分的代码实现的功能都是&lt;strong&gt;相似&lt;/strong&gt;的！说到相似，那么是不是把不同的部分（取数逻辑）独立出来，相同部分进行复用即可：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;配置一个数据接口只需要填写一段SQL就可以了！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其他的操作（数据库、返回数据）不需要你再关心了。YY了一下大部分的需求用SQL绝对绰绰有余，这件事情就这样结束了！&lt;strong&gt;图样图森破啊&lt;/strong&gt;！！马上遇到了这样的需求：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
{
    title : &quot;xxx&quot;,
    data : [1, 2, 3, 4, 5, 6, 7, 8]
}
&lt;/pre&gt;

&lt;p&gt;还有这样（一些常量）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
[
    {text : &#39;A&#39;, value : 1},
    {text : &#39;B&#39;, value : 2}
]
&lt;/pre&gt;

&lt;p&gt;于是火速开发了更多的功能组件来解决问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;MYSQL&lt;/li&gt;
  &lt;li&gt;MYSQL-XXX&lt;/li&gt;
  &lt;li&gt;JSON&lt;/li&gt;
  &lt;li&gt;VELOCITY&lt;/li&gt;
  &lt;li&gt;XXXX&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组件越来越多，“新手”进来已经不是特别了解每个的具体含义，配置的成本也越来越大。感觉系统用起来并不想当初想的那么美好！&lt;/p&gt;

&lt;p&gt;停下来想一下，从一开始的目标：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我要一个可以干啥干啥的功能！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在实现起来没有任何的拐弯抹角，一步到位完成之后没有考虑过：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;系统有多少的灵活性、可以从哪些方面扩展？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仔细想了一想，我们对系统进行了简单的改造：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;利用GROOVY脚本极大的灵活性，让系统的适应能力也有所提高！虽然花了很多业务时间来研究ACE的功能来提高编辑体验，但是还是有非常多的同一种吐槽：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写脚本的学习成本太高！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更郁闷的是来吐槽的都是“资深”JAVA开发工程师（GROOVY和JAVA不是很像么）！在现在的系统上面只需要实现一个方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static Ojbect execute(){
    return [1, 2, 3];
}
&lt;/pre&gt;

&lt;p&gt;即可通过RPC或者HTTP获取数据（在底层已经将参数传递等东西都封装完成），作为一个程序猿对这样写一小段脚本就能实现的方式挺亲切的，不明白为啥其他的同是开发对这种方式极其的排斥，以至于我几乎没有机会去讲我夹下来要做的事情。&lt;/p&gt;

&lt;p&gt;接下来要做什么呢？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;脚本再简单也只能开发来写，那像原来只会SQL的人就用不来这个系统了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;显然不能让这种情况发生，解决办法也非常简单：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;写一个通用解决问题的脚本&lt;/li&gt;
  &lt;li&gt;在执行时，将SQL、数据源信息通过参数传给对应的通用脚本执行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如一个查询数据库的脚本如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static Object execute(sql, datasource){
    // 1. 根据datasource获取数据源
    // 2. 指定sql
    // 3. 返回执行结果
}
&lt;/pre&gt;

&lt;p&gt;而此时用户看到的配置页面就小白很多了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;保存时会将其填写的信息以及要使用的目标脚本一起保存下来，执行时将参数传给指定的脚本执行即可（是不是有点像带参数的ln）。&lt;/p&gt;

&lt;p&gt;将该功能开放给各个业务系统，那么就可以自己去做各自需要的小白配置页面了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组装页面&lt;/h2&gt;

&lt;p&gt;缺前端是个普遍的问题，如果能将前端的开发简化到后端也能参与，也许能在一定程度上得到解决。&lt;/p&gt;

&lt;p&gt;首先，把页面上的各个部分抽象成组件：&lt;strong&gt;组件=数据+动作+展示&lt;/strong&gt;。比如带下拉列表的选择输入框：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据：列表中的内容以及当前展示的内容&lt;/li&gt;
  &lt;li&gt;动作：内容发生改变&lt;/li&gt;
  &lt;li&gt;展示：可以用bootstrap等前段框架实现&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在使用的时候就非常简单了（一行代码相当于原来20行左右的HTML+JS）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@input(label=&quot;仓库&quot; name=&quot;warehouse&quot; items=[{text:&quot;A&quot;, value:&quot;1&quot;},{text:&quot;B&quot;, value:&quot;2&quot;}])
&lt;/pre&gt;

&lt;p&gt;直观上干了两件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用组件输入框（input）&lt;/li&gt;
  &lt;li&gt;设置一些属性（label、name、items）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那展示呢？这个显然不应该交给用户来操心，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;需要引入哪些CSS、JS？&lt;/li&gt;
  &lt;li&gt;对应的DOM结构应该是什么样的？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了达到这种效果，一个组件的定义可以是这样的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@import(
    &#39;bootstrap.css&#39; // 依赖的CSS文件（需要的时候也可以加JS）
)
@component
    this.width = &#39;10px&#39;; // 一些默认的数据

    @render  // 在render下定义渲染（有点像JSX吧）
    &amp;lt;ul&amp;gt;
        for(i in items){
            &amp;lt;li&amp;gt;${items[i]}&amp;lt;/li&amp;gt;
        }
    &amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在做的过程中发现一些好玩的问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JS的资源不一定适合SEAJS来加载，因为JS之间可能有依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;渲染DOM的部分类似JSX，但更暴力：&lt;strong&gt;支持JavaScript的各种控制结构&lt;/strong&gt;，但这一点是有代价的。仔细想一下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;JavaScript和HTML的语法之间天然就是彼此隔离的，除了‘&amp;lt;’之外。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那做到上面这种模板语法也就比较简单自然了。到这里组件就变为一个&lt;strong&gt;方便定制&lt;/strong&gt;、&lt;strong&gt;高度聚合&lt;/strong&gt;的东西了！但是光聚合没用啊，需要把他们拼装成一个页面，需要解决：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;布局（把组件拼装成一个完整的区块甚至页面）&lt;/li&gt;
  &lt;li&gt;数据交互（组件之间建立关联）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单想了一种方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;利用&lt;strong&gt;缩进&lt;/strong&gt;来控制层次关系&lt;/li&gt;
  &lt;li&gt;利用&lt;strong&gt;@on&lt;/strong&gt;来进行组件关联&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@layout// 布局
    @input(name=&quot;a&quot;)
    @input(name=&quot;b&quot;)
    @input(name=&quot;c&quot;)
    @button(label=&#39;查询&#39;)// 查询
        @on(click)
            // 1. 获取a、b、c的数据
            // 2. 请求数据
            // 3. 更新table、page的展示
@layout
    @table // 表格
    @page// 分页
&lt;/pre&gt;

&lt;p&gt;当点击查询按钮时，根据三个输入框（a、b、c）的内容查询数据并更新表格的展示。最后我们需要将该页面放到业务系统中，做法也非常的‘土’：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;script&amp;gt;
engine.init(&quot;page&quot;, document.body);// 将page对应的页面渲染到body下面。
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;渲染的位置你可以随意指定。到这里用法就说完了，下面来看如何实现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;模块很简单，我用SEAJS的方法，但是作了一些简化和定制。组件的操作包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用组件（添加到父组件的children列表中）&lt;/li&gt;
  &lt;li&gt;设置属性&lt;/li&gt;
  &lt;li&gt;绑定事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;HTML的操作包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建标签&lt;/li&gt;
  &lt;li&gt;设置属性&lt;/li&gt;
  &lt;li&gt;绑定事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;既然想为以后留好扩展性，那么JavaScript作为中间层应该是一个不错的选择，将对应的HTML操作可以翻译成下面几个方法（组件的也类似）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;create   // 创建HTML标签&lt;/li&gt;
  &lt;li&gt;attr     // 设置属性&lt;/li&gt;
  &lt;li&gt;listen   // 绑定事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了处理层次还需要&lt;strong&gt;push&lt;/strong&gt;、&lt;strong&gt;pop&lt;/strong&gt;方法。为了实现这些我们需要一个翻译器：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将生成的JS文件保存到CDN上面，再结合HTTP缓存，性能应该还是可以的！我们继续，在此基础上可以扩展出更多的玩法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在是将结果渲染到某个DOM节点下面，那是否可以直接在Velocity中使用某个组件，像这样:&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;div&amp;gt;
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
&amp;lt;/div&amp;gt;
&lt;/pre&gt;

&lt;p&gt;上面是对后端Javaer敞开大门，那前端工程师是否可以得到好处，像这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;script type=&quot;text/engine&quot;&amp;gt;
@input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
&amp;lt;/script&amp;gt;
&lt;/pre&gt;

&lt;p&gt;因为每一步前后都没有耦合，你完全可以去扩展自己想要的东西。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;远古时期的程序员在实现业务时可能把：取数据、业务逻辑、渲染都放在一个代码中完成，后来逐渐分成几层来做：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Model&lt;/li&gt;
  &lt;li&gt;View&lt;/li&gt;
  &lt;li&gt;Controller&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不仅结构更清晰，而且在任何一层你都可以选择不同的方案来实现。我们在做工具时也可以参考这种思路，多分几步来做。&lt;/p&gt;

&lt;p&gt;那什么是从下到上呢？和上面的分层的角度不一样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;越下越灵活，但门槛越高&lt;/li&gt;
  &lt;li&gt;越上越好用，但扩展起来不是很容易&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在对一些场景实现工具，根据灵活度和易用性来分成几步来做，这样不同的技术背景的人都可以使用，而且最关键的是可以扩展出更多的使用场景！:-)&lt;/p&gt;
</description>
        <pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/17/DOWN-TO-UP.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/17/DOWN-TO-UP.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>EASYDT</title>
        <description>&lt;!-- test --&gt;

&lt;!-- test end--&gt;

&lt;!-- (0) --&gt;
&lt;section&gt;&lt;h1&gt;EASY-DT&lt;/h1&gt;&lt;/section&gt;
&lt;!-- (1) --&gt;
&lt;section&gt;&lt;h3&gt;方便、快速地提供标准数据接口&lt;/h3&gt;&lt;/section&gt;
&lt;!-- (2) --&gt;
&lt;section&gt;
&lt;!-- (2.1) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 老的配置方式

&lt;div style=&quot;display:inline-block;&quot;&gt;
![](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-1.png)
![](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-1.png)
&lt;/div&gt;

- 理想：让不会写代码的人也能配置 &lt;!-- .element: class=&quot;fragment&quot; --&gt;
- 现实：并没有多少人会用 &lt;!-- .element: class=&quot;fragment&quot; --&gt;
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2.2) --&gt;
&lt;section&gt;
&lt;h3&gt;实际中的数据&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
[
    {
        &quot;name&quot;: &quot;拣选&quot;,
        &quot;list&quot;: [
            0, 0, 0, 0, 0, 0, 0, 0, 256, 6049, 5684, 3008
        ],
        &quot;latest_count&quot;: 4862
    },
    {}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!-- (2.3) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 分析问题

- 功能作用单一
- 无法地将功能组件组合使用
- 扩展复杂
- 过多的功能容易导致混淆
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2.4) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 使用GROOVY组合基础功能

- 调试
- 安全控制
- 版本控制
- 编辑保存
- 同步
- 扩展性&lt;!-- .element: class=&quot;fragment highlight-red&quot; --&gt;
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2.5) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
![现在的编辑页面](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-1.png)

- 对开发来说GROOVY的学习成本应该还是比较低的
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2.6) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 小白用户更愿意看到的是

![现在的编辑页面](http://7xiz10.com1.z0.glb.clouddn.com/DOWN-TO-UP-1.png)&lt;!-- .element: class=&quot;fragment&quot; --&gt;
&lt;/script&gt;&lt;/section&gt;
&lt;!-- (2.7) --&gt;
&lt;section&gt;
&lt;h3&gt;可能的一种扩展方法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;
static Object execute(){
    def template_context = get(&quot;template_context&quot;);
    def sql = template_context.get(&quot;sql&quot;);
    def datasource = template_context.get(&quot;datasource&quot;);
    // 
}
static void mock(){
    // 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!-- (2.8) --&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 整体结构
&lt;/script&gt;&lt;/section&gt;
&lt;/section&gt;
&lt;!--(3)--&gt;
&lt;section&gt;&lt;h3&gt;更简单的前端页面开发&lt;/h3&gt;&lt;/section&gt;
&lt;!--(4)--&gt;
&lt;section&gt;
&lt;!--(4.1)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 分析问题

- 后端开发不懂前端逻辑，前端很容易成为瓶颈&lt;!-- .element: class=&quot;fragment&quot; --&gt;
- 逻辑复杂&lt;!-- .element: class=&quot;fragment&quot; --&gt;
- 代码重复&lt;!-- .element: class=&quot;fragment&quot; --&gt;
- 可读性和维护性不是很好&lt;!-- .element: class=&quot;fragment&quot; --&gt;
&lt;/script&gt;&lt;/section&gt;
&lt;!--(4.2)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 解决问题

- 灵活性：生成JavaScript代码
- 可读性：用简单的DSL来描述
- 易用性：在组件中封装JS、CSS的依赖
&lt;/script&gt;&lt;/section&gt;
&lt;!--(4.3)--&gt;
&lt;section&gt;
&lt;h3&gt;使用组件&lt;/h3&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;div class=&quot;fragment&quot;&gt;
&lt;span style=&quot;color:red;&quot;&gt;@input&lt;/span&gt;
(
&lt;span style=&quot;color:green;&quot;&gt;label&lt;/span&gt;=&quot;仓库&quot; 
&lt;span style=&quot;color:green;&quot;&gt;name&lt;/span&gt;=&quot;warehouse&quot;
)
&lt;/div&gt;
&lt;/section&gt;
&lt;!--(4.4)--&gt;
&lt;section&gt;
&lt;h3&gt;组件关联&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
@input(name=&quot;warehouse&quot;)
@input(name=&quot;owner&quot;)
    @on(target=&quot;warehouse&quot; type=&quot;change&quot;)
        // 1. 请求接口获取数据
        // 2. 更新组件自生的数据
        // 3. 刷新展示
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!--(4.5)--&gt;
&lt;section&gt;
&lt;h3&gt;定义组件&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
@import(
    &#39;bootstrap.css&#39; // 依赖的CSS文件（需要的时候也可以加JS）
)
@component
    this.width = &#39;10px&#39;; // 一些默认的数据

    @render  // 在render下定义渲染（有点像JSX吧）
        &lt;ul&gt;
            for(i in items){
                &lt;li&gt;${items[i]}&lt;/li&gt;
            }
        &lt;/ul&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!-- (4.6) --&gt;
&lt;section&gt;
&lt;h3&gt;生成的代码&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
	create(&quot;div&quot;);
	attr(&quot;class&quot;,&quot;control-group span8&quot;);
	push();
	create(&quot;label&quot;);
	attr(&quot;class&quot;,&quot;control-label&quot;);
	push();
	create(null, (&quot;供应商编码：&quot;));
	pop();
	create(&quot;div&quot;);
	attr(&quot;id&quot;,&quot;s1&quot;+this.name);
	attr(&quot;class&quot;,&quot;controls&quot;);
	push();
	pop();
	pop();
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!--(4.7)--&gt;
&lt;section&gt;
&lt;h3&gt;前端&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
&lt;script type=&quot;text/engine&quot;&gt;
@layout
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;)
@layout
    @table
    @page
&lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!--(4.8)--&gt;
&lt;section&gt;
&lt;h3&gt;后端&lt;/h3&gt;
&lt;br /&gt;
&lt;pre&gt;&lt;code&gt;
&lt;script type=&quot;text/engine&quot;&gt;
&lt;form&gt;
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;) // 使用组件
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;) // 使用组件
    @input(label=&quot;xxx&quot; name=&quot;xxx&quot;) // 使用组件
    &lt;table&gt;&lt;/table&gt;
&lt;/form&gt;
&lt;/script&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/section&gt;
&lt;!--(4.9)--&gt;
&lt;section data-markdown=&quot;&quot;&gt;&lt;script type=&quot;text/template&quot;&gt;
### 整体结构
&lt;/script&gt;&lt;/section&gt;
&lt;/section&gt;
</description>
        <pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/17/DOWN-TO-UP-SLIDES.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/12/17/DOWN-TO-UP-SLIDES.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>用ACE来写代码（二）</title>
        <description>&lt;p&gt;仅仅把代码高亮了还不够，在正常的编辑器中当输入少量的几个字符串就可以根据它来提示可能的输入：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-4.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样用起来能极大地提高输入的效率，而实现起来非常简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ace.require(&quot;ace/ext/language_tools&quot;);
var editor = ace.edit(&quot;editor&quot;);
editor.session.setMode(&quot;ace/mode/groovy&quot;);
editor.setTheme(&quot;ace/theme/tomorrow&quot;);
editor.setOptions({
    enableBasicAutocompletion: true,
    enableSnippets: true,
    enableLiveAutocompletion: true
});
&lt;/pre&gt;

&lt;p&gt;另外注意需要引入&lt;strong&gt;ext-language_tools.js&lt;/strong&gt;文件！感觉看英文的文档有些地方不是很清楚（可能是英语水平的问题☺），于是我们继续开始读源码。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;源码分析&lt;/h2&gt;

&lt;p&gt;我们设置了&lt;strong&gt;enableLiveAutocompletion&lt;/strong&gt;后输入内容时会执行&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/ext/language_tools.js#L156&quot;&gt;doLiveAutocomplete&lt;/a&gt;方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var doLiveAutocomplete = function(e) {
    var editor = e.editor;
    var hasCompleter = editor.completer &amp;amp;&amp;amp; editor.completer.activated;
    if (e.command.name === &quot;backspace&quot;) {// 删除动作
        if (hasCompleter &amp;amp;&amp;amp; !getCompletionPrefix(editor))
            editor.completer.detach();
    } else if (e.command.name === &quot;insertstring&quot;) {// 输入动作
        var prefix = getCompletionPrefix(editor);
        if (prefix &amp;amp;&amp;amp; !hasCompleter) {
            if (!editor.completer) {
                editor.completer = new Autocomplete();
            }
            editor.completer.autoInsert = false;
            editor.completer.showPopup(editor);// 入口方法
        }
    }
};
&lt;/pre&gt;

&lt;p&gt;对操作的类型及内容做一些简单的过滤之后就交由&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js&quot;&gt;Autocomplete&lt;/a&gt;来完成实质性的工作：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.showPopup = function(editor) {
    // 初始化
    if (this.editor)
        this.detach();
    this.activated = true;
    this.editor = editor;
    if (editor.completer != this) {
        if (editor.completer)
            editor.completer.detach();
        editor.completer = this;
    }
    // 绑定方法
    editor.on(&quot;changeSelection&quot;, this.changeListener);
    editor.on(&quot;blur&quot;, this.blurListener);
    editor.on(&quot;mousedown&quot;, this.mousedownListener);
    editor.on(&quot;mousewheel&quot;, this.mousewheelListener);
    // 更新补全信息列表
    this.updateCompletions();
};
&lt;/pre&gt;

&lt;p&gt;方法&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L253&quot;&gt;showPopup&lt;/a&gt;中先进行初始化：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用detach进行清理；&lt;/li&gt;
  &lt;li&gt;绑定事件；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来就使用&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L274&quot;&gt;updateCompletions&lt;/a&gt;来获取补全列表信息并进行展示：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.updateCompletions = function(keepPopupPosition) {
    if (keepPopupPosition &amp;amp;&amp;amp; this.base &amp;amp;&amp;amp; this.completions) {
        var pos = this.editor.getCursorPosition();
        var prefix = this.editor.session.getTextRange({start: this.base, end: pos});
        // 内容没有发生变化
        if (prefix == this.completions.filterText)
            return;
        this.completions.setFilter(prefix);
        if (!this.completions.filtered.length)
            return this.detach();
        if (this.completions.filtered.length == 1
            &amp;amp;&amp;amp; this.completions.filtered[0].value == prefix
            &amp;amp;&amp;amp; !this.completions.filtered[0].snippet)
            return this.detach();
        this.openPopup(this.editor, prefix, keepPopupPosition);
        return;
    }
    var _id = this.gatherCompletionsId;
    // 收集所有的补全信息并执行（全部用回调函数来搞看着好累- -!）
    this.gatherCompletions(this.editor, function(err, results) {
        var detachIfFinished = function() {
            if (!results.finished) return;
            return this.detach();
        }.bind(this);
        // 获取前缀
        var prefix = results.prefix;
        var matches = results &amp;amp;&amp;amp; results.matches;
        // 没有匹配到的时候就可以清理一下然后返回了
        if (!matches || !matches.length)
            return detachIfFinished();
        if (prefix.indexOf(results.prefix) !== 0 || _id != this.gatherCompletionsId)
            return;
        this.completions = new FilteredList(matches);
        // 是否精确匹配
        if (this.exactMatch)
            this.completions.exactMatch = true;
        // 过滤，过滤完的结果保存在filtered中
        this.completions.setFilter(prefix);
        var filtered = this.completions.filtered;
        // 检查过滤完的结果，没有匹配到的就清理并返回
        if (!filtered.length)
            return detachIfFinished();
        if (filtered.length == 1 &amp;amp;&amp;amp; filtered[0].value == prefix &amp;amp;&amp;amp; !filtered[0].snippet)
            return detachIfFinished();
        if (this.autoInsert &amp;amp;&amp;amp; filtered.length == 1 &amp;amp;&amp;amp; results.finished)
            return this.insertMatch(filtered[0]);
        // 展示内容
        this.openPopup(this.editor, prefix, keepPopupPosition);
    }.bind(this));
};
&lt;/pre&gt;

&lt;p&gt;其中参数&lt;strong&gt;keepPopupPosition&lt;/strong&gt;表示是否保持弹出框的位置保持不变：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;补全框中的内容会随着你的输入变化而变化，但是位置却保持不变就是这个参数在起作用！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中比较关键的用&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L224&quot;&gt;gatherCompletions&lt;/a&gt;来收集所有补全器提供的数据（感觉是用这个方法把language_tools.js和autocomplete.js打通）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.gatherCompletions = function(editor, callback) {
    var session = editor.getSession();
    var pos = editor.getCursorPosition();
    var line = session.getLine(pos.row);
    var prefix = util.retrievePrecedingIdentifier(line, pos.column);
    this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
    this.base.$insertRight = true;
    var matches = [];
    var total = editor.completers.length;
    // 遍历执行每个补全器
    editor.completers.forEach(function(completer, i) {
        // 获取补全列表
        completer.getCompletions(editor, session, pos, prefix, function(err, results) {
            // 在没有发生错误的时候，将结果合并到matchs中
            if (!err)
                matches = matches.concat(results);
            var pos = editor.getCursorPosition();
            var line = session.getLine(pos.row);
            // 调用回调函数
            callback(null, {
                prefix: util.retrievePrecedingIdentifier(line, pos.column, results[0] &amp;amp;&amp;amp; results[0].identifierRegex),
                matches: matches,
                finished: (--total === 0)
            });
        });
    });
    return true;
};
&lt;/pre&gt;

&lt;p&gt;在每个补全器的&lt;strong&gt;getCompletions&lt;/strong&gt;方法中都会调用callback方法：将自己的结果合并到全局的数据中。获取补全器的数据之后就会调用&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete.js#L81&quot;&gt;openPopup&lt;/a&gt;方法来更新展示：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.openPopup = function(editor, prefix, keepPopupPosition) {
    if (!this.popup)
        this.$init();
    this.popup.setData(this.completions.filtered);
    editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
    var renderer = editor.renderer;
    this.popup.setRow(this.autoSelect ? 0 : -1);
    if (!keepPopupPosition) {
        // 设置展示
        this.popup.setTheme(editor.getTheme());
        this.popup.setFontSize(editor.getFontSize());
        var lineHeight = renderer.layerConfig.lineHeight;
        // 设置位置
        var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
        pos.left -= this.popup.getTextLeftOffset();
        var rect = editor.container.getBoundingClientRect();
        pos.top += rect.top - renderer.layerConfig.offset;
        pos.left += rect.left - editor.renderer.scrollLeft;
        pos.left += renderer.gutterWidth;
        // 展示内容
        this.popup.show(pos, lineHeight);
    } else if (keepPopupPosition &amp;amp;&amp;amp; !prefix) {
        this.detach();
    }
};
&lt;/pre&gt;

&lt;p&gt;回过头再来看language_tools.js中的补全器：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;getCompletions&lt;/strong&gt;：获取补全列表；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;getDocTooltip&lt;/strong&gt;：返回HTML格式的提示内容；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个补全列表中的元素包含如下信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;caption&lt;/strong&gt;：字幕，也就是展示在列表中的内容&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;meta&lt;/strong&gt;：展示类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;name&lt;/strong&gt;：名称&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;：值&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;score&lt;/strong&gt;：分数，越大的排在越上面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而getDocTooltip感觉又进一步地提升了写代码时候的体验（在写代码的时候就知道输入的是什么）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-5.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体是怎么实现的呢？接着来看代码，&lt;strong&gt;Mode&lt;/strong&gt;中的&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/mode/text.js#L370&quot;&gt;getCompletions&lt;/a&gt;如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.getCompletions = function(state, session, pos, prefix) {
    // 获取当前Mode的关键字
    var keywords = this.$keywordList || this.$createKeywordList();
    // 根据关键字组装补全列表
    return keywords.map(function(word) {
        return {
            name: word,
            value: word,
            score: 0,
            meta: &quot;keyword&quot;
        };
    });
};
&lt;/pre&gt;

&lt;p&gt;在当前文件中写过的单词被自动提示补全的逻辑在&lt;a href=&quot;https://github.com/ajaxorg/ace/blob/36e6744a5f40df0da52ff22b3bc729657c056e09/lib/ace/autocomplete/text_completer.js&quot;&gt;text_completer.js&lt;/a&gt;中实现（逻辑很简单），比较麻烦的是&lt;strong&gt;enableSnippets&lt;/strong&gt;，这个后面有时间再看。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;自定义补全&lt;/h2&gt;

&lt;p&gt;知道了ACE的补全运行的原理，那么现在扩展起来就比较简单了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var languageTools = ace.require(&quot;ace/ext/language_tools&quot;);
    languageTools.addCompleter({
        getCompletions: function(editor, session, pos, prefix, callback) {
        callback(null,  [
            {
                name : &quot;test&quot;,
                value : &quot;test&quot;,
                caption: &quot;test&quot;,
                meta: &quot;test&quot;,
                type: &quot;local&quot;,
                score : 1000 // 让test排在最上面
            }
        ]);
    }
});
&lt;/pre&gt;

&lt;p&gt;虽然看到的例子都是同步执行callback方法，但用异步来做也是完全没有问题的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在上面看源码的时候还不明白为啥每次回调的时候都要更新显示而不是等全部执行完后更新一次~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在事件驱动的系统中接口的设计还是需要多思考、多推敲的啊！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;有了自动补全之后与IDE的距离又近了一步，不仅仅能加快脚步编写的速度，更重要的是代码的准确性也会有所提高，当然这还是不够的！&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Nov 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/11/06/ACEJS-B.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/11/06/ACEJS-B.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>用ACE来写代码（一）</title>
        <description>&lt;p&gt;后台应用通常会有很多的配置页面，现在在状态是直接搞一个textarea来搞：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种粗糙、QJ用户的行为显然不是一个有节操的程序员该干的，为了这种配置的页面好用最少应该提供三个功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;高亮：提示关键字、类型，可以在第一时间发现简单错误&lt;/li&gt;
  &lt;li&gt;缩进：增加配置可读性的最简单的办法&lt;/li&gt;
  &lt;li&gt;折叠：有一大堆的配置的时候折叠还是挺好用的&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在网上逛了一圈发现Colud9的ACE还是挺好用的（GitHub上10000+的Star也说明了实力），可以在&lt;a href=&quot;https://ace.c9.io/build/kitchen-sink.html&quot;&gt;这里&lt;/a&gt;体验下，国内的&lt;a href=&quot;https://coding.net/&quot;&gt;coding.net&lt;/a&gt;平台所使用的也是该工具，但是做出来的效果离Colud9还是有不小的差距。。。&lt;/p&gt;

&lt;p&gt;由于网上的资料不多，学习过程非常痛苦，有些东西是直接看&lt;a href=&quot;https://github.com/ajaxorg/ace&quot;&gt;代码&lt;/a&gt;去猜测运行的原理，希望对需要的人有一点帮助！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;使用&lt;/h2&gt;

&lt;p&gt;使用方法很经典（和HighCharts等差不多）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&amp;gt;
    #editor {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;editor&quot;&amp;gt;function foo(items) {
    var x = &quot;All this is syntax highlighted&quot;;
    return x;
}&amp;lt;/div&amp;gt;
&amp;lt;script src=&quot;https://ace.c9.io/build/src/ace.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var editor = ace.edit(&quot;editor&quot;);
    editor.setTheme(&quot;ace/theme/monokai&quot;);
	editor.getSession().setMode(&quot;ace/mode/javascript&quot;);
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;完成后ACE会在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div id=&quot;editor&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;渲染出对应的DOM结构，其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;editor.setTheme&lt;/strong&gt;：设置主题，有点皮肤的意思&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;editor.getSession().setMode&lt;/strong&gt;：设置模式，上面这段设置的是JavaScript的模式，其中包括了高亮、缩进、折叠凳功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ajaxorg/ace/tree/master/lib/ace/mode&quot;&gt;内部&lt;/a&gt;有大部分语言的模式，正常情况下你是不需要考虑后面的内容的。后来有同事用drools做规则引擎，这个没有现成的只能自己来搞！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;高亮&lt;/h2&gt;

&lt;p&gt;让代码高亮显示的思路很简单，比如将关键字用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span class=&quot;ace_keyword&quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/code&gt;包裹起来并在CSS中设置样式即可，那么关键问题就是如何对源码进行&lt;strong&gt;词法分析&lt;/strong&gt;了。&lt;/p&gt;

&lt;p&gt;在ACE中实现的时候有点像&lt;strong&gt;状态机&lt;/strong&gt;，在处理时不断地从当前状态的规则集中找到匹配&lt;code class=&quot;highlighter-rouge&quot;&gt;regex&lt;/code&gt;的规则，之后跳转到对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;状态：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
this.$rules = {
    &quot;start&quot; : [
        {
            token: &amp;lt;token&amp;gt;, // class名称
            regex: &amp;lt;regex&amp;gt;, // 正则匹配串
            next:  &amp;lt;next&amp;gt;   // 下个状态
        }
    ]
};
&lt;/pre&gt;

&lt;p&gt;相比普通的词法分析器，一个状态就相当于一个小的隔离环境，在这个隔离环境中在做匹配的时候难度要小很多，你只需要考虑在该状态内可能出现的TOKEN即可：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-2.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外比较好用的几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设置&lt;strong&gt;merge:true&lt;/strong&gt;来合并连续的token&lt;/li&gt;
  &lt;li&gt;利用&lt;strong&gt;createKeywordMapper&lt;/strong&gt;来简化关键字列表的编写&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么简单来做个drools高亮的Mode如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ace.define(&quot;ace/mode/drools_highlight_rules&quot;, function(require, exports, module) {
    &quot;use strict&quot;;
    var oop = require(&quot;../lib/oop&quot;);
    var TextHighlightRules = require(&quot;./text_highlight_rules&quot;).TextHighlightRules;
    var DroolsHighlightRules = function(){
        var keywordMapper = this.createKeywordMapper({
            &quot;keyword&quot;:
                &quot;when|then|rule|end|salience&quot;
        }, &quot;identifier&quot;);
        this.$rules = {
            &quot;start&quot; :[{
                token : keywordMapper,
                regex : &quot;[a-zA-Z_$][a-zA-Z0-9_$]*\\b&quot;
            }]
        };
    };
    oop.inherits(DroolsHighlightRules, TextHighlightRules);
    exports.DroolsHighlightRules = DroolsHighlightRules;
});
 
ace.define(&quot;ace/mode/drools&quot;, function(require, exports, module) {
    &quot;use strict&quot;;
    var oop = require(&quot;../lib/oop&quot;);
    var TextMode = require(&quot;./text&quot;).Mode;
    var DroolsHighlightRules = require(&quot;./drools_highlight_rules&quot;).DroolsHighlightRules;
    var DroolsMode = function(){
        this.HighlightRules = DroolsHighlightRules;
    };
    oop.inherits(DroolsMode, TextMode);
    (function() {
        this.$id = &quot;ace/mode/drools&quot;
    }).call(DroolsMode.prototype),
    exports.Mode = DroolsMode;
});
&lt;/pre&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/ACE-3.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更多的功能可以在&lt;a href=&quot;https://ace.c9.io/#nav=higlighter&quot;&gt;这里&lt;/a&gt;看到，不过貌似很不稳定- -！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缩进&lt;/h2&gt;

&lt;p&gt;ACE为MODE扩展缩进预留了接口，你只需要实现&lt;strong&gt;getNextLineIndent&lt;/strong&gt;方法即可，会将其结果自动添加到新行的开头，参数含义为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;state：状态&lt;/li&gt;
  &lt;li&gt;line：当前行内容&lt;/li&gt;
  &lt;li&gt;tab：缩进符号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看个例子（如果是{[(结尾的，那么下一行的缩进加一）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
(function(){
    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);
        if (state == &quot;start&quot;) {
            var match = line.match(/^.*[\{\(\[]\s*$/); // 如果是{[(结尾的，那么下一行的缩进加一
            if (match) {
                indent += tab;
            }
        }
        return indent;
    };
}).call(DroolsMode.prototype);
&lt;/pre&gt;

&lt;p&gt;对大部分的缩进需求这种方式完全能搞定了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;折叠&lt;/h2&gt;

&lt;p&gt;折叠的实现涉及到范围对象new Range(Number startRow, Number startColumn, Number endRow, Number endColumn)：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;startRow：开始行&lt;/li&gt;
  &lt;li&gt;startColumn：开始列&lt;/li&gt;
  &lt;li&gt;endRow：结束行&lt;/li&gt;
  &lt;li&gt;endColumn：结束列&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现折叠需要提供两个方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;getFoldWidget&lt;/strong&gt;：折叠开始的地方&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;getFoldWidgetRange&lt;/strong&gt;：需要折叠的范围&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面我们为drools实现一个简单的折叠逻辑，也就是将&lt;strong&gt;rule&lt;/strong&gt;与&lt;strong&gt;end&lt;/strong&gt;之间的部分能够折叠隐藏：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
ace.define(&quot;ace/mode/folding/drools_fold&quot;, function(require, exports, module) {
    &quot;use strict&quot;;
    var Range = require(&quot;../../range&quot;).Range;
    var FoldMode = exports.FoldMode = function() {};
    (function() {
        this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (line == &quot;rule&quot;)
                return &quot;start&quot;;
            return &quot;&quot;;
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
            var startRow = row, startColumn = 4;
            var endRow = row+1, endColumn = 3;
            while(session.getLine(endRow) != &quot;end&quot;){
                endRow += 1;
            }
            return new Range(startRow, startColumn, endRow, endColumn);
        };
    }).call(FoldMode.prototype);
});
&lt;/pre&gt;

&lt;p&gt;然后需要在drools的Mode中设置&lt;strong&gt;foldingRules&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var DroolsFoldMode = require(&quot;ace/mode/folding/drools_fold&quot;).FoldMode;
var DroolsMode = function(){
    this.foldingRules = new DroolsFoldMode();
};
&lt;/pre&gt;

&lt;p&gt;在ACE中提供了一个基本的折叠块：&lt;strong&gt;fold_mode&lt;/strong&gt;，用来折叠相同的缩进部分，如果需要直接集成即可！&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;实现了这三部分功能已经可以大幅度提升简单配置页面的体验，但是作为一个在线的IDE才仅仅是万里长征的第一步！&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Oct 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/19/ACEJS-A.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/19/ACEJS-A.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>组装页面</title>
        <description>&lt;p&gt;在码农中最持久的一个口号就是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;低耦合、高内聚&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先来看低耦合，在用Java写代码的时候大家已经习惯用&lt;strong&gt;共享内存&lt;/strong&gt;的方式来实现多线程间的通信（就不举栗子了），有点问题的时候排查起来比较头疼，而另外一种思路是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用通信的方式来共享内存&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如在古老的&lt;a href=&quot;http://svn.liancheng.info/cpie-cn/trunk/.build/html/part-i/chapter-5.html&quot;&gt;Erlang&lt;/a&gt;中是这样的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
receive
    Message1 [when Guard1] -&amp;gt;
        Actions1 ;
    Message2 [when Guard2] -&amp;gt;
        Actions2 ;
    ...
end
&lt;/pre&gt;

&lt;p&gt;而比较新的&lt;a href=&quot;http://www.cnblogs.com/hustcat/p/4003729.html&quot;&gt;Golang&lt;/a&gt;中是这样的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func Producer (queue chan&amp;lt;- int){
    for i:= 0; i &amp;lt; 10; i++ {
        queue &amp;lt;- i
    }
}
func Consumer( queue &amp;lt;-chan int){
    for i :=0; i &amp;lt; 10; i++{
        v := &amp;lt;- queue
            fmt.Println(&quot;receive:&quot;, v)
    }
}
func main(){
    queue := make(chan int, 1)
    go Producer(queue)
    go Consumer(queue)
    time.Sleep(1e9) //让Producer与Consumer完成
}
&lt;/pre&gt;

&lt;p&gt;再回过头来看HTML其实也是通过消息来驱动的，页面上的每个操作都会转换成事件传递给JavaScript进行处理，在JavaScript中的事件处理方式如下（单线程）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Build-Up-Page.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在可视化编程中这种方式还是挺给力的，在使用一个组件时，需要根据它的事件来让用户去扩展（写代码）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@input(name = &quot;abc&quot;)
    @on(click)
        ......
    @on(change)
        ......
&lt;/pre&gt;

&lt;p&gt;用户在编写代码的时候只需要关注两个对象：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;event&lt;/strong&gt;：事件对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;this&lt;/strong&gt;：订阅了事件的组件，也就是当前组件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;组件可以监听另一个组件的事件，这样两个组件就可以实现交互（和HTML的区别是动作与展示结合在一起）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@input(name = &quot;abc&quot;)
    .....
@table(...)
    @target(abc)
        @on(click)
            .....
    @on(target = &quot;abc&quot; type=&quot;click&quot;)
        ....
&lt;/pre&gt;

&lt;p&gt;在event中包含的字段有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;字段&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;target&lt;/td&gt;
      &lt;td&gt;产生事件的组件名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;type&lt;/td&gt;
      &lt;td&gt;事件类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;data&lt;/td&gt;
      &lt;td&gt;数据&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;实现事件的订阅/发布需要三个操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;绑定&lt;/li&gt;
  &lt;li&gt;取消绑定&lt;/li&gt;
  &lt;li&gt;发送&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在组件从页面上消失的时候是需要取消绑定的，不然可能会有问题，配置完成页面上组件之间的关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Build-Up-Page-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在接收到事件的时候可以做任何你想做的事情，比如更新一下页面的展示。因为组件已经封装的比较彻底了，暴露给用户的只有数据，那么只能通过更新数据来更新展示：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@table
    @on(click)
        setState({list:[1,2,3,4]});
&lt;/pre&gt;

&lt;p&gt;如果对应的模板为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@render
    for(var i in list){
        &amp;lt;li&amp;gt;${i}&amp;lt;/li&amp;gt;
    }
&lt;/pre&gt;

&lt;p&gt;那么得到的HTML的代码如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在更新展示时如果直接用&lt;a href=&quot;http://www.w3school.com.cn/jsref/prop_tablerow_innerhtml.asp&quot;&gt;innerHTML&lt;/a&gt;或者&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Element/outerHTML&quot;&gt;outerHTML&lt;/a&gt;实现起来比较简单，但问题是体验比较差：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用户的输入（或者列表的选择）都会消失，感觉有点像区域被刷新了一下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外在全部更新的情况下要比逐个更新元素要快一些，但是很多情况下我们只需要更新页面上的一小部分，那么就可以考虑用JS原生的DOM操作来搞：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Document/createElement&quot;&gt;createElement&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;创建HTML元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild&quot;&gt;appendChild&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;将一个节点插入到指定的父节点的最末尾处&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild&quot;&gt;removeChild&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;从某个父节点中移除指定的子节点,并返回那个子节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild&quot;&gt;replaceChild&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore&quot;&gt;insertBefore&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;在当前节点的某个子节点之前再插入一个子节点&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;虽然没有&lt;strong&gt;insertAfter&lt;/strong&gt;方法，但是实现起来非常简单。DOM结构中另一个变化的大头就是属性：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getAttribute&quot;&gt;getAttribute&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;获取属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/element/setAttribute&quot;&gt;setAttribute&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;设置属性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/element/removeAttribute&quot;&gt;removeAttribute&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;移除属性&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最后想修改标签中的字符时可以用&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Element/innerHTML&quot;&gt;innerHTML&lt;/a&gt;或者&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent&quot;&gt;textContent&lt;/a&gt;直接搞定，最后一个问题就是如何更新DOM结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Build-Up-Page-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;追求性能可以根据&lt;strong&gt;增&lt;/strong&gt;、&lt;strong&gt;删&lt;/strong&gt;、&lt;strong&gt;改&lt;/strong&gt;的成本用动态规划算出一个最优的修改方式，但是长期来看处理的数据都相当有限，只需要用贪心地策略来保证用户体验即可。&lt;/p&gt;

</description>
        <pubDate>Thu, 15 Oct 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/15/Build-Up-Page-A.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/15/Build-Up-Page-A.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>模板语言设计</title>
        <description>&lt;p&gt;平时各种模板用的很HIGH，但是当有一天遇到一个特殊需求，貌似现在的各种模板都不是那么好用，那么就不得不系统地思考一下模板语言应该如何设计~&lt;/p&gt;

&lt;h2 id=&quot;veolcity&quot;&gt;Veolcity&lt;/h2&gt;

&lt;p&gt;做过WEB开发的JAVAER可能都这么干过：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
String data = &quot;&amp;lt;body&amp;gt;hello world&amp;lt;/body&amp;gt;&quot;;
OutputStream outputStream = response.getOutputStream();
response.setHeader(&quot;content-type&quot;, &quot;text/html;charset=UTF-8&quot;);
outputStream.write(data.getByte(&quot;UTF-8&quot;));
&lt;/pre&gt;

&lt;p&gt;简单的输出没问题，稍微复杂一点就不行了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;程序复杂&lt;/li&gt;
  &lt;li&gt;代码几乎没有可读性和可维护性&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在使用Velocity之后情况有了明显的好转，当你想输出一个列表的时候可以这么干：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;ul&amp;gt;
	#foreach($i in $list)
	&amp;lt;li&amp;gt;$i&amp;lt;/li&amp;gt;
	#end
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;p&gt;这种写法非常直观以至于我现在都用它来渲染SQL语句，如果你也想这么玩需要自己定义&lt;strong&gt;ResourceLoader&lt;/strong&gt;来自定义资源加载。编写Velocity模板时只需要记住两个关键点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有的控制结构是以&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;开头&lt;/li&gt;
  &lt;li&gt;所有的取数据逻辑以&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;开头（恰好你也在用jQuery的话会产生冲突）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而其他的部分都会append到输出，使用时如果每次都对模板进行解析那速度估计就跟蜗牛一样，正确的姿势应该是&lt;strong&gt;编译并缓存&lt;/strong&gt;（这些内容与主题关系不大就不说了）。&lt;/p&gt;

&lt;p&gt;其中语法设计的核心思想是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用HTML（甚至普通文本）中很少用到的字符来区分语法结构&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;学习成本很低，但是单纯地使用它来编写一些复杂的逻辑还是很痛苦的事情。不过相比较来看&lt;strong&gt;FreeMarker&lt;/strong&gt;的写法更让人难受，加个&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;有啥意义么（估计会被喷）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;ul&amp;gt;
	&amp;lt;#list list as i&amp;gt;
		&amp;lt;li&amp;gt;i&amp;lt;/li&amp;gt;
	&amp;lt;/#list&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;p&gt;类似的模板引擎还有&lt;strong&gt;CommonTemplate&lt;/strong&gt;、&lt;strong&gt;HTTL&lt;/strong&gt;等。虽然这些技术已经将性能提到到一个很高的水准，但在后端处理页面展示还是非常局限：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;只能每次都获取全部的数据并把页面渲染一遍&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;浪费服务器资源不说，体验也很差，真是出力不讨好！&lt;/p&gt;

&lt;h2 id=&quot;angular&quot;&gt;Angular&lt;/h2&gt;

&lt;p&gt;在JavaScript的世界里也有与Velocity相似的模板技术（更多可以看&lt;a href=&quot;http://cdc.tencent.com/?p=5723&quot;&gt;这里&lt;/a&gt;）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;h3&amp;gt;
&amp;lt;% if (typeof content === &#39;string&#39;){ %&amp;gt;
	&amp;lt;%= content %&amp;gt;
&amp;lt;% } %&amp;gt;
&amp;lt;/h3&amp;gt;
&lt;/pre&gt;

&lt;p&gt;从Java转JavaScript可能觉得这种方式很好用：在数据发生变化的时候执行一下render然后替换掉原先改位置的DOM结构就可以了~ 但是能不能更进一步：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;DOM结构随着数据的变化而自动跟着变化&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看起来是终极目标，貌似&lt;a href=&quot;http://www.apjs.net/&quot;&gt;Angular&lt;/a&gt;完美地实现了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Your name: &amp;lt;input type=&quot;text&quot; ng-model=&quot;yourname&quot; placeholder=&quot;World&quot;&amp;gt;
&amp;lt;hr&amp;gt;
My name: &amp;lt;input type=&quot;text&quot; ng-model=&quot;yourname&quot; placeholder=&quot;World&quot;&amp;gt;
&lt;/pre&gt;

&lt;p&gt;执行的效果为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;两个输入框的内容，你随便改变哪一个，另一个都会随之变化，这就是&lt;strong&gt;双向绑定&lt;/strong&gt;（也许你已经注意到&lt;code class=&quot;highlighter-rouge&quot;&gt;ng-model&lt;/code&gt;了），当你需要输出列表时要用到&lt;code class=&quot;highlighter-rouge&quot;&gt;ng-repeat&lt;/code&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li ng-repeat=&quot;o in question.options&quot;&amp;gt;
        &amp;lt;b&amp;gt;\.&amp;lt;/b&amp;gt;
        &amp;lt;input type=&quot;radio&quot; name=&quot;optcheck&quot; /&amp;gt;
        \
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;p&gt;这种思想非常先进，和之前出现的模板都是不一样的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;之前的模板都是静态的，像一锤子买卖，而Angular的模板是动态的！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;刚开始接触前端的时候也想过这个问题，但是实在没有想出来应该如何定义这样的模板语言，而Angular则已经实现了，但是代价就是限制多、门槛高：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;模块&lt;/li&gt;
  &lt;li&gt;控制器&lt;/li&gt;
  &lt;li&gt;过滤器&lt;/li&gt;
  &lt;li&gt;指令&lt;/li&gt;
  &lt;li&gt;作用域&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可能大家不明白为什么门槛高：当你在适合Angular的例子上操作的时候上手非常容易，但是实现复杂的功能需要熟悉很多不那么直观的概念。还有一点比较不喜欢的是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;将展示和数据完全分开，甚至模板与展示相关的判断逻辑也分开！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这样确实能保持模板的简洁，但是总体上是否简洁、直观就不好说了。甚至连双向绑定这么好的卖点都有时候会被吐槽：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在页面复杂的时候双向数据绑定的行为可能是预测不出来（这点保留意见，没有深入玩过）。&lt;/p&gt;

&lt;h2 id=&quot;react&quot;&gt;React&lt;/h2&gt;

&lt;p&gt;接着我们来看下最近红得发紫的React，网上已经有很多它与Angular的比较，有些还是有点道理的。使用React的第一关是&lt;strong&gt;JSX&lt;/strong&gt;语法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var root =(
  &amp;lt;ul className=&quot;my-list&quot;&amp;gt;
    &amp;lt;li&amp;gt;First Text Content&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Second Text Content&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
);
&lt;/pre&gt;

&lt;p&gt;看起来就是将HTML代码嵌入到JavaScript中，看起来很怪但是也比较容易理解，而真正得到的代码如下:&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var root = React.createElement(
    &quot;ul&quot;,
    { className: &quot;my-list&quot; },
    React.createElement(&quot;li&quot;, null, &quot;First Text Content&quot;),
    React.createElement(&quot;li&quot;, null, &quot;Second Text Content&quot;)
);
&lt;/pre&gt;

&lt;p&gt;当然你也可以在&lt;a href=&quot;https://babeljs.io/repl/&quot;&gt;babel在线工具&lt;/a&gt;来体验这种语法。&lt;/p&gt;

&lt;p&gt;看起来很美好，但实际上也不能太任性：模板的作用仅在于&lt;strong&gt;映射&lt;/strong&gt;！控制语句&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;等是不能使用（多用babel玩一下就能体会到从JSX到JS之间的转换有多简单）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;思路有点像Angular那样去扩展HTML原有的东西（Angular扩展的是Attribute，而React进一步扩展了Element）！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在用React的时候需要过的第二关是&lt;strong&gt;生命周期&lt;/strong&gt;，讲道理的话生命周期这种东西应该越简单越合理，然而并不是这样：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;状态&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Mounting&lt;/td&gt;
      &lt;td&gt;已插入真实 DOM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Updating&lt;/td&gt;
      &lt;td&gt;正在被重新渲染&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unmounting&lt;/td&gt;
      &lt;td&gt;已移出真实 DOM&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;为每个状态配了两个处理函数：&lt;code class=&quot;highlighter-rouge&quot;&gt;will&lt;/code&gt;函数在进入状态之前调用，&lt;code class=&quot;highlighter-rouge&quot;&gt;did&lt;/code&gt;函数在进入状态之后调用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;componentWillMount&lt;/li&gt;
  &lt;li&gt;componentDidMount&lt;/li&gt;
  &lt;li&gt;componentWillUpdate&lt;/li&gt;
  &lt;li&gt;componentDidUpdate&lt;/li&gt;
  &lt;li&gt;componentWillUnmount&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外提供两个特殊状态的处理函数：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;componentWillReceiveProps&lt;/td&gt;
      &lt;td&gt;已加载组件收到新的参数时调用&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;shouldComponentUpdate&lt;/td&gt;
      &lt;td&gt;组件判断是否重新渲染时调用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;大家都在讲React很快、非常快，这就是第三关的&lt;strong&gt;虚拟DOM&lt;/strong&gt;：真实的DOM操作代价太大，在&lt;code class=&quot;highlighter-rouge&quot;&gt;render&lt;/code&gt;会先操作内存中的DOM结构，然后最小化反映到真正的DOM上（DomDiff算法可以在&lt;a href=&quot;https://github.com/migijs/migi/wiki/%E5%9F%BA%E4%BA%8Evd%E5%92%8Cvr%E7%9A%84DomDiff%E7%AE%97%E6%B3%95&quot;&gt;这里&lt;/a&gt;感受下）。&lt;/p&gt;

&lt;h2 id=&quot;noob-template&quot;&gt;Noob Template&lt;/h2&gt;

&lt;p&gt;在上面我们看到的各种办法把逻辑与HTML代码分开，如果是JS的话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;HTML的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;和JavaScript的&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;其实已经天然地起到了这个作用！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面这段代码不用说也应该可以猜到输出应该是什么吧：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;ul&amp;gt;
    for(var i = 0; i &amp;lt; 10; i++){
        &amp;lt;li&amp;gt;${i}&amp;lt;/li&amp;gt;
    }
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;

&lt;p&gt;当用组件来搭建一个页面的时候可以是这样（包含嵌套的逻辑）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@xxxxxx
    @yyyyyy
        ...
    @yyyyyy
        ...
    @yyyyyy
        ...
&lt;/pre&gt;

&lt;p&gt;用过&lt;strong&gt;MarkDown&lt;/strong&gt;或者&lt;strong&gt;Jade&lt;/strong&gt;或者&lt;strong&gt;Python&lt;/strong&gt;的同学可能对这种方式已经比较熟悉了，都没用过的话可以对比一下几种层级表示方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;缩进式&lt;/li&gt;
  &lt;li&gt;大括号式&lt;/li&gt;
  &lt;li&gt;END结束符式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用组件时需要设置一些属性来控制其行为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@xxxxx(name=&quot;TEST&quot; style= list=ajax(&quot;/url.do&quot;))
&lt;/pre&gt;

&lt;p&gt;另外如果可以在模板中直接编写JavaScript代码就更灵活了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@xxxxx
    @on(init)
        this.name = &quot;TEST&quot;;
        this.style = {color:&quot;white&quot;};
        ....
&lt;/pre&gt;

&lt;p&gt;然后结合React的精华：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;最小化DOM操作（用这个模式实现起来好像不怎么方便）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么这样实现的模板怎么样？&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;在后端渲染页面来展示的方式有点像漫画：看完一页翻一页；每次改变数据刷一次页面有点像动画：一帧一帧地动。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/lvdabao/p/AngularJs.html?utm_source=tuicool&amp;amp;utm_medium=referral#myexample&quot;&gt;走进AngularJs(一)angular基本概念的认识与实战&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/lvdabao/p/3379659.html&quot;&gt;走进AngularJs(二) ng模板中常用指令的使用方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ourjs.com/detail/5483d2d10dad0fbb6d000014&quot;&gt;2015年的JavaScript：Angular之类的框架将被库取代&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-AngularJS/&quot;&gt;AngularJS 作用域与数据绑定机制&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ourjs.com/detail/5567c046d11a73aa4d000003&quot;&gt;我是怎么从顾虑到热爱ReactJS的(与AngularJS经典MVC数据绑定的对比)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/react-jsx-and-component?utm_campaign=rightbar_v2&amp;amp;utm_source=infoq&amp;amp;utm_medium=articles_link&amp;amp;utm_content=link_text&quot;&gt;深入浅出React（三）：理解JSX和组件&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/react-dom-diff&quot;&gt;深入浅出React（四）：虚拟DOM Diff算法解析&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://reactjs.cn/react/docs/component-specs.html&quot;&gt;组件的详细说明和生命周期&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://zjumty.iteye.com/blog/2207030&quot;&gt;react.js的的diff算法真的很强大&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000000606216&quot;&gt;React 的 diff 算法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/03/react.html&quot;&gt;React 入门实例教程&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://facebook.github.io/react/index.html&quot;&gt;React官网&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Thu, 15 Oct 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/15/Template-Language.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/15/Template-Language.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>xml之schema</title>
        <description>&lt;p&gt;在网络传输中JSON和XML是最长用的两种数据格式，JSON的特点是短小、简单，但是除了这点以外就完全不能跟XML比了，所以涉及到配置方面还是优先考虑XML吧！&lt;/p&gt;

&lt;p&gt;但是裸奔的XML并不好用，比如我们打出来Jar包给别人用，需要他们自己在Spring配置中添加：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean class=&quot;xxxxxx&quot;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;功能简单的时候是没有问题的，当你做的东西比较复杂的时候就会变成：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean class=&quot;xxx&quot;&amp;gt;
    &amp;lt;property name=&quot;aaa&quot; value=&quot;aaa&quot;/&amp;gt;
    &amp;lt;property name=&quot;bbb&quot; value=&quot;bbb&quot;/&amp;gt;
    &amp;lt;property name=&quot;ccc&quot; value=&quot;ccc&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;

&lt;p&gt;除非在你的WILE里面写的非常清楚应用用哪个&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;，需要设置哪些&lt;code class=&quot;highlighter-rouge&quot;&gt;property&lt;/code&gt;，哪些是必填的等等等，不然没人知道该怎么写，而更好的解决办法是编写schema来定义XML的规则！&lt;/p&gt;

&lt;h2 id=&quot;xmlns&quot;&gt;命名空间（xmlns）&lt;/h2&gt;

&lt;p&gt;我们在配置Spring的时候经常会这么写：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;beans:beans xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;&amp;gt;
    &amp;lt;beans:import resource=&quot;xxx&quot;/&amp;gt;
&amp;lt;/beans:beans&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.springframework.org/schema/beans&lt;/code&gt;就是一个命名空间，而&lt;code class=&quot;highlighter-rouge&quot;&gt;xmlns:beans&lt;/code&gt;相当于设置了命名空间的一个代号，在使用时&lt;code class=&quot;highlighter-rouge&quot;&gt;beans:import&lt;/code&gt;就可以表示使用该命名空间中的import元素。&lt;/p&gt;

&lt;p&gt;可以不写&lt;code class=&quot;highlighter-rouge&quot;&gt;:beans&lt;/code&gt;来表示默认就用该命名空间，那么配置就更简单了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&amp;gt;
    &amp;lt;import resource=&quot;xxx&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在schema中由下面三个属性来控制命名空间的行为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;targetNamespace：目标命名空间&lt;/li&gt;
  &lt;li&gt;elementFormDefault：unqualified/qualified&lt;/li&gt;
  &lt;li&gt;attributeFormDefault：unqualified/qualified&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当设置&lt;code class=&quot;highlighter-rouge&quot;&gt;unqualified&lt;/code&gt;时schema中除了根元素以外，其他的元素都是没有命名空间的，在使用的时候需要将其命名空间设置为空：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;easydt:easydt xmlns:easydt=&quot;http://www.cainiao.com/schema/easydt&quot;&amp;gt;
    &amp;lt;provider xmlns=&quot;&quot;/&amp;gt;&amp;lt;!-- 注意这里 --&amp;gt;
&amp;lt;/easydt:easydt&amp;gt;
&lt;/pre&gt;

&lt;p&gt;而设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;qualified&lt;/code&gt;时schema中定义的所有元素都属于&lt;code class=&quot;highlighter-rouge&quot;&gt;targetNamespace&lt;/code&gt;所定义的命名空间：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;easydt:easydt xmlns=&quot;http://www.cainiao.com/schema/easydt&quot;&amp;gt;
    &amp;lt;provider/&amp;gt;&amp;lt;!-- 看这里 --&amp;gt;
&amp;lt;/easydt:easydt&amp;gt;
&lt;/pre&gt;

&lt;p&gt;显然用qualified看起来更简单一些，不过也是看情况的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;定义元素&lt;/h2&gt;

&lt;p&gt;完整的schema的定义如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
targetNamespace=&quot;http://www.w3school.com.cn&quot;
xmlns=&quot;http://www.w3school.com.cn&quot;
elementFormDefault=&quot;qualified&quot;&amp;gt;
    在这里定义元素和属性
&amp;lt;/xs:schema&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其目的就是配置出来一堆的&lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;attribute&lt;/code&gt;来约束XML的行为，简单来说&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;yyy xxx=&quot;xxx&quot;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其中：yyy是element、xxx是属性！最简单的元素如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;easydt:a&amp;gt;123&amp;lt;/easydt:a&amp;gt;
&lt;/pre&gt;

&lt;p&gt;对应的配置如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;a&quot; type=&quot;xs:integer&quot;/&amp;gt;
&lt;/pre&gt;

&lt;p&gt;设置type为&lt;code class=&quot;highlighter-rouge&quot;&gt;integer&lt;/code&gt;之后会对内容进行检查，如果不是数字则报错，另外可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;simpleType&lt;/code&gt;对其扩展来实现更复杂的限定：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;age&quot;&amp;gt;
    &amp;lt;xs:simpleType&amp;gt;
        &amp;lt;xs:restriction base=&quot;xs:integer&quot;&amp;gt;
            &amp;lt;xs:minInclusive value=&quot;0&quot;/&amp;gt;
            &amp;lt;xs:maxInclusive value=&quot;100&quot;/&amp;gt;
        &amp;lt;/xs:restriction&amp;gt;
    &amp;lt;/xs:simpleType&amp;gt;
&amp;lt;/xs:element&amp;gt;
&lt;/pre&gt;

&lt;p&gt;向元素中添加子元素、属性之后就不是一个简单元素，而是一个复杂元素，可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;complexType&lt;/code&gt;定义其类型：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;note&quot;&amp;gt;
    &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:attribute name=&quot;app&quot; type=&quot;xs:string&quot;/&amp;gt;
    &amp;lt;/xs:complexType&amp;gt;
&amp;lt;/xs:element&amp;gt;
&lt;/pre&gt;

&lt;p&gt;对应的XML的配置为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;easydt:note app=&quot;123&quot;/&amp;gt;&lt;/code&gt;，子节点的定义也很简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:element name=&quot;note&quot;&amp;gt;
    &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:sequence&amp;gt;
            &amp;lt;xs:element name=&quot;a&quot; type=&quot;xs:integer&quot;/&amp;gt;
            &amp;lt;xs:element name=&quot;b&quot; type=&quot;xs:integer&quot;/&amp;gt;
        &amp;lt;/xs:sequence&amp;gt;
    &amp;lt;/xs:complexType&amp;gt;
&amp;lt;/xs:element&amp;gt;
&lt;/pre&gt;

&lt;p&gt;对应的XML的配置为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;note&amp;gt;&amp;lt;a&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;b&amp;gt;2&amp;lt;/b&amp;gt;&amp;lt;/note&amp;gt;&lt;/code&gt;，其中sequence的作用是&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;组中的元素以指定的顺序出现在包含元素中，每个子元素可以出现0次到任意次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然还有其他的方式：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;指示器&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;子元素可以按照任意顺序出现，且每个子元素必须只出现一次&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;choice&lt;/td&gt;
      &lt;td&gt;随便添加子元素，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;maxOccurs&lt;/code&gt;来设置可添加子元素的数目&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;attributeGroup&lt;/td&gt;
      &lt;td&gt;属性组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;group&lt;/td&gt;
      &lt;td&gt;元素组&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;元素的类型是非常复杂的，不同的类型之间很可能有一些定义是可以重用的，我们可以定义一些基础的类型，然后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;extension&lt;/code&gt;对其进行扩展可以得到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;xs:complexType name=&quot;baseInfo&quot;&amp;gt;
    &amp;lt;xs:sequence&amp;gt;
        &amp;lt;xs:element name=&quot;id&quot; type=&quot;xs:string&quot;/&amp;gt;
    &amp;lt;/xs:sequence&amp;gt;
&amp;lt;/xs:complexType&amp;gt;
&amp;lt;xs:complexType name=&quot;fullpersoninfo&quot;&amp;gt;
    &amp;lt;xs:complexContent&amp;gt;
        &amp;lt;xs:extension base=&quot;baseInfo&quot;&amp;gt;
            &amp;lt;xs:sequence&amp;gt;
                &amp;lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&amp;gt;
            &amp;lt;/xs:sequence&amp;gt;
        &amp;lt;/xs:extension&amp;gt;
    &amp;lt;/xs:complexContent&amp;gt;
&amp;lt;/xs:complexType&amp;gt;
&lt;/pre&gt;

&lt;p&gt;其他元素的可以在&lt;a href=&quot;http://www.w3school.com.cn/schema/schema_elements_ref.asp&quot;&gt;这里&lt;/a&gt;查看使用方法~~&lt;/p&gt;

&lt;p&gt;当上面这些不能满足你的需求时，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;any&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;anyAttribute&lt;/code&gt;来允许用户配置没有在schema中定义过的东西，然后在解析的阶段进行处理！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;解析&lt;/h2&gt;

&lt;p&gt;在Spring中定义解析需要用下面两个文件来配置（需要放在META-INF目录，Spring会自动加载）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;spring.schemas&lt;/strong&gt;：命名空间对应的schemas配置的位置&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;spring.handlers&lt;/strong&gt;：命名空间对应的解析类&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// spring.schemas
http\://www.cainiao.com/schema/easydt/easydt.xsd=META-INF/easydt.xsd
// spring.handlers
http\://www.cainiao.com/schema/easydt=com.cainiao.easydt.client.springTag.EasyDtNamespaceHandler
&lt;/pre&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;NamespaceHandlerSupport&lt;/code&gt;中定义了遇到对应的元素的时候应该使用Parser：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class EasyDtNamespaceHandler extends NamespaceHandlerSupport {
	public void init() {
		registerBeanDefinitionParser(&quot;easydt&quot;, new EasyDtBeanDefinitionParser());
	}
}
&lt;/pre&gt;

&lt;p&gt;然后用&lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractBeanDefinitionParser&lt;/code&gt;中拿到配置信息并使用&lt;code class=&quot;highlighter-rouge&quot;&gt;addPropertyValue&lt;/code&gt;来定义BeanDefinition：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class EasyDtBeanDefinitionParser extends AbstractSingleBeanDefinitionParser{
	protected Class&amp;lt;EasyDt&amp;gt; getBeanClass(Element element) {
		return EasyDt.class;
	}
	protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
		builder.addPropertyValue(&quot;domain&quot;, element.getAttribute(&quot;domain&quot;));
	}
}
&lt;/pre&gt;

&lt;p&gt;关于BeanDefinition的载入和解析的过程可以看&lt;a href=&quot;http://book.51cto.com/art/201203/322589.htm&quot;&gt;这里&lt;/a&gt;，具体的解析工作是交给&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanDefinitionParserDelegate&lt;/code&gt;来完成的，如果子元素不是简单元素可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;parseCustomElement&lt;/code&gt;来完成解析：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
builder.addPropertyValue(&quot;provider&quot;,
    parserContext.getDelegate().parseCustomElement(
        DomUtils.getChildElementByTagName(element, &quot;provider&quot;),
        builder.getRawBeanDefinition()));
&lt;/pre&gt;

&lt;p&gt;想更灵活地在Spring中玩耍XML还是要多看看Bean的解析过程。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;用这些最基本的用法基本可以搞定大部分的自定义schema的需求，对于复杂的还需要深入去研究。&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Oct 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/14/Xml-Schema.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/10/14/Xml-Schema.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>JQUERY</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img4.douban.com/mpic/s10170467.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jquery&quot;&gt;为什么学习jQuery&lt;/h2&gt;

&lt;p&gt;原生JavaScript写代码很不方便而且容易出错（一直感觉写getElementById非常地烦），再加上浏览器之间差异处理起来就更烦躁了，jQuery刚好能解决这些问题，而且：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;轻量级&lt;/li&gt;
  &lt;li&gt;链式编程&lt;/li&gt;
  &lt;li&gt;隐式迭代&lt;/li&gt;
  &lt;li&gt;丰富的插件支持&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么，赶紧开始jQuery之旅！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;元素选择及操作&lt;/h2&gt;

&lt;p&gt;用jQuery在选择元素时和用CSS选择非常像且代码量很少，因此上手很容易：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;选择器&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;基本选择器&lt;/td&gt;
      &lt;td&gt;$(‘div’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;层次选择器&lt;/td&gt;
      &lt;td&gt;$(‘.a &amp;gt; div’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;基本过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div:first’)、$(‘input:even’)、$(‘header’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;内容过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div:contains(di)’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可见性过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div:visible’)、$(‘div:hidden’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;属性过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div[title]’)、$(‘div[id][title*=es]’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;子元素过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘div.one :nth-child(2)’)、$(‘div.one :first-child’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表单对象属性过滤选择器&lt;/td&gt;
      &lt;td&gt;$(‘#form1 input:enable’)、$(‘input:checked’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;表单选择器&lt;/td&gt;
      &lt;td&gt;$(‘#form1 :input’)、$(‘#form1 :password’)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;遇到特殊字符时需要转义，比如对&lt;strong&gt;&amp;lt;div id=”id#b”&amp;gt;bb&amp;lt;/div&amp;gt;&lt;/strong&gt;需要用&lt;strong&gt;$(‘#id\#b’)&lt;/strong&gt;来选取，编写时尤其需要注意空格，挨着和不挨着的区别太大了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$(‘.test :hidden’)&lt;/li&gt;
  &lt;li&gt;$(‘.test:hidden’)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了可以使用jQuery，还有其他的方式支持CSS选择器，这里就省略了~ 用选择器拿到的是jQuery对象（对dom对象做了封装），可用$cr[0]拿到对应的dom对象~&lt;/p&gt;

&lt;p&gt;另外jQuery对DOM操作的封装有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;用法&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;创建&lt;/td&gt;
      &lt;td&gt;$(‘&amp;lt;li&amp;gt;abc&amp;lt;/li&amp;gt;’)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;插入&lt;/td&gt;
      &lt;td&gt;$(“p”).prepend($(‘&amp;lt;li&amp;gt;abc&amp;lt;/li&amp;gt;’))&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;删除&lt;/td&gt;
      &lt;td&gt;remove&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;复制&lt;/td&gt;
      &lt;td&gt;$(this).clone(true)没有参数时复制生成的对象不具有任何行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;替换&lt;/td&gt;
      &lt;td&gt;$(“p”).replaceWith(“&amp;lt;strong&amp;gt;abc&amp;lt;strong&amp;gt;”)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;包裹&lt;/td&gt;
      &lt;td&gt;$(“strong”).warp(“&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;”)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;设置/获取属性&lt;/td&gt;
      &lt;td&gt;获取：$para.attr(“title”)，设置：$para.attr(“title”, “new title”)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;样式&lt;/td&gt;
      &lt;td&gt;addClass、removeClass、toggleClass、hasClass、css&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;文本&lt;/td&gt;
      &lt;td&gt;获取：$para.html()，设置：$para.html(“&amp;lt;strong&amp;gt;abc&amp;lt;strong&amp;gt;”)，text()/val()&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;子元素&lt;/td&gt;
      &lt;td&gt;children&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;兄弟元素&lt;/td&gt;
      &lt;td&gt;next、pre、sibling&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事件与动画&lt;/h2&gt;

&lt;p&gt;以前经常在代码中看到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
$(function(){
    // DOM就绪时执行的方法
});
&lt;/pre&gt;

&lt;p&gt;作用像是绑定了对ready的响应，而对于普通的事件（鼠标点击等）可以用&lt;strong&gt;on&lt;/strong&gt;来统一搞定：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;on(events, [, selector] [, data], handler)
on( eventsMap [, selector ] [, data ] )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参数的含义如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;events&lt;/strong&gt;：一个或多个用空格分隔的事件类型和可选的命名空间&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;eventsMap&lt;/strong&gt;：属性对应事件类型和可选的命名空间，属性值对应绑定的事件处理函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;selector&lt;/strong&gt;：指定哪些后代元素可以触发绑定的事件&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;：触发事件时，需要通过event.data传递给事件处理函数的任意数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;handler&lt;/strong&gt;：事件处理函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：在jQuery1.8之后bind、delegate、live都不建议使用，所以干脆就都用on好了！&lt;/p&gt;

&lt;p&gt;另外并不是每个事件都只有一个处理函数，在jQuery中有两个合成事件：&lt;strong&gt;hover&lt;/strong&gt;和&lt;strong&gt;toggle&lt;/strong&gt;，其中hover的使用方法如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;hover(enter, lever)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;分别用两个函数来响应移入和移出，相比较toggle就更加暴力了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;toggle(f1, f2, …., fn)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在第一次点击时调用f1、第二次调用f2、依次类推，n个方法循环调用（没想到需要用到什么地方- -!），jQuery对事件对象进行了封装，提供如下方法：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;type()&lt;/td&gt;
      &lt;td&gt;类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;stopPropagation()&lt;/td&gt;
      &lt;td&gt;停止事件冒泡&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;preventDefault()&lt;/td&gt;
      &lt;td&gt;阻止默认的行为，比如可以阻止点击&amp;lt;a&amp;gt;标签打开新页面的行为&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;target()&lt;/td&gt;
      &lt;td&gt;触发事件的元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;relatedTarget()&lt;/td&gt;
      &lt;td&gt;获取相关元素，在mouseover和mouseout的时候经常用到&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;which()&lt;/td&gt;
      &lt;td&gt;鼠标点击或者键盘点击事件中，获取具体的按键&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;既然能绑定就应该能解除：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jQueryObject.off( [ events [, selector ] [, handler ] ] )
jQueryObject.off( eventsMap [, selector ] )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：可以用&lt;strong&gt;trigger&lt;/strong&gt;来模拟事件，用来实现一些功能（比如快捷键）还是非常方便的！在jQuery中对DOM元素上的动画做了一些封装（不用再蛋疼地使用setTimeout）：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;效果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;show/hide&lt;/td&gt;
      &lt;td&gt;显示、隐藏元素，可通过参数控制速度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fadeIn/fadeOut&lt;/td&gt;
      &lt;td&gt;改变元素不透明度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;slideUp/slideDown&lt;/td&gt;
      &lt;td&gt;改变元素高度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;animate&lt;/td&gt;
      &lt;td&gt;自定义动画，上面的功能用该方法都很容易搞定&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;toggle&lt;/td&gt;
      &lt;td&gt;两种状态切换，用在按钮的效果上面非常合适&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;slideToggle&lt;/td&gt;
      &lt;td&gt;通过高度变化来切换元素的可见性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fadeTo&lt;/td&gt;
      &lt;td&gt;以渐进的方式修改不透明度&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;strong&gt;animate&lt;/strong&gt;的定义如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;animate(params, speed, callback)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;参数含义如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;params&lt;/strong&gt;：包含样式属性及值的映射，用来控制动画的行为&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;speed&lt;/strong&gt;：速度&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;callback&lt;/strong&gt;：结束时的回调函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面来看几个实际的例子感受下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
$(this).animate({left:&quot;500px&quot;}, 3000);// 使left从原来的值变为500
$(this).animate({left:&quot;+=500px&quot;}, 3000);// 使left从原来的值增加500
$(this).animate({left:&quot;+=500px&quot;,height:&quot;+=600px&quot;}, 3000);// 多重动画
$(this).animate({left:&quot;+=500px&quot;}, 3000)
       .animate({height:&quot;+=500px&quot;}, 3000);// 两个动画效果链式写法
&lt;/pre&gt;

&lt;p&gt;延迟总是会带来问题，比如为元素的移入、移出设计了动画，但是在鼠标快速移动的时候动画的效果可能就与实际鼠标的位置不一致了，这时候需要&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;stop([cleanQueue] [, gotoEnd])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cleanQueue：是否清空未执行完成的动画&lt;/li&gt;
  &lt;li&gt;gotoEnd：是否将正在执行的动画跳转到末状态&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外可以使用&lt;strong&gt;$(this).is(“:animated”)&lt;/strong&gt;判断元素是否处于动画状态！&lt;/p&gt;

&lt;h2 id=&quot;ajax&quot;&gt;Ajax&lt;/h2&gt;

&lt;p&gt;全称为&lt;strong&gt;Asynchronous JavaScript and XML&lt;/strong&gt;，并不是指一种单一的技术，而是有机地利用一系列交互式网页应用相关的技术所形成的结合体，优势：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不需要插件支持&lt;/li&gt;
  &lt;li&gt;优秀的用户体验&lt;/li&gt;
  &lt;li&gt;提高Web程序的性能&lt;/li&gt;
  &lt;li&gt;减轻服务器和带宽的负担&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浏览器对XMLHttpRequest对象的支持度不足&lt;/li&gt;
  &lt;li&gt;破坏浏览器前进、后退按钮的正常功能&lt;/li&gt;
  &lt;li&gt;对搜索引擎的支持不足&lt;/li&gt;
  &lt;li&gt;开发和调试工具的缺乏&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于JavaScript原生的写法可以看&lt;a href=&quot;http://wsztrush.github.io/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/09/JavaScript-Basic.html&quot;&gt;这里&lt;/a&gt;，在jQuery中的封装如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;load(url [,data] [, callback])&lt;/td&gt;
      &lt;td&gt;加载HTML文档并插入DOM中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get(url [,data] [, callback] [, type])&lt;/td&gt;
      &lt;td&gt;使用GET方式异步请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;post(url [,data] [, callback] [, type])&lt;/td&gt;
      &lt;td&gt;使用POST方式异步请求&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getScript()&lt;/td&gt;
      &lt;td&gt;加载脚本文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;getJson()&lt;/td&gt;
      &lt;td&gt;加载JSON文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ajax()&lt;/td&gt;
      &lt;td&gt;最底层的实现，是其他方法的基础&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;方法ajax()的参数如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;url&lt;/strong&gt;：发送请求的地址&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;type&lt;/strong&gt;：请求方式（GET or POST）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;timeout&lt;/strong&gt;：请求超时时间（毫秒）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;：发送到服务端的数据&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;dataType&lt;/strong&gt;：预期服务器返回的数据类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;beforeSend&lt;/strong&gt;：发送请求前执行的函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;complete&lt;/strong&gt;：请求完成后的回调函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;success&lt;/strong&gt;：请求成功后的回调函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;error&lt;/strong&gt;：请求失败时的回调函数&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;global&lt;/strong&gt;：是否触发全局Ajax事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于巨大的表单在提交的时候获取参数是非常繁琐的，在jQuery做了简单的封装serialize()、serializeArray()、param()。在用上面的方法发送请求的过程中会触发事件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ajaxStart&lt;/li&gt;
  &lt;li&gt;ajaxSend&lt;/li&gt;
  &lt;li&gt;ajaxSuccess&lt;/li&gt;
  &lt;li&gt;ajaxComplete[](http://)&lt;/li&gt;
  &lt;li&gt;ajaxError&lt;/li&gt;
  &lt;li&gt;ajaxStop&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;利用这些事件我们可以很容易为请求的各个环节封装相同的响应！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;插件&lt;/h2&gt;

&lt;p&gt;jQuery的插件非常多，再很多地方（比如&lt;a href=&quot;http://www.htmleaf.com/&quot;&gt;这里&lt;/a&gt;）可以搜索，这里主要来看下自己如何造插件，涉及到的方法有：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jQuery.extend( target [, object1 ] [, objectN… ] )
jQuery.extend( [ deep ], target , object1 [, objectN… ] )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;该方法用来将一个或者多个对象的成员属性和方法复制到指定的对象上，参数的含义为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;deep&lt;/strong&gt;：是否深度合并对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;target&lt;/strong&gt;：目标对象，其他对象的成员属性将被复制到该对象上&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;object1&lt;/strong&gt;：第一个被合并的对象&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;objectN&lt;/strong&gt;：第N个被合并的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有一个用来扩展jQuery对象方法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;jQuery.fn.extend( object )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在可以编写插件了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
;(function($){
    // 封装jQuery对象方法
	$.fn.extend({
        &quot;color&quot; : function(value){/* 插件代码 */}
    })
    // 直接对jQuery对象进行扩展
    $.extend({
        ltrim : function(text) {
            return (text || &quot;&quot;)
        }
    })
})(jQuery);
&lt;/pre&gt;

&lt;p&gt;编写一些插件写法需要对jQuery本身的运行的机制由一定的了解~&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;jQuery主要是用来简化开发，对JavaScript做了一些封装，不需要再考虑很多兼容性的东西，而且代码也更加简洁，列出一些参考资料：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jquery.cuishifeng.cn/index.html&quot;&gt;api&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.365mini.com/doc&quot;&gt;codeplayer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.htmleaf.com/&quot;&gt;jquery之家&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html&quot;&gt;jquery最佳实践&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/07/jquery_fundamentals.html&quot;&gt;jquery设计思想&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 16 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/09/16/Jquery.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/09/16/Jquery.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>Grunt</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://www.gruntjs.net/img/grunt-logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;WHY&lt;/h2&gt;

&lt;p&gt;在用Java写完源码之后需要编译成Class才能执行，其实前端也是类似的，需要压缩等操作才是真正的成品，况且现在前端的工具越来越多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;LESS&lt;/li&gt;
  &lt;li&gt;CoffeeScript&lt;/li&gt;
  &lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些都需要预处理成最终的CSS、JS才能被使用，而GRUNT则将这些过程管理起来，你只需要开开心心写代码就好了~&lt;/p&gt;

&lt;h2 id=&quot;how&quot;&gt;HOW&lt;/h2&gt;

&lt;p&gt;当然首先需要node.js，然后&lt;strong&gt;npm install -g grunt-cli&lt;/strong&gt;安装命令行工具，在工程下面配置两个文件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;package.json&lt;/strong&gt;：被npm用于存储项目元数据，以便将此项目发布为npm模块，可以在这里列出项目依赖的Grunt和Grunt插件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Gruntfile.js&lt;/strong&gt;：用来配置或定义任务并加载Grunt插件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;执行&lt;strong&gt;npm install&lt;/strong&gt;安装项目依赖的库，然后执行&lt;strong&gt;grunt&lt;/strong&gt;即可，package.json配置文件如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
{
    &quot;name&quot;: &quot;my-project-name&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;devDependencies&quot;: {
        &quot;grunt&quot;: &quot;~0.4.5&quot;,
        &quot;grunt-contrib-jshint&quot;: &quot;~0.10.0&quot;,
        &quot;grunt-contrib-nodeunit&quot;: &quot;~0.4.1&quot;,
        &quot;grunt-contrib-uglify&quot;: &quot;~0.5.0&quot;
    }
}
&lt;/pre&gt;

&lt;p&gt;可以通过命令&lt;strong&gt;npm install &amp;lt;module&amp;gt; –save-dev&lt;/strong&gt;安装插件的同时向文件中的devDependencies字段添加，&lt;a href=&quot;http://www.gruntjs.net/plugins&quot;&gt;这里&lt;/a&gt;有插件列表。&lt;/p&gt;

&lt;p&gt;文件Gruntfile.js由三部分组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;配置任务：grunt.initConfig&lt;/li&gt;
  &lt;li&gt;加载插件：grunt.loadNpmTasks&lt;/li&gt;
  &lt;li&gt;定义任务：grunt.registerTask&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本上配置好之后就可以跑起来了，更多看&lt;a href=&quot;http://www.gruntjs.ne&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2015/09/15/Grunt.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2015/09/15/Grunt.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>CSS基础和LESS入门</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s2921314.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看《CSS权威指南》的时候简单的整理了一些&lt;a href=&quot;http://naotu.baidu.com/file/ed1f91b9f4ba914a4d97e404acd71ee3?token=33581ba44ab41688&quot;&gt;笔记&lt;/a&gt;，有些东西比之前有了更深的理解，但是用这么厚的一本书来学CSS多少有些头大，只需要把一些关键的东西理解透彻，具体的设置查&lt;a href=&quot;http://www.w3chtml.com/css3/&quot;&gt;手册&lt;/a&gt;更快！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;布局和定位&lt;/h2&gt;

&lt;p&gt;原生的HTML中元素分为两种：&lt;strong&gt;块级元素&lt;/strong&gt;和&lt;strong&gt;行内元素&lt;/strong&gt;，而CSS中用display来影响元素的展示：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;none&lt;/td&gt;
      &lt;td&gt;隐藏对象并且不会保留物理空间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline&lt;/td&gt;
      &lt;td&gt;行内元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;block&lt;/td&gt;
      &lt;td&gt;块级元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline-block&lt;/td&gt;
      &lt;td&gt;行内块元素，也就是说横着排列的同时可以指定宽高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;box&lt;/td&gt;
      &lt;td&gt;弹性盒子模型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline-box&lt;/td&gt;
      &lt;td&gt;行内弹性盒子，和inline-block有点类似&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;直接使用top、right等是不会起作用的，想要起作用得用position来配合：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;static&lt;/td&gt;
      &lt;td&gt;不使用定位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;relative&lt;/td&gt;
      &lt;td&gt;相对于父节点的位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;absolute&lt;/td&gt;
      &lt;td&gt;绝对定位，会跟滚动条滚动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fixed&lt;/td&gt;
      &lt;td&gt;固定定位，不会跟随滚动&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当用relative有问题的时候可能是你的HTML结构错了导致父节点判断错误导致的:)用display+position可以把一个元素放到你想要的位置，但是一个块也不是简单的长方形，也有其结构：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;margin&lt;/td&gt;
      &lt;td&gt;外补白&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;padding&lt;/td&gt;
      &lt;td&gt;内补白&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;border&lt;/td&gt;
      &lt;td&gt;边框&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;外补白比较特殊一点：取的双方的是max而不是sum，在chrome控制台玩一下就能很好地理解这三个的用法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Css-Less.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直观上背景图片是用来做背景的，但是感觉现在都被大家玩坏了，比如经常把很多的图标放到一个图片上然后用&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
.x {
    background-image:url(img-url);
    background-position:-100px 100px;
}
&lt;/pre&gt;

&lt;p&gt;就可以在对应的DIV中展示出局部图片，这个局部就可能是某个ICON，感觉这完全是在当图片使用额~ 当内容超过限制的时候可以使用&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;overflow&lt;/li&gt;
  &lt;li&gt;overflow-x&lt;/li&gt;
  &lt;li&gt;overflow-y&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来进行控制，但是滚动条的默认样式实在是太丑了，在&lt;a href=&quot;http://www.webhek.com/scrollbar&quot;&gt;这里&lt;/a&gt;找到一种修改的方法，对于&lt;strong&gt;-webkit-&lt;/strong&gt;核的浏览器来说很简单，但是要去兼容IE+FX比较麻烦，可以考虑用&lt;a href=&quot;http://www.jqcool.net/demo/201404/jquery-jscrollpane/&quot;&gt;jQuery插件&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;变换和动画&lt;/h2&gt;

&lt;h2 id=&quot;less&quot;&gt;LESS&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://www.1024i.com/demo/less/images/logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然它的口号是&lt;strong&gt;LESS IS MORE, THAN CSS&lt;/strong&gt;，但是确实感觉LESS是在CSS的基础上增加了一些扩展&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;变量&lt;/li&gt;
  &lt;li&gt;继承&lt;/li&gt;
  &lt;li&gt;嵌套&lt;/li&gt;
  &lt;li&gt;运算&lt;/li&gt;
  &lt;li&gt;函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外LESS实际兼容CSS的（也就是说你可以在里面直接写CSS代码），实际使用时可以在后端将其打包（比如Grunt）成CSS文件之后再提供给前端，具体用法可以看&lt;a href=&quot;http://www.1024i.com/demo/less/index.html&quot;&gt;这里&lt;/a&gt;的中文文档。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Fri, 11 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/11/Css-Less.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/11/Css-Less.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
