<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 19 Jun 2015 21:02:14 +0800</pubDate>
    <lastBuildDate>Fri, 19 Jun 2015 21:02:14 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>拣选单执行情况总结</title>
        <description>&lt;p&gt;数据处理方案有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;离线计算：Hadoop&lt;/li&gt;
  &lt;li&gt;实时计算：Spark&lt;/li&gt;
  &lt;li&gt;流计算：Storm&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这离线计算有点是吞吐量大、逻辑简单，但时效太差，在仓库里面出现问题的时候一个小时（甚至一天）之后才汇报给管理员，估计没人会用了。&lt;/p&gt;

&lt;p&gt;很多人都会讲实时计算和流计算放在一起，他们还是有区别的：Spark可以看成是内存版的Hadoop，把数据放到内存里面可以提高处理速度。另外&lt;strong&gt;ADS&lt;/strong&gt;（阿里云的一个产品）可能做的更优秀一些，在大量的数据上面做统计。而&lt;strong&gt;Storm&lt;/strong&gt;则是监听变化来统计&lt;strong&gt;结果&lt;/strong&gt;，处理的是增量的数据。&lt;/p&gt;

&lt;p&gt;总体上根据读、写的比例，不同的方式各有优劣！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;项目背景&lt;/h2&gt;

&lt;p&gt;本项目的目的是为仓库管理系统（WMS）做一个作业执行情况监控的功能，WMS里面的概念繁多，项目中核心包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;拣选单&lt;/strong&gt;：在拣选单上面有一些要去拣选的商品及数据，库工拿着它推着小车去拿东西&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;包裹&lt;/strong&gt;：一个拣选单对应多个包裹，弄完之后包裹会称重-&amp;gt;包装-&amp;gt;发货-&amp;gt;出库&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后希望通过下面两个维度来进行展示：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;统计拣选单上面各状态的包裹数&lt;/li&gt;
  &lt;li&gt;统计各库区的未拣选完的拣选单数、包裹数、商品数及品种数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一个维度用来看单个拣选单的执行情况，其实把所有拣选单都列出来之后也能够反映出整个仓库的执行情况。&lt;/p&gt;

&lt;p&gt;第二个维度则用来看是否某个库区中的拣选工作量太大，比如为拣选完成的商品数太多就说明是这种情况，此时仓库管理员可以从其他不怎么忙的库区抽调一些人去帮忙。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;技术方案&lt;/h2&gt;

&lt;p&gt;前段时间看了一些JSTORM（一个类似STORM东西，用JAVA重写的）的东西，这次就用它来搞，总体上是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/拣选单-总结-架构.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中几个关键部分用到了公司的中间件：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;中间件&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;DRC&lt;/td&gt;
      &lt;td&gt;监听数据库的变化并存储下来，供各种应用进行消费，后发生的消息ID更大&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OTS&lt;/td&gt;
      &lt;td&gt;类似HBase，不过现在太挫了&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;现在系统中的机器上的缓存也是用DRC来实现了，每台机器都会消费DRC的消息，然后根据更新来对本地的缓存进行更新，但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在流计算中，每个变更消息只需要被一台机器消费！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在公司内部貌似没有什么工具能做很灵活的路由，而恰巧JSTORM里面的&lt;strong&gt;fieldsGrouping&lt;/strong&gt;刚好可以轻松解决掉，可以在Spout根据指定的Field将Tuple发送给Bolt进行处理，这样只需要指定Field为拣选单ID就可以将相同的拣选单发送给同一个Task进行处理。&lt;/p&gt;

&lt;p&gt;多台机器随机消费DRC消息的时候，如果同一个拣选单相关的消息落在不同的机器上面，此时对应的Task要更新拣选单状态时必须要通过分布式锁来保证状态的准确性！这个麻烦也被顺带着解决了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-E.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;即便是相同的拣选单都落在同一个机器上面，但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;消息到达的顺序可能是乱序的！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;查看DRC文档之后发现在变更的消息中有字段ID，越晚的更新ID越大。接收到的消息虽然是乱序的，但是毕竟是在同一个Task中，那么解决办法就简单了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从OTS中取出单据状态&lt;/li&gt;
  &lt;li&gt;比较记录的ID与变更消息的ID比较&lt;/li&gt;
  &lt;li&gt;如果变更消息更小，则放弃&lt;/li&gt;
  &lt;li&gt;如果变更消息更大，那么更新单据状态，然后将其放入OTS&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在OTS中永远保存单据最新的状态不会有错！但是这又有什么意义？如果光是为了取正确的状态直接去数据库好了啊！要想通过SQL获取记录少量还可以，如果多了基本上铁定会超时（因为要联表）。在流计算中要想达到联表的效果很不容易：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不同任务执行速度不同，如果直接联表可能出现当前数据与10分钟前另一份数据关联！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这问题解决起来比较容易，有两个任务同时消费拣选单、包裹的变更消息，每消费完成一分钟的数据，那么就将其保存一个版本，而在他们都完成某个时间点的变更之后，再将他们联表！&lt;/p&gt;

&lt;p&gt;看似很美好，其实有个大问题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当一个任务半天没有接收到消息的时候，可能是把本分钟的消息消费完了，也有可能是消息还没来！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再次翻DRC的文档发现它有一个心跳消息，这种心跳消息和我们通常理解的完全不同！在收集binlog的时候就已经将它插入到持久化存储中。在拉取消息的时候，同时也会拉取到对应时间点的心跳记录。&lt;/p&gt;

&lt;p&gt;那么此时要做的就是：如果没有拉取到消息，并且已经接收到下一分钟的心跳消息，那么本分钟的所有的消息都已经处理过了。但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;处理过了并不代表都处理成功了！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在Spout端emit给Bolt出里之后，如果成功就会ack，如果失败则fail。他们都会通过acker任务通知给Spout进行统计或者重试。那么我们可以利用这个规则来判断：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在emit时all计数加一&lt;/li&gt;
  &lt;li&gt;在ack时success数加一&lt;/li&gt;
  &lt;li&gt;在fail时all加一并重新发送消息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样在完成所有的消息消费时应该有&lt;strong&gt;all == success&lt;/strong&gt;，综合上面的判断就可以知道某分钟是否全部成功处理。&lt;/p&gt;

&lt;p&gt;即便是能保证消息按照我们设计的数据一分钟一分钟地写入数据库，但是写入过程仍然是需要时间的（不可能一瞬间完成），那么：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写入与读取同时进行的话，可能读取到的一部分是老版本、一部分是新版本！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;简单来说仅仅将数据读出来展示倒是问题不大，但如果要再其上面做进一步的加工，那么就完蛋了！先不管用户看到的数据有多大影响，光让测试去验证系统的准确性都是一个非常头疼的问题了！&lt;/p&gt;

&lt;p&gt;解决这种问题基本上都是用版本来搞，比如HBase中的&lt;strong&gt;timestamp&lt;/strong&gt;就可以轻松搞定，但是HBase这货查询起来太麻烦了。当然你可能想到用&lt;strong&gt;Phoenix&lt;/strong&gt;来搞，复杂性和效率先不说，关键是公司的PE已经不给HBase资源了，主推OTS！&lt;/p&gt;

&lt;p&gt;无奈跑去问OTS的负责人，得到答复：&lt;strong&gt;支持SQL不在考虑之中&lt;/strong&gt;~~~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-A.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没办法只能放到MySQL里面了，如果每个版本记录都有一条记录，有两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据库中的记录会变成实际数据量的N倍&lt;/li&gt;
  &lt;li&gt;查询复杂&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有天睡觉醒来突然想到一个解决办法！如果将所有的版本都记录下来，其实起作用的最多只有两个版本，那么：&lt;strong&gt;对每条数据只记录两个版本的数据即可&lt;/strong&gt;。在更新某条数据时：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从DB中取出所有版本（最多两条）&lt;/li&gt;
  &lt;li&gt;如果有两条
    &lt;ul&gt;
      &lt;li&gt;取出版本较大的一条记录&lt;/li&gt;
      &lt;li&gt;将较小的版本的ID给他&lt;/li&gt;
      &lt;li&gt;更新数据库&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果有一条或者根本没有
    &lt;ul&gt;
      &lt;li&gt;创建新对象并插入数据库中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;而在取数据的时候需要加上简单的版本限制：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
(_version &amp;lt;= #currVersion# AND (_max_version = _version OR _max_version &amp;gt;= #currVersion#))
&lt;/pre&gt;

&lt;p&gt;这种效率显然比联表查效率会高很多！&lt;/p&gt;

&lt;p&gt;一般流数据只关心从现在开始发生的变化，但是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如何历史数据也很重要，需要更更实时的数据合并怎么办！！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仔细想一下，其实也是有办法的，在流计算运行之前做一次数据初始化即可！将所有的数据当前的状态当做的一个时间点变更的结果插入OTS中，然后让OTS来进行消费。在持久化DRC消息到OTS的任务中，设置DRC启动的时间点稍前一些，这样的话增量和全量直接就有覆盖，如果当前状态是4，那么覆盖的过程可能是：4-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;···这样就构成了一个环，中间状态的累加并不会出错！&lt;/p&gt;

&lt;p&gt;哎，饶了这么多的弯，就是为了能够给用户看到一份准确的数据！开始干活！！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开发过程&lt;/h2&gt;

&lt;p&gt;在开始写代码的时候，很多的事情还没有想清楚，但是如果一直因为没有想清楚不开工的话就太傻逼了！光想是没办法永远都想清楚的！&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Move Fast And Break Things.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说干就干！刚开始看到包裹里面的有area_id的时候以为是库区ID，然后也没当回事，过了两天仔细一看完全不是那么回事，因为获取不到库区歇菜了？&lt;/p&gt;

&lt;p&gt;请教同事之后发现包裹占用表上有pick_area_id，我只能说当初添加这个字段的哥们太聪明了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-E.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看了一下线下的数据库，发现这个字段很多为空！心想应该是大家在日常数据滥用的结果，赶紧到线上看一下，发现这个字段在所有记录里面全部为空！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-D.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;坑到了！但回头一想：肯定有个地方是有位置信息的，这时候看到了占用表中有货位的编码，样子大概是&lt;strong&gt;A0-B0-C0&lt;/strong&gt;，而第一个为A0则为库区编码，这时候仿佛看到了希望，赶紧找别人确认一下！我去，这种规则是仓库自己配的，他们想怎么配怎么配，完全不可靠!!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-D.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没办法，注意到占用表里面还有一个货位ID，货位必然属于某个库区，在系统中肯定有地方维护这个关系！请教对应同事之后果然如此，这个问题算是搞定了。&lt;/p&gt;

&lt;p&gt;之前一直以为DRC中的心跳消息可以分割不同时间段的消息，比如收到10分钟的消息，那么它之前的就全部是十分钟之前的，它之后就全部是十分钟之后的，而这个项目也是建立在这个基础上的！但是突然有一天他们团队的人跑过来说并不是这样！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-A.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个团队的人怎么能说话都不一致！在以为又被坑大了的时候，仔细思考：其实这个项目对心跳记录的要求并没有这么高，只需要保证在接收到消息之后，它之前的数据一定消费完了，而至于有没有消费它之后的数据则并没有那么大的关系！再次去跟他们确认，得到的答复确实是这样的！哈哈哈~~&lt;/p&gt;

&lt;p&gt;开发到后期，商品品种数成了麻烦，因为是品种数所以不能简单的进行累加（不然就变成商品数了）！马上想到一个最简单的解决办法：在OTS中保存一个Map来记录！但是OTS中的值有大小限制，赶紧去问同事一个拣选单中商品数最多有多少个！结果是没有限制….&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/FACE-A.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;真的无解了么？仔细想了一番，想到一种解决方法：为每个itemId建一个key，value为其对应的包裹数！在有包裹创建的时候value++，而在包裹删除的时候value–。那么可以在从0变1的时候增加品种数，从1变0的时候减少品种数！&lt;/p&gt;

&lt;p&gt;纠结了两个小时，感觉这种做法太复杂，而且效率也非常低！这时候想可能线上每个拣选单的商品品种数根本就很少！赶紧去线上捞了一把，果然如此！另外发现包裹删除是发生在拆包的情况，而此时仅仅是将包裹一拆为二，里面的品种数并没有发生变化！这样直接在OTS中保存一个itemId的SET即可！&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;现存问题&lt;/h2&gt;

&lt;p&gt;系统虽然上线了，但是还有一些问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;处理效率不高&lt;/li&gt;
  &lt;li&gt;对OTS的依赖太大&lt;/li&gt;
  &lt;li&gt;全量数据和增量数据合并还是可能导致结果出错，原因和解决办法都比较简单&lt;/li&gt;
  &lt;li&gt;在Jstorm中获取数据是通过SQL来的，这样增加了DB的连接数&lt;/li&gt;
  &lt;li&gt;对Jstorm依赖太重，而Jstorm有自身的缺陷&lt;/li&gt;
  &lt;li&gt;每次开发需求都要做代码开发&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，流计算本身就是监控（或者说是报表）的一部分，但是这应该把监控当做一个产品来考虑！最近也在想一些为来的计划：&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;未来计划&lt;/h2&gt;

&lt;p&gt;既然要做，就做到最屌！现在公司内部并没有一个面向&lt;strong&gt;用户的监控&lt;/strong&gt;系统，面向小二的倒是一大堆。另外，面向小二的也做的并不怎么完善，很多都没有当做一个产品来做，那么接下来要做的就是把监控、数据报表分块并一一解决掉：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;通知模块：维护用户、组的信息，可以向组、用户发送消息，支持推拉两种方式&lt;/li&gt;
  &lt;li&gt;数据打通：打通数据计算模块和各个模块之间的数据访问&lt;/li&gt;
  &lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E6%B5%81%E6%B0%B4%E8%B4%A6/2015/06/19/Pickbill-Monitor.html</link>
        <guid isPermaLink="true">/%E6%B5%81%E6%B0%B4%E8%B4%A6/2015/06/19/Pickbill-Monitor.html</guid>
        
        
        <category>流水账</category>
        
      </item>
    
      <item>
        <title>VIM</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/VIM-LOGO.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很早之前就知道VIM很厉害，不过作为一个Java攻城狮，用起来实在是不方便，完全没有Eclipse或者IDEA写代码顺畅，比如代码提示等（怀疑自己配置有问题-.-!）。最近对golang非常感兴趣，然而默认的IDE实在是太丑了，所以决心把VIM捡起来。&lt;/p&gt;

&lt;p&gt;周围用Emacs的同事越来越多，但是简单用了几次，总觉得不怎么顺手，也就不了了之。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;插件管理器&lt;/h2&gt;

&lt;p&gt;相比现代编辑器，VIM缺乏默认的插件管理功能，之前在配置时不停地从网上收集插件，然后粘贴到对应的目录下。这个过程相当地考验耐心，以及人品。&lt;/p&gt;

&lt;p&gt;最近无意间发现了一个插件管理工具：&lt;strong&gt;vundle&lt;/strong&gt;。玩了一下感觉还不错，首先从github上下载:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后修改&lt;strong&gt;vimrc&lt;/strong&gt;文件：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
set nocompatible &quot;关闭兼容模式
filetype off &quot;
set rtp+=~/.vim/bundle/Vundle.vim &quot; 写自己安装的目录
call vundle#begin() &quot;

Bundle 'gmarik/Vundle.vim' &quot; 插件列表
&quot; ... 插件列表

call vundle#end() &quot;
filetype plugin indent on
&lt;/pre&gt;

&lt;p&gt;如果是&lt;strong&gt;vim-scripts&lt;/strong&gt;下面的插件直接写名字就好了，否则为&lt;strong&gt;用户名/插件&lt;/strong&gt;的格式，使用时用到的几个命令如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleList&lt;/td&gt;
      &lt;td&gt;列举出列表中(.vimrc中)配置的所有插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall&lt;/td&gt;
      &lt;td&gt;安装列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleInstall!&lt;/td&gt;
      &lt;td&gt;更新列表中全部插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch foo&lt;/td&gt;
      &lt;td&gt;查找foo插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleSearch! foo&lt;/td&gt;
      &lt;td&gt;刷新foo插件缓存&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;:BundleClean!&lt;/td&gt;
      &lt;td&gt;清除列表中没有的插件&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;写代码之前&lt;/h2&gt;
</description>
        <pubDate>Wed, 10 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2015/06/10/VIM.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>Golang入门</title>
        <description>&lt;p&gt;虽然Go已经不算是一个很新的语言了，但是现在非常地火！一般来说语言本身没有什么好讲究的，能快速编程、少点坑就算是一门好的语言了。但是，如果语言火了之后，其周围的工具发展起来之后，能用它做的事情就太多了~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;环境搭建&lt;/h2&gt;

&lt;p&gt;因为我仅仅打算在ubuntu上面进行golang的开发，所以其他的系统后面用过了再来补充！配置来说相当容易：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载golang的包解压安装，如果官网上的访问不到就到&lt;a href=&quot;http://www.golangtc.com/&quot;&gt;golang中国&lt;/a&gt;找个版本下载&lt;/li&gt;
  &lt;li&gt;在/etc/profile中配置&lt;strong&gt;PATH&lt;/strong&gt;、&lt;strong&gt;GOROOT&lt;/strong&gt;、&lt;strong&gt;GOPATH&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;配置你的IDE&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面就开始GOLANG的学习。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基础语法&lt;/h2&gt;

&lt;p&gt;按照惯例，来看Hello World代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
package main

import &quot;fmt&quot;

func main(){
    fmt.Println(&quot;Hello World&quot;);
}
&lt;/pre&gt;

&lt;p&gt;使用&lt;strong&gt;go run hello.go&lt;/strong&gt;即可执行，也可以使用&lt;strong&gt;go build hello.go&lt;/strong&gt;打包完成之后在运行，所有的命令作用如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;build&lt;/td&gt;
      &lt;td&gt;用于测试编译&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;clean&lt;/td&gt;
      &lt;td&gt;移除当前源码包里面编译生成的文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;env&lt;/td&gt;
      &lt;td&gt;环境变量&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fix&lt;/td&gt;
      &lt;td&gt;修复以前老版本的代码到新版本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fmt&lt;/td&gt;
      &lt;td&gt;代码格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;generate&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;get&lt;/td&gt;
      &lt;td&gt;动态获取远程代码包的，目前支持的有BitBucket、GitHub、Google Code和Launchpad&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;install&lt;/td&gt;
      &lt;td&gt;生成结果文件(可执行文件或者.a包)，把编译好的结果移到$GOPATH/pkg或者$GOPATH/bin&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;list&lt;/td&gt;
      &lt;td&gt;列出当前全部安装的package&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;run&lt;/td&gt;
      &lt;td&gt;编译并运行Go程序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;test&lt;/td&gt;
      &lt;td&gt;自动读取源码目录下面名为*_test.go的文件，生成并运行测试用的可执行文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;tool&lt;/td&gt;
      &lt;td&gt;运行对应的工具类&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;version&lt;/td&gt;
      &lt;td&gt;版本号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;码代码最基本的是变量和常量，在Go中的定义方法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var a string = &quot;initial&quot;  /* 变量 */
const s string = &quot;initial&quot; /* 常量 */
&lt;/pre&gt;

&lt;p&gt;另外一些基本的控制结构也基本一致，简单来看就是省略了不少的括号：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// FOR
for i &amp;lt;= 3
for i := 1; i &amp;lt;= 3; i++
for
// IF
if 8%4 == 0
if num := 9; num &amp;lt; 0
// SWITCH
switch time.Now().Weekday() {
    case time.Saturday, time.Sunday:
    default:
}
&lt;/pre&gt;

&lt;p&gt;Go中的集合用起来感觉跟Python中的有点像：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// ARRAY:数组
var a [5]int
b := [5]int{1, 2, 3, 4, 5}
var c [2][3]int

// SLICES:跟数组很像，不过区间操作非常方便
s := make([]string, 10)
l := s[2:5]
l := s[2:]
l := s[:5]

// RANGE:更方便地遍历，数组的话返回下标和值，MAP返回KEY、VALUE
for _,num := nums {
    sum += num;
}

// MAP:这个没什么好说的
m := make(map[string]int)
m[&quot;a&quot;] = 1
m[&quot;b&quot;] = 2
&lt;/pre&gt;

&lt;p&gt;在Go中定义方法也是比较奇葩的语法，用过的其他语言大部分把返回值写在前面，而它是写在后面，不过应该也没有谁优谁劣，而且在Go中方法可以返回多个值(尤其是在后面会用来返回错误)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func vals() (int, int) {// 普通函数：a, b := vals()
    return 1, 2;
}
func sum(nums ...int) {// 可变参数：sum(1, 2)   sum(1, 2, 3)
}
func zeroptr(iptr *int) {// 参数类型为指针
    *iptr = 0
}
func intSeq() func() int {// 闭包
    i := 0
    return func() int {
        i += 1
        return i
    }
}
&lt;/pre&gt;

&lt;p&gt;在Go中所有的面向对象就是&lt;strong&gt;struct&lt;/strong&gt;了，是不是感觉有点简单？或者有点low？另外在Go中定义了一个奇葩的&lt;strong&gt;interface&lt;/strong&gt;，感觉有点像是一个方法的集合：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
type method interface {
    output();
}

type person struct {
    name string
    age  int
}

func (p *person) output(){// 定义方法，再次吐槽：是不是跟Python很像
    fmt.Println(p.name, p.age);
}

func f(m method) { // 为不同对象定义相同的方法，用这个来实现泛型的话，额~~
	fmt.Println(m);
    m.output();
}

func f1(arg int) (int, error) {
    return -1, errors.New(&quot;i can't work！&quot;); // 返回错误
}

// 调用方法
fmt.Println(person{&quot;Bob&quot;, 20})
fmt.Println(person{name: &quot;Alice&quot;, age: 30})
&lt;/pre&gt;

&lt;p&gt;在Go中比较吸引人的应该就是&lt;strong&gt;goroutines&lt;/strong&gt;，面向并发的语言自然要最大程度的简化对应的代码才算合格。在Go中任意一个方法都可以使用&lt;strong&gt;go&lt;/strong&gt;这个关键字来当做一个协程进行处理：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;go func(“abc”)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;仅仅这样是不够的，在Go中又提供了&lt;strong&gt;channel&lt;/strong&gt;用来做消息传递，这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;消息传递&lt;/li&gt;
  &lt;li&gt;共享内存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两种方式在Go里面就凑齐了，另外&lt;strong&gt;select&lt;/strong&gt;也大大简化了IO时候的操作，代码减了多少并不重要，关键是代码与其含义更加地贴近：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
messages := make(chan string)
messages := make(chan string, 2)

messages &amp;lt;- &quot;buffered&quot; // 写入
msg := &amp;lt;-messages // 读取

select {
    case msg := &amp;lt;-messages:
        fmt.Println(&quot;received message&quot;, msg)
    default:// 这样就不会阻塞了
        fmt.Println(&quot;no message received&quot;)
}
&lt;/pre&gt;

&lt;p&gt;总是感觉select与switch很像，不仅仅是写法上面，另外连TimeOut的写法能很简单、粗暴地搞定：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
select {
    case res := &amp;lt;-c1:
        fmt.Println(res)
    case &amp;lt;-time.After(time.Second * 1):
        fmt.Println(&quot;timeout 1&quot;)
    }
&lt;/pre&gt;

&lt;p&gt;用这种方式能设置延迟，在需要重复的场景下可以用&lt;strong&gt;ticker := time.NewTicker(time.Millisecond * 500)&lt;/strong&gt;来解决。&lt;/p&gt;

&lt;p&gt;在Go语言中不支持传统的try-catch-finally这种异常机制，因为Go的设计者认为可能程序员经常会滥用，所以在大部分的情况都通过返回多个值、其中一个为&lt;strong&gt;ERROR&lt;/strong&gt;的办法来处理，只有在真正异常的情况下才使用Go的Exception机制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;defer&lt;/strong&gt;：为函数添加结束时执行的语句&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;panic&lt;/strong&gt;：非常严重的不可恢复的错误&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;recover&lt;/strong&gt;：从错误中恢复&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来看简单的例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
func f() (result int) {// 返回值为1，只有defer执行后才有效
    defer func() {
        result++
    }()
    return 0;
}
panic(&quot;problem&quot;);// 在这个地方程序就挂掉了

func a(){
    panic(&quot;a---error&quot;);
}
func b(){
    panic(&quot;b---error&quot;);
}
func(){
    def func(){
        if r:= recover(); r != nil {
            log.Printf(&quot;caught: %v&quot;, r);
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;用recover的方法有点像缩水版的try-catch，最后，在Go中居然支持&lt;strong&gt;goto&lt;/strong&gt;，虽然我觉得goto还是挺好用的。&lt;/p&gt;

&lt;p&gt;简单把Go的语法过了一遍，总体的感觉就是简单、面向工程开发，没有很多的废话，也没有太多学术上很有用、工程上用的不多的细节。基本语法的例子都可以在&lt;a href=&quot;https://gobyexample.com/&quot;&gt;这里&lt;/a&gt;找到。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;工程开发&lt;/h2&gt;

</description>
        <pubDate>Tue, 09 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/09/Golang-Start.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Spring</title>
        <description>&lt;p&gt;如今作为一个Java程序员，如果没用过Spring的话基本上没法混了~ 这里就不再啰嗦如何如何从EJB走到了Spring(毕竟咱也没经历过那些个艰难的时代)，直接来看它带给我们哪些东西：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;IoC&lt;/li&gt;
  &lt;li&gt;Aop&lt;/li&gt;
  &lt;li&gt;SpringMVC&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面分几个部分很粗地描述一下Spring~&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;控制反转&lt;/h2&gt;

&lt;p&gt;要看控制反转，那么我们先看看没有反转的时候是什么样子的，当自己的服务依赖于别人的实现时，在其使用之前选择合适的服务实现对其进行初始化：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    private XXService xxService;
    public MyService(){
        this.xxService = new XXServiceImpl();/* 利用合适的实现进行初始化 */
    }
    // ...
}
&lt;/pre&gt;

&lt;p&gt;程序可以正常运行，但是当你有几十个类中使用了XXService，而某一天发现XXServiceImpl是有BUG的，你想换个实现类，那就傻逼了~~&lt;/p&gt;

&lt;p&gt;用IoC最原始的配置方式就可以将这个问题引刃而解：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;bean id=&quot;myService&quot; class=&quot;com.test.MyService&quot;&amp;gt;
    &amp;lt;property name=&quot;xxService&quot; ref=&quot;xxService&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;xxService&quot; class=&quot;com.test.XXServiceImpl&quot;/&amp;gt;&amp;lt;!-- 改这里 --&amp;gt;
&lt;/pre&gt;

&lt;p&gt;在配置文件中搞定他们之间的依赖关系，在使用前，需要用&lt;strong&gt;BeanFactory&lt;/strong&gt;来构建其中的Bean，在需要时，调用&lt;strong&gt;getBean&lt;/strong&gt;取得实例，然后就可以继续后面的操作了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
BeanFactory factory = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
MyService myService = (MyService)factory.getBean(&quot;myService&quot;);
&lt;/pre&gt;

&lt;p&gt;可能“顽固派”会说：干嘛要怎么麻烦，把你要使用的类包装一下再交给MyService使用就可以了啊！确实可以解决问题，但是思路决定出路，这种解决方法确实解决了上面的问题，但是下面&lt;strong&gt;ApplicationContext&lt;/strong&gt;的登场，使得这种依赖管理变得异常简单：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class MyService {
    @Resource /* 利用注解完成注入 */
    private XXService xxService;
    // ...
}
@Component(&quot;xxService&quot;) /* 声明一个Bean */
public class XXServiceImpl{
    // ...
}
&lt;/pre&gt;

&lt;p&gt;一直感觉注解在Java中的作用就是将配置信息植入到代码文件里面，现在在依赖管理中注解再一次发挥了巨大的威力。到这里基本上满足大部分的需求了，但是Spring提供的功能可能远超过了你需要的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;BeanFactoryAware：获取BeanFactory实例&lt;/li&gt;
  &lt;li&gt;BeanPostProcessor：在afterPropertiesSet的方法前后执行&lt;/li&gt;
  &lt;li&gt;InitializingBean：完成一些初始化动作&lt;/li&gt;
  &lt;li&gt;BeanFactoryPostProcessor:处理Bean的定义，也就是BeanDefinition&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;还有很多其他的扩展点，下面重点看下Bean的生命周期：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Spring-Bean生命周期.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;另外IoC里面有很多的细节点，逐步整理中：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;byType/byName&lt;/td&gt;
      &lt;td&gt;根据类型/名字注入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;scope(singleton/prototype)&lt;/td&gt;
      &lt;td&gt;单例还是每次都生成一个新的Bean&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;factory-bean/FactoryBean&lt;/td&gt;
      &lt;td&gt;工厂类型的Bean，getBean时会调用其getObject方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Resource&lt;/td&gt;
      &lt;td&gt;默认byName，找不到的时候就byType(指定name就只能byName了)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;@Autowire&lt;/td&gt;
      &lt;td&gt;默认byType，可以配合@Qualifier变为byName&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lazy-init&lt;/td&gt;
      &lt;td&gt;只对singleton的Bean起作用，效果是在getBean的时候才初始化&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;section-1&quot;&gt;面向切面编程&lt;/h2&gt;

&lt;p&gt;面向切面编程(Aspect Oriented Programming)提供了另外一个角度来考虑程序结构，在介绍AOP的时候几乎都会介绍&lt;strong&gt;打日志&lt;/strong&gt;的需求，当然除此之外还有很多的场景，这里就不赘述。简单来说Spring的AOP提供了拦截一批方法的手段。&lt;/p&gt;

&lt;p&gt;其实我们自己也可以利用&lt;strong&gt;BeanFactoryPostProcessor&lt;/strong&gt;来实现类似的功能，但在Spring中AOP强大的地方是提供了很多种方便的配置方式。第一种是用XML的配置方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:aspect id=&quot;logaop&quot; ref=&quot;allLogAdvice&quot;&amp;gt;&amp;lt;!--处理类 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.test.MyService.*(..))&quot; /&amp;gt;&amp;lt;!-- 方法 --&amp;gt;
        &amp;lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&amp;gt;&amp;lt;!-- 方式及调用方法 --&amp;gt;
    &amp;lt;/aop:aspect&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;

&lt;p&gt;另外一种个人感觉比较好用的就是&lt;strong&gt;@Aspect&lt;/strong&gt;方式，这种方式把方法和它要拦截的方法放在一个地方，比较自然一点：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class MyAspect {
    @Pointcut(&quot;execution(* com.test.MyService.*(..))&quot;)
    private void aspectjMethod(){};

    @Before(&quot;service()&quot;)
    private void aroundMethod(){ /* code */ }
}
&lt;/pre&gt;

&lt;p&gt;在使用前需要配置&lt;strong&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/strong&gt;，第二种方式确实有一些进步，但是考虑注解之后，AOP的功能开始变得有点IMBA了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Aspect
public class LocalCacheAspect {
    @Pointcut(&quot;@annotation(localCache)&quot;)
    public void getLocalCacheAnnotation(LocalCache localCache) {}

    @Around(&quot;getLocalCacheAnnotation(localCache)&quot;)
    public Object handleCache(ProceedingJoinPoint joinPoint, LocalCache localCache) throws Throwable {
        /* code */
    }
}
&lt;/pre&gt;

&lt;p&gt;这样当你在Spring的某个方法上加注解&lt;strong&gt;@LocalCache&lt;/strong&gt;后，就可以被handleCache拦截了，在这里需要注意一下大小写。在具体实现的时候AOP利用了两种技术：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;JDK动态代理&lt;/li&gt;
  &lt;li&gt;CGLIB字节码生成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想选择cglib需要配置文件中加上&lt;strong&gt;&amp;lt;aop:aspectj-autoproxy proxy-target-class=”true”/&amp;gt;&lt;/strong&gt;。
AOP中涉及到的细节整理如下(不断更新中)：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;关键字&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Pointcut&lt;/td&gt;
      &lt;td&gt;通常使用正则表达式来描述切入的点(拦截哪些方法)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Advice&lt;/td&gt;
      &lt;td&gt;在特定的Pointcut执行的动作：around、before、throws等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Joinpoint&lt;/td&gt;
      &lt;td&gt;具体运行时拦截到的信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;mvc&quot;&gt;MVC&lt;/h2&gt;

&lt;p&gt;细想一下大部分的Java程序员应该都在直接或者间接的做页面开发，那么这里就涉及到分层的概念了，当然这里不会讲这些东西。在WEB应用作用，不能不提&lt;strong&gt;web.xml&lt;/strong&gt;,其中需要清楚&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;filter&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;listener&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;servlet&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;它们的作用以及运行机制，在通过SpringMVC来开发Web应用前，需要配置：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
        &amp;lt;load-on-startup&amp;gt;2&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;spring&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;*.htm&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/pre&gt;

&lt;p&gt;这样就把所有以&lt;strong&gt;.htm&lt;/strong&gt;结尾的请求都交给&lt;strong&gt;DispatcherServlet&lt;/strong&gt;进行具体的处理并返回，过程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常用的&lt;strong&gt;handleMapping&lt;/strong&gt;的方式有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;SimpleUrlHandlerMapping&lt;/li&gt;
  &lt;li&gt;DefaultAnnotationHandlerMapping&lt;/li&gt;
  &lt;li&gt;AnnotationMethodHandlerAdapter&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用注解的方式更直观一些，在代码中直接就可以明白你正在处理什么样的请求，最简单的一个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@Controller
@RequestMapping(&quot;/helloAnnoController.html&quot;)
public class AnyTypeYouLikeController{
    @RequestMapping(method={RequestMethod.GET,RequestMethod.POST})
    public String processWebRequest(){
        return &quot;anno/helloAnnController&quot;;
    }
}
&lt;/pre&gt;

&lt;p&gt;PS：现在各种WEB框架非常多，关键是了解它们运行机制，在遇到问题的时候可以DEBUG去找到解决办法，对某个框架有哪些“奇技淫巧”就不说了，细节太多了···&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;数据访问&lt;/h2&gt;

&lt;p&gt;首先想想要想是的访问数据更方便，Spring应该做什么事情？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;统一的异常处理&lt;/li&gt;
  &lt;li&gt;将相同（类似）操作进行封装&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果直接用JDBC来完成数据访问，大致如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    Connection connection = getDataSource().getConnection();
    Statement statement = connection.createStatement();
    // TODO 执行数据库操作
    statement.executeUpdate(&quot;sql...&quot;);
    statement.close();
}finally{
    statement.close();
    connection.close();
}
&lt;/pre&gt;

&lt;p&gt;显然在使用JDBC API处理数据的时候会有大量相似的代码，不仅增加了代码量，而且使得业务
逻辑不清晰、工程难维护。在Spring中用&lt;strong&gt;JdbcTemplate&lt;/strong&gt;通过模板方式来解决这些问题：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class JdbcTemplate {
    public Object execute(StatementCallback action) throws DataAccessException
    {
       // 将连接数据库等操作抽取出来
    }
}
&lt;/pre&gt;

&lt;p&gt;在JdbcTemplate中定义了很多queryXXX和updateXXX的方法，其本质上还是&lt;strong&gt;Callback&lt;/strong&gt;的方
式实现的，定义出来方便我们使用：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
JdbcTemplate jdbcTemplate = new JdbcTemplate();
jdbcTemplate.setDataSource(ds);
jdbcTemplate.execute(new StatementCallback(){
    public Object doInStatement(Statement stmt) throws SQLException {
        stmt.execute(&quot;your sql&quot;);
        return ret;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样编码起来方便了很多，但是接着会想如果我们把SQL写到单独的文件里面，这样剥离开应该
会更好一下吧，这样就有了各种ORM，比如&lt;strong&gt;iBatis&lt;/strong&gt;和&lt;strong&gt;Hibernate&lt;/strong&gt;，在iBatis中用SqlMapClient
来访问数据，通常访问的方式有三种：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
//1、基于SqlMapCLient的自动提交事务型简单数据访问
Map parameters = new HashMap();
parameters.put(&quot;param1&quot;, value);
// ..
Object ret = sqlMap.queryForObject(&quot;sql_id&quot;, parameters);
// 2、基于SqlMapClient的非自动提交事务型数据访问
try{
    sqlMap.startTransaction();
    sqlMap.update(&quot;....&quot;);
    sqlMap.commitTransaction();
} finally {
    sqlMap.endTransaction();
}
// 3、基于SqlMapSession的数据访问
SqlMapSession session = null;
try{
    session = sqlMap.openSession();
    session.startTransaction();
    session.update(&quot;...&quot;);
    session.commitTransaction();
} finally {
    session.endTransaction();
}
&lt;/pre&gt;

&lt;p&gt;因为Spring在集成iBatis的时候要考虑将事务控制也纳入进来，所以使用基于SqlMapSession
的数据访问方式对iBatis进行集成，这种方式更灵活，可以将iBatis内部直接指定的数据源和事
务管理器等转由外部提供（IoC），&lt;strong&gt;SqlMapClientTemplate&lt;/strong&gt;是Spring为iBatis的数据访问操
作提供的模板方法类：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class SqlMapClientTemplate {
    public Object execute(SqlMapClientCallback action) throws DataAccessException {
        // ...
    }
}
&lt;/pre&gt;

&lt;p&gt;SqlMapClientCallback可以完成任何基于iBatis的数据访问操作，比如要向一个数据库批量提
交更新数据：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
protected void batchInsert(final List beans) {
    sqlMapClientTemplate.execute(new SqlMapClientCallback() {
        public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
            executor.startBatch();
            Interator iter = beans.iterator();
            while(iter.hasNext()) {
                Bean bean = (Bean) iter.next();
                executor.insert(&quot;insert_name&quot;, bean);
            }
            executor.executeBatch();
            return null;
        }
    });
}
&lt;/pre&gt;

&lt;p&gt;最后来看事务处理，局部事务的话用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
try{
    transaction = session.beginTransaction();
    // TODO 操作数据
    session.flush();
    transaction.commit();
} catch (Exception e){
    transaction.rollback(); // 回滚
} finally {
    session.close();
}
&lt;/pre&gt;

&lt;p&gt;因为JDBC的局部事务控制是由同一个Connection来完成的，所以要保证两个DAO的数据访问
方式处于一个事务中，我们就得保证他们使用的是同一个Connection，要做到这一点，通常采
用称为connection-passing的方式，即为同一个事务中的各个DAO的数据访问传递当前事务对
应的同一个Connection。&lt;/p&gt;

&lt;p&gt;我们可以直接使用PlatformTransactionManager，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
DefaultTransactionDefinition definition = new DefaultTransactionDefinition();
definition.setXXX();
definition.setXXX();
TransactionStatus status = transactionManager.getTransaction(definition);
try {
    // TODO 业务逻辑
} catch (Exception e) {
    transactionManager.roolback(status);
}
transactionManager.commit(status);
&lt;/pre&gt;

&lt;p&gt;可以看到上面有很多重复的操作，接着用TransactionTemplate对事务的管理进行模板化。而
基于申明式的事务有四种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ProxyFactory + TransactionInterceptor&lt;/li&gt;
  &lt;li&gt;TransactionProxyFactoryBean&lt;/li&gt;
  &lt;li&gt;BeanNameAutoProxyCreator&lt;/li&gt;
  &lt;li&gt;Spring 2.x申明事务配置方式&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然也可以通过注解&lt;strong&gt;@Transactional&lt;/strong&gt;来申明事务。&lt;/p&gt;
</description>
        <pubDate>Mon, 08 Jun 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/06/08/Spring.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Guava</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;写在前面&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用法&lt;/h2&gt;

&lt;h2 id=&quot;section-2&quot;&gt;学习&lt;/h2&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

</description>
        <pubDate>Sat, 30 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/30/Guava.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java枚举</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;
&lt;p&gt;在JDK 1.5之前通常用final来定义各种常量，现在新加了枚举类型，最简单的用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED,
    GREEN
}
&lt;/pre&gt;

&lt;p&gt;还可以像普通的类那样自己定义属性和方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color {
    RED(&quot;red&quot;),
    GREEN(&quot;green&quot;);
    String name;

    Color(String name) {
        this.name = name;
    }

    public String toString(){
        return name;
    }
}
&lt;/pre&gt;

&lt;p&gt;甚至enum还可以去实现接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
enum Color implements Comparable&amp;lt;Color&amp;gt; {
    RED,
    GREEN;
}
&lt;/pre&gt;

&lt;p&gt;在使用的时候，枚举可以用来比较：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
if(c == Color.GREEN){
    // ...
}
&lt;/pre&gt;

&lt;p&gt;也可以用来switch：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Color c = Color.RED;
switch (c) {
    case RED:
    case GREEN:
}
&lt;/pre&gt;

&lt;p&gt;而且你可以很方便的变量一个枚举类型中所有的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
for (Color c : Color.values()) {
    System.out.println(c);
}
&lt;/pre&gt;

&lt;p&gt;甚至在你只知道枚举的变量名的时候也能拿到对应的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
System.out.println(Color.valueOf(&quot;RED&quot;));
&lt;/pre&gt;

&lt;p&gt;看下来，枚举在定义常量上面做了不少友好的封装。&lt;/p&gt;

&lt;h2 id=&quot;vs&quot;&gt;枚举VS常量&lt;/h2&gt;

&lt;p&gt;首先不同的枚举类是不同的类型，而你用final static修饰的一般都是int等基本类型，这样很难做类型检查，这算是Enum比较大的一个优势的优势，在写代码的时候不会传错参数：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void check(Color c){

}
&lt;/pre&gt;

&lt;p&gt;当你传入其他类型参数时会编译出错。&lt;/p&gt;

&lt;h2 id=&quot;enum&quot;&gt;enum到底是什么&lt;/h2&gt;

&lt;p&gt;在编译之后会有一个Color.class文件，使用javap查看：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
final class Color extends java.lang.Enum implements java.lang.Comparable{
    public static final Color RED;
    public static final Color GREEN;
    public static Color[] values();
    public static Color valueOf(java.lang.String);
    static {};
}
&lt;/pre&gt;

&lt;p&gt;该类继承自&lt;strong&gt;java.lang.Enum&lt;/strong&gt;，然后通过&lt;strong&gt;javap -c Color&lt;/strong&gt;来看初始化的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static {};
  Code:
   0:   new     #4; //class Color
   3:   dup
   4:   ldc     #7; //String RED
   6:   iconst_0
   7:   invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   10:  putstatic       #9; //Field RED:LColor;
   13:  new     #4; //class Color
   16:  dup
   17:  ldc     #10; //String GREEN
   19:  iconst_1
   20:  invokespecial   #8; //Method &quot;&amp;lt;init&amp;gt;&quot;:(Ljava/lang/String;I)V
   23:  putstatic       #11; //Field GREEN:LColor;
   26:  iconst_2
   27:  anewarray       #4; //class Color
   30:  dup
   31:  iconst_0
   32:  getstatic       #9; //Field RED:LColor;
   35:  aastore
   36:  dup
   37:  iconst_1
   38:  getstatic       #11; //Field GREEN:LColor;
   41:  aastore
   42:  putstatic       #1; //Field $VALUES:[LColor;
   45:  return
&lt;/pre&gt;

&lt;p&gt;这里大家可能会对枚举switch有疑问，我们写代码来看下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void func(Color c){
        switch(c){
            case RED:
            case GREEN:
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;然后用javap -c查看，得到：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void func(Color);
  Code:
   0:   getstatic       #2; //Field Test$1.$SwitchMap$Color:[I
   3:   aload_1
   4:   invokevirtual   #3; //Method Color.ordinal:()I
   7:   iaload
   8:   lookupswitch{ //2
                1: 36;
                2: 36;
                default: 36 }
   36:  return
}
&lt;/pre&gt;

&lt;p&gt;可以看到这里switch的其实还是enum类中的ordinal（int），和之前我们对switch的认识是一致的。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 May 2015 04:34:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/15/Java-Enum.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的ThreadLocal</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;用法&lt;/h2&gt;

&lt;p&gt;多个线程在调用同一个方法的时候，会有并发问题，解决这种问题最简单的办法就是将数据保存在Thread的自己的结构中，也就是ThreadLocal的作用了。用法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class JavaBean {
    static ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = new ThreadLocal&amp;lt;Integer&amp;gt;();

    public void prepare() {
        threadLocal.set(0);
    }

    public void work() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            int val = threadLocal.get();
            val++;
            threadLocal.set(val);
        }
        System.out.println(threadLocal.get());
    }
}

class Worker extends Thread {
    JavaBean bean;

    public Worker(JavaBean bean) {
        this.bean = bean;
    }

    public void run() {
        bean.prepare();
        bean.work();
    }
}

public class ThreadLocalDemo {
    public static void main(String[] args) {
        JavaBean bean = new JavaBean();
        for (int i = 0; i &amp;lt; 100; i++) {
            new Worker(bean).start();
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;从输出中可以看到，多个线程操作同一个threadLocal时，结果并不会出错。&lt;/p&gt;

&lt;p&gt;可以将ThreadLocal看做是对&lt;strong&gt;Thread.threadLocals&lt;/strong&gt;的封装，况且在程序中也是不能直接访问到Thread.threadLocals。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;下面简单看ThreadLocal的原理，在Thread中保存了一个Map，类型可以认为是&lt;strong&gt;Map&amp;lt;ThreadLocal, T&amp;gt;&lt;/strong&gt;，其中T是要保存数据的类型。当要从中取出数据时，调用的流程如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Thread.currentThread().threadLocals.getEntry(threadLocal).value
&lt;/pre&gt;

&lt;p&gt;这样，不同的线程在执行的时候在同一个threadLocal上获取到的是不同的数据，线程之间的隔离性是通过”各自保存不同的Map”来实现的，而看到的threadLocal对象其实是&lt;strong&gt;KEY&lt;/strong&gt;，在操作前get到的是&lt;strong&gt;VALUE&lt;/strong&gt;。其实自己动手做一个线程安全的数据保存的解决方法也是这个思路。&lt;/p&gt;

&lt;p&gt;在ThreadLocalMap中使用的并不是普通的引用保存数据，而是使用&lt;strong&gt;WeakReference&lt;/strong&gt;来做：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;gt; {
    Object value;
    Entry(ThreadLocal k, Object v) {
        super(k);
        value = v;
    }
}
&lt;/pre&gt;

&lt;p&gt;这样如果ThreadLocal被释放了，那么ThreadLocalMap中的Entry也会被释放，不至于造成内存泄露。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java对象占用了多少空间？</title>
        <description>&lt;p&gt;在Java中没有sizeof运算符，所以没办法知道一个对象到底占用了多大的空间，但是在分配对象的时候会有一些基本的规则，我们根据这些规则大致能判断出来对象大小。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;对象头&lt;/h2&gt;

&lt;p&gt;对象的头部至少有两个WORD，如果是数组的话，那么三个WORD，内容如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;对象的HashCode，锁信息等&lt;/li&gt;
  &lt;li&gt;到对象类型数据的指针&lt;/li&gt;
  &lt;li&gt;数组的长度（如果是数组的话）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-1&quot;&gt;规则&lt;/h2&gt;

&lt;p&gt;首先，任何对象都是8字节对齐，属性按照[long,double]、[int,float]、[char,short]、[byte,boolean]、reference的顺序存放，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    byte a;
    int b;
    boolean c;
    long d;
    Object e;
}
&lt;/pre&gt;

&lt;p&gt;如果这个对象的属性按照顺序存放的话，要占用的空间为：head(8) + a(1) + padding(3) + b(4) + c(1) + padding(7) + d(8) + e(4) + padding(4) = 40。但是按照这个规则得到：head(8) + d(8) + b(4) + a(1) + c(1) + padding(2) + e(4) + padding(4) = 32。可以看到节省了不少空间。&lt;/p&gt;

&lt;p&gt;在涉及继承关系的时候有一个最基本的规则：首先存放父类中的成员，接着才是子类中的成员，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    long a;
    int b;
    int c;
}
class B extends A {
    long d;
}
&lt;/pre&gt;

&lt;p&gt;这样存放的顺序及占用空间如下：head(8) + a(8) + b(4) + c(4) + d(8) = 32。那如果父类中的属性不够八个字节怎么办？这样就有了新的一条规则：父类中最后一个成员与子类的第一个成员的间隔如果不够4个字节，此时需要扩展到4个字节的基本单位，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    byte b;
}
&lt;/pre&gt;

&lt;p&gt;那么此时占用的空间如下：head(8) + a(1) + padding(3) + b(1) + padding(3) = 16。显然这种方式比较浪费空间，那么就有了：如果子类的第一个成员是double或者long，并且父类并没有用完8个字节，JVM会破坏规将较小的数据填充到该空间，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class A {
    byte a;
}
class B extends A {
    long b;
    short c;
    byte d;
}
&lt;/pre&gt;

&lt;p&gt;此时占用的空间如下：head(8) + a(1) + padding(3) + c(2) + d(1) + padding(1) + b(8) = 24。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Sizeof.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Java中的泛型</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;什么是泛型&lt;/h2&gt;

&lt;p&gt;泛型是JDK 1.5中引入的特性，允许在定义类、接口、方法的时候使用类型参数，声明的类型参数在使用时用具体的类型替换。从好的方面来看，泛型的引入可以在编译时刻就发现很多明显的错误。从不好的方面，为了保证与旧有版本的兼容性，Java泛型的实现上存在一些不优雅的地方。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;使用方法&lt;/h2&gt;

&lt;p&gt;最常见的使用场景是泛型类或者接口：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
interface TestInterface&amp;lt;T&amp;gt; {
}
class TestClass&amp;lt;T&amp;gt; {
    T data;
}
&lt;/pre&gt;

&lt;p&gt;看以看到泛型的好处能节省我们的代码量，当&lt;strong&gt;data&lt;/strong&gt;的类型变化的时候，我们不需要去写不同的接口或者类。当然有时候你需要指定多个类型，那么可以：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&amp;lt;K, V, OTHER&amp;gt; {
    K     key;
    V     value;
    OTHER other;
}
&lt;/pre&gt;

&lt;p&gt;有时候我们希望只支持Number类型，那么可以：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
class TestClass&amp;lt;T extends Number&amp;gt; {
    T data;
}
&lt;/pre&gt;

&lt;p&gt;当然，泛型也可以用在方法上，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public &amp;lt;T&amp;gt; T doSth(T a){
    return a;
}
&lt;/pre&gt;

&lt;p&gt;你可能会比较好奇如果同时在方法和类上面使用泛型的话会出现什么情况：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&amp;lt;T&amp;gt; {
    T data;
    @SuppressWarnings(&quot;hiding&quot;)
    public &amp;lt;T&amp;gt; T doSth(T a) {
        return a;
    }

    public static void main(String[] args) {
        Test&amp;lt;String&amp;gt; t = new Test&amp;lt;String&amp;gt;();
        System.out.println(t.doSth(123));
        t.data = &quot;123&quot;;
    }
}
&lt;/pre&gt;

&lt;p&gt;结论是方法上的用方法的，其他的用类上的，如果方法上没有，方法用类上的。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;多想一点&lt;/h2&gt;

&lt;p&gt;现在想一下泛型具体是如何实现的，用&lt;strong&gt;javap Test&lt;/strong&gt;看doSth的方法声明如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Object doSth(java.lang.Object);
&lt;/pre&gt;

&lt;p&gt;如果是受限的泛型，比如：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test&amp;lt;T extends Number&amp;gt; {
    public T doSth(T a) {
        return a;
    }
}
&lt;/pre&gt;

&lt;p&gt;那么得到的结果则是：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public java.lang.Number doSth(java.lang.Number);
&lt;/pre&gt;

&lt;p&gt;如果限制类型有两个（比如&amp;lt;T extends Comparable &amp;amp; Serializable&amp;gt;）则生成的字节码中选用第一个（Comparable）。Java中的泛型是伪泛型，在运行期间，所有的泛型信息都会被擦除。也就是说在生成的Java字节码中没有包含泛型中的类型信息。那么在重载的时候会有什么影响，举个例子：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public void doSth(List&amp;lt;Integer&amp;gt; list) { }
    public void doSth(List&amp;lt;String&amp;gt; list) { }
}
&lt;/pre&gt;

&lt;p&gt;现在应该会猜到：&lt;strong&gt;因为类型擦除，这个类是不能被编译通过的。&lt;/strong&gt;那么下面这段代码呢？&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public Integer doSth(List&amp;lt;Integer&amp;gt; list) { return null; }
    public String doSth(List&amp;lt;String&amp;gt; list) { return null; }
}
&lt;/pre&gt;

&lt;p&gt;编译通过了。这貌似与我们之前对重载的认识不相同：函数之间的区分是依据参数和方法名，返回值并不参与。上面这段代码中常在不是根据返回值来判断的，但是增加不同类型的返回值是的这两个方法能够共存在同一个Class文件中：
&amp;gt; 重载要求方法有不同的方法签名，而返回值并不在方法签名中。但是在Class文件格式中，只要描述符不是完全一致的方法就可以共存，也就是说：返回值也能影响方法能不能共存在同一个Class中。
可以通过javap -s Test看到方法签名。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;获取泛型的类型&lt;/h2&gt;

&lt;p&gt;首先来看通过&lt;strong&gt;ParameterizedType&lt;/strong&gt;获取类型的方法，如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Test {
    public List&amp;lt;String&amp;gt; list;

    public static void main(String[] args) throws Exception {
        ParameterizedType pt = (ParameterizedType) Test.class.getField(&quot;list&quot;).getGenericType();
        System.out.println(pt.getActualTypeArguments()[0]);
    }
}
&lt;/pre&gt;

&lt;p&gt;其中getGenericType方法返回一个Type对象，如果是一个参数化类型，那么返回的Type会反映源码中使用的实际参数类型，实际的参数类型通过getActualTypeArguments获取。&lt;/p&gt;
</description>
        <pubDate>Thu, 14 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-Generics.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>Linux内存管理</title>
        <description>&lt;p&gt;现在的服务器大部分都是运行在Linux上面的，所以，作为一个程序员有必要简单地了解一下系统是如何运行的。对于内存部分需要知道：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;地址映射&lt;/li&gt;
  &lt;li&gt;内存管理的方式&lt;/li&gt;
  &lt;li&gt;缺页异常&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先来看一些基本的知识，在进程看来，内存分为内核态和用户态两部分，经典比例如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-虚拟地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从用户态到内核态一般通过系统调用、中断来实现。用户态的内存被划分为不同的区域用于不同的目的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-用户区分段.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然内核态也不会无差别地使用，所以，其划分如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-内核地址空间划分.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面来仔细看这些内存是如何管理的。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;地址&lt;/h2&gt;

&lt;p&gt;在Linux内部的地址的映射过程为&lt;strong&gt;逻辑地址&lt;/strong&gt;–&amp;gt;&lt;strong&gt;线性地址&lt;/strong&gt;–&amp;gt;&lt;strong&gt;物理地址&lt;/strong&gt;，物理地址最简单：地址总线中传输的数字信号，而线性地址和逻辑地址所表示的则是一种转换规则，线性地址规则如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-线性地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这部分由MMU完成，其中涉及到主要的寄存器有CR0、CR3。机器指令中出现的是逻辑地址，逻辑地址规则如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-逻辑地址.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Linux中的逻辑地址等于线性地址，也就是说Inter为了兼容把事情搞得很复杂，Linux简化顺便偷个懒。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;内存管理的方式&lt;/h2&gt;

&lt;p&gt;在系统boot的时候会去探测内存的大小和情况，在建立复杂的结构之前，需要用一个简单的方式来管理这些内存，这就是&lt;strong&gt;bootmem&lt;/strong&gt;，简单来说就是位图，不过其中也有一些优化的思路。&lt;/p&gt;

&lt;p&gt;bootmem再怎么优化，效率都不高，在要分配内存的时候毕竟是要去遍历，&lt;strong&gt;buddy&lt;/strong&gt;系统刚好能解决这个问题：在内部保存一些2的幂次大小的空闲内存片段，如果要分配3page，去4page的列表里面取一个，分配3个之后将剩下的1个放回去，内存释放的过程刚好是一个逆过程。用一个图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-伙伴系统.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到0、4、5、6、7都是正在使用的，那么，1、2被释放的时候，他们会合并吗？&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
static inline unsigned long
__find_buddy_index(unsigned long page_idx, unsigned int order)
{
    return page_idx ^ (1 &amp;lt;&amp;lt; order);// 更新最高位，0～1互换
}
&lt;/pre&gt;

&lt;p&gt;从上面这段代码中可以看到，0、1是buddy，2、3是buddy，虽然1、2相邻，但他们不是。内存碎片是系统运行的大敌，伙伴系统机制可以在一定程度上防止碎片~~另外，我们可以通过cat /proc/buddyinfo获取到各order中的空闲的页面数。&lt;/p&gt;

&lt;p&gt;伙伴系统每次分配内存都是以页（4KB）为单位的，但系统运行的时候使用的绝大部分的数据结构都是很小的，为一个小对象分配4KB显然是不划算了。Linux中使用&lt;strong&gt;slab&lt;/strong&gt;来解决小对象的分配：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-SLAB.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在运行时，slab向buddy“批发”一些内存，加工切块以后“散卖”出去。随着大规模多处理器系统和NUMA系统的广泛应用，slab终于暴露出不足：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;复杂的队列管理&lt;/li&gt;
  &lt;li&gt;管理数据和队列存储开销较大&lt;/li&gt;
  &lt;li&gt;长时间运行partial队列可能会非常长&lt;/li&gt;
  &lt;li&gt;对NUMA支持非常复杂&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了解决这些高手们开发了&lt;strong&gt;slub&lt;/strong&gt;：改造page结构来削减slab管理结构的开销、每个CPU都有一个本地活动的slab(kmem_cache_cpu)等。对于小型的嵌入式系统存在一个slab模拟层&lt;strong&gt;slob&lt;/strong&gt;，在这种系统中它更有优势。&lt;/p&gt;

&lt;p&gt;小内存的问题算是解决了，但还有一个大内存的问题：用伙伴系统分配10 x 4KB的数据时，会去16 x 4KB的空闲列表里面去找（这样得到的物理内存是连续的），但很有可能系统里面有内存，但是伙伴系统分配不出来，因为他们被分割成小的片段。那么，&lt;strong&gt;vmalloc&lt;/strong&gt;就是要用这些碎片来拼凑出一个大内存，相当于收集一些“边角料”，组装成一个成品后“出售”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-非连续内存.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前的内存都是直接映射的，第一次感觉到页式管理的存在:D 另外对于高端内存，提供了&lt;strong&gt;kmap&lt;/strong&gt;方法为page分配一个线性地址。&lt;/p&gt;

&lt;p&gt;进程由不同长度的段组成：代码段、动态库的代码、全局变量和动态产生数据的堆、栈等，在Linux中为每个进程管理了一套&lt;strong&gt;虚拟地址空间&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-进程虚拟内存.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在我们写代码malloc完以后，并没有马上占用那么大的物理内存，而仅仅是维护上面的虚拟地址空间而已，只有在真正需要的时候才分配物理内存，这就是&lt;strong&gt;COW&lt;/strong&gt;（COPY-ON-WRITE:写时复制）技术，而物理分配的过程就是最复杂的缺页异常处理环节了，下面来看!&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;缺页异常&lt;/h2&gt;

&lt;p&gt;在实际需要某个虚拟内存区域的数据之前，和物理内存之间的映射关系不会建立。如果进程访问的虚拟地址空间部分尚未与页帧关联，处理器自动引发一个缺页异常。在内核处理缺页异常时可以拿到的信息如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cr2：访问到线性地址&lt;/li&gt;
  &lt;li&gt;err_code：异常发生时由控制单元压入栈中，表示发生异常的原因&lt;/li&gt;
  &lt;li&gt;regs：发生异常时寄存器的值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;处理的流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Linux内存-缺页异常.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;发生缺页异常的时候，可能因为不常使用而被swap到磁盘上了，swap相关的命令如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;swapon&lt;/td&gt;
      &lt;td&gt;开启swap&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;swapoff&lt;/td&gt;
      &lt;td&gt;关闭swap&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;/proc/sys/vm/swappiness&lt;/td&gt;
      &lt;td&gt;分值越大越积极使用swap，可以修改/etc/sysctl.conf中添加vm.swappiness=xx来修改&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果内存是mmap映射到内存中的，那么在读、写对应内存的时候也会产生缺页异常。&lt;/p&gt;
</description>
        <pubDate>Wed, 13 May 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/13/Linux-Memory.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
  </channel>
</rss>
