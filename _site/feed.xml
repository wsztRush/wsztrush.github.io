<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 15 Sep 2015 23:56:16 +0800</pubDate>
    <lastBuildDate>Tue, 15 Sep 2015 23:56:16 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Grunt</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://www.gruntjs.net/img/grunt-logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;WHY&lt;/h2&gt;

&lt;p&gt;在用Java写完源码之后需要编译成Class才能执行，其实前端也是类似的，需要压缩等操作才是真正的成品，况且现在前端的工具越来越多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;LESS&lt;/li&gt;
  &lt;li&gt;CoffeeScript&lt;/li&gt;
  &lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些都需要预处理成最终的CSS、JS才能被使用，而GRUNT则将这些过程管理起来，你只需要开开心心写代码就好了~&lt;/p&gt;

&lt;h2 id=&quot;how&quot;&gt;HOW&lt;/h2&gt;

&lt;p&gt;当然首先需要node.js，然后&lt;strong&gt;npm install -g grunt-cli&lt;/strong&gt;安装命令行工具，在工程下面配置两个文件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;package.json&lt;/strong&gt;：被npm用于存储项目元数据，以便将此项目发布为npm模块，可以在这里列出项目依赖的Grunt和Grunt插件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Gruntfile.js&lt;/strong&gt;：用来配置或定义任务并加载Grunt插件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;执行&lt;strong&gt;npm install&lt;/strong&gt;安装项目依赖的库，然后执行&lt;strong&gt;grunt&lt;/strong&gt;即可，package.json配置文件如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
{
    &quot;name&quot;: &quot;my-project-name&quot;,
    &quot;version&quot;: &quot;0.1.0&quot;,
    &quot;devDependencies&quot;: {
        &quot;grunt&quot;: &quot;~0.4.5&quot;,
        &quot;grunt-contrib-jshint&quot;: &quot;~0.10.0&quot;,
        &quot;grunt-contrib-nodeunit&quot;: &quot;~0.4.1&quot;,
        &quot;grunt-contrib-uglify&quot;: &quot;~0.5.0&quot;
    }
}
&lt;/pre&gt;

&lt;p&gt;可以通过命令&lt;strong&gt;npm install &amp;lt;module&amp;gt; –save-dev&lt;/strong&gt;安装插件的同时向文件中的devDependencies字段添加，&lt;a href=&quot;http://www.gruntjs.net/plugins&quot;&gt;这里&lt;/a&gt;有插件列表。&lt;/p&gt;

&lt;p&gt;文件Gruntfile.js由三部分组成：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;配置任务：grunt.initConfig&lt;/li&gt;
  &lt;li&gt;加载插件：grunt.loadNpmTasks&lt;/li&gt;
  &lt;li&gt;定义任务：grunt.registerTask&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;基本上配置好之后就可以跑起来了，更多看&lt;a href=&quot;http://www.gruntjs.ne&quot;&gt;官网&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 15 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E5%B7%A5%E5%85%B7/2015/09/15/Grunt.html</link>
        <guid isPermaLink="true">/%E5%B7%A5%E5%85%B7/2015/09/15/Grunt.html</guid>
        
        
        <category>工具</category>
        
      </item>
    
      <item>
        <title>CSS基础和LESS入门</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s2921314.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看《CSS权威指南》的时候简单的整理了一些&lt;a href=&quot;http://naotu.baidu.com/file/ed1f91b9f4ba914a4d97e404acd71ee3?token=33581ba44ab41688&quot;&gt;笔记&lt;/a&gt;，有些东西比之前有了更深的理解，但是用这么厚的一本书来学CSS多少有些头大，只需要把一些关键的东西理解透彻，具体的设置查&lt;a href=&quot;http://www.w3chtml.com/css3/&quot;&gt;手册&lt;/a&gt;更快！&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;布局和定位&lt;/h2&gt;

&lt;p&gt;原生的HTML中元素分为两种：&lt;strong&gt;块级元素&lt;/strong&gt;和&lt;strong&gt;行内元素&lt;/strong&gt;，而CSS中用display来影响元素的展示：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;none&lt;/td&gt;
      &lt;td&gt;隐藏对象并且不会保留物理空间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline&lt;/td&gt;
      &lt;td&gt;行内元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;block&lt;/td&gt;
      &lt;td&gt;块级元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline-block&lt;/td&gt;
      &lt;td&gt;行内块元素，也就是说横着排列的同时可以指定宽高&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;box&lt;/td&gt;
      &lt;td&gt;弹性盒子模型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;inline-box&lt;/td&gt;
      &lt;td&gt;行内弹性盒子，和inline-block有点类似&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;直接使用top、right等是不会起作用的，想要起作用得用position来配合：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;值&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;static&lt;/td&gt;
      &lt;td&gt;不使用定位&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;relative&lt;/td&gt;
      &lt;td&gt;相对于父节点的位置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;absolute&lt;/td&gt;
      &lt;td&gt;绝对定位，会跟滚动条滚动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fixed&lt;/td&gt;
      &lt;td&gt;固定定位，不会跟随滚动&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当用relative有问题的时候可能是你的HTML结构错了导致父节点判断错误导致的:)用display+position可以把一个元素放到你想要的位置，但是一个块也不是简单的长方形，也有其结构：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;margin&lt;/td&gt;
      &lt;td&gt;外补白&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;padding&lt;/td&gt;
      &lt;td&gt;内补白&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;border&lt;/td&gt;
      &lt;td&gt;边框&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;外补白比较特殊一点：取的双方的是max而不是sum，在chrome控制台玩一下就能很好地理解这三个的用法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Css-Less.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;直观上背景图片是用来做背景的，但是感觉现在都被大家玩坏了，比如经常把很多的图标放到一个图片上然后用&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
.x {
    background-image:url(img-url);
    background-position:-100px 100px;
}
&lt;/pre&gt;

&lt;p&gt;就可以在对应的DIV中展示出局部图片，这个局部就可能是某个ICON，感觉这完全是在当图片使用额~&lt;/p&gt;

&lt;h2 id=&quot;less&quot;&gt;LESS&lt;/h2&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;
</description>
        <pubDate>Fri, 11 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/11/Css-Less.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/11/Css-Less.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>JavaScript基础知识</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img3.douban.com/mpic/s8958650.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最近被逼着学习JavaScript，这篇也算是记得一些笔记，如果你对其他的语法（Java等）比较熟悉，那么看完这篇文章并实践一下，也差不多算入门了:)&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;基本语法&lt;/h2&gt;

&lt;p&gt;JavaScript中包括六种基本类型：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;undefined/null&lt;/td&gt;
      &lt;td&gt;区别看&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html&quot;&gt;这里&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;boolean&lt;/td&gt;
      &lt;td&gt;需要注意从其他类型转换到Boolean的规则&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;number&lt;/td&gt;
      &lt;td&gt;整数、浮点数、NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td&gt;字符串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;数据、对象的集合，是所有对象的基础&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;接着来体会一下弱类型的方便之处：&lt;strong&gt;“123” == 123&lt;/strong&gt;的结果居然是true，而&lt;strong&gt;“123” === 123&lt;/strong&gt;才是预期中的false，此时会比较类型。常用的引用类型有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Array&lt;/li&gt;
  &lt;li&gt;Date&lt;/li&gt;
  &lt;li&gt;RegExp&lt;/li&gt;
  &lt;li&gt;Function&lt;/li&gt;
  &lt;li&gt;Boolean&lt;/li&gt;
  &lt;li&gt;Number&lt;/li&gt;
  &lt;li&gt;String&lt;/li&gt;
  &lt;li&gt;Global：全局对象(不属于任何其他对象的属性和方法都是它的)&lt;/li&gt;
  &lt;li&gt;Math&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;结构控制语句中比较特别是加了&lt;strong&gt;with&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
with(location){
    var a = search.substring(1); // var a = location.search.substring(1)
    var b = hostname;// var b = location.hostname
}
&lt;/pre&gt;

&lt;p&gt;可以看做是一个作用域操作符！另一个能控制作用域的就只有函数了，没有块作用域也算比较奇葩~ 函数的定义非常灵活：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;既不需要定义返回值，也不需要定义入参！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实它是把参数放到数组&lt;strong&gt;arguments&lt;/strong&gt;里面了，处理方式和Python有点像。函数可以作为参数传来传去很容易让人头晕，再加上匿名函数和闭包就更烦了：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;闭包是指有权访问另一个函数作用域中变量的函数，也就是在一个函数内部创建的函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;来看看段代码理解一下闭包：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function createFunctions(){
    var result = new Array();
    for(var i = 0; i &amp;lt; 10; i++){
        result[i] = function(){
            return i;
        };
    }
}
&lt;/pre&gt;

&lt;p&gt;返回的方法数组每个的返回结果都是相同的，是不是和预期的不一样？要达到预期的效果需要：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function createFunctions(){
    var result = new Array();
    for(var i = 0; i &amp;lt; 10; i++){
        result[i] = function(num){
            return num;
        }(i);
    }
}
&lt;/pre&gt;

&lt;p&gt;更复杂度是：&lt;strong&gt;this&lt;/strong&gt;的原始含义为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当方法被某个对象调用时，this就等于那个对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;记住&lt;/strong&gt;：要时刻小心是是谁在调用方法，再来看一段代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var name = &quot;the window&quot;;
vra obj = {
    var name = &quot;my object&quot;;
    getNameFunc : function(){
        return function(){
            return this.name;
        }
    }
}
alert(obj.getNameFunc()());// the window
&lt;/pre&gt;

&lt;p&gt;是不是隐隐感觉到了&lt;strong&gt;闭包+this&lt;/strong&gt;组合的强大威力？虽然很多程序猿没有对象，但面向对象编程是一个永恒的话题：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;对象是无序属性的集合，其属性可以包含基本值、对象或者函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;有一些属性只给引擎内部使用，在我们自己写的JavaScript中是无法访问的，常用的有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;configurable&lt;/li&gt;
  &lt;li&gt;enumerable：能否通过for-in循环，默认为true&lt;/li&gt;
  &lt;li&gt;writable：能否修改属性的值&lt;/li&gt;
  &lt;li&gt;value：值&lt;/li&gt;
  &lt;li&gt;get：在读取属性时调用的函数&lt;/li&gt;
  &lt;li&gt;set：在设置属性时调用的函数&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;创建对象除了用&lt;strong&gt;new Object&lt;/strong&gt;之外还可以用构造函数&lt;strong&gt;new Person&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function Person(name, age, job){
    this.name = name;
    this.job = job;
    this.age = age;
}
var person = new Person();
&lt;/pre&gt;

&lt;p&gt;其背后处理的逻辑如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建一个新对象&lt;/li&gt;
  &lt;li&gt;将构造函数函数的作用域赋给新对象（因此this指向了新对象）&lt;/li&gt;
  &lt;li&gt;执行构造函数中的代码&lt;/li&gt;
  &lt;li&gt;返回新对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;创建自定义的构造函数意味着将它的实例标志为一种特定的类型，这也是其优势所在：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
alert(person instanceof Person); // true
&lt;/pre&gt;

&lt;p&gt;而最大的劣势在于：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;每个方法都要在每个实例上创建一遍。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;上面是将方法当成属性来使用，其实还有一种将方法当成方法来用的方法:)&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function Person(){
}
Person.prototype = {
    name : &quot;a&quot;;
    sayName : function(){
        alert(this.name);
    }
}
&lt;/pre&gt;

&lt;p&gt;在方法的&lt;strong&gt;prototype&lt;/strong&gt;中指定的属性（原型），对其所有的实例可用，这样方法的用法就和Java一致，而属性就像是类的静态属性，而且可以方便地用来模仿继承：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function SubType(){
    this.sayHello = function(){
        alert(&quot;hello&quot;);
    }
}
function SuperType(){
}
SubType.prototype = SuperType;
new SubType().sayHello();// hello
&lt;/pre&gt;

&lt;p&gt;总的来说继承更像是提供了一个默认的parent指针，在查找属性、方法的时候可以递归向上查找，但是用不好的时候会出现一些莫名其妙的问题：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function Super(){
    this.key = [1, 2, 3];
}
function A(){}
function B(){}

A.prototype = new Super();

var a1 = new A();
a1.key.push(4);
alert(a1.key);// [1, 2, 3, 4]

var a2 = new A();
alert(a2.key);// [1, 2, 3, 4]

// 用一个公共的方法来包装对象，这样就可以直接在对象上&quot;继承&quot;了
function object(o){
    function F(){}
    F.prototype = o;
    return new F();
}
&lt;/pre&gt;

&lt;p&gt;在ECMAScript 5中新增了方法&lt;strong&gt;Object.create()&lt;/strong&gt;规范了原型继承（类似object方法）。把SuperType中的属性共享给SubType的每个实例可能不能满足需求，那么可以试试下面这种方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
function SuperType(){
    this.colors = [1, 2, 3];
}
function SubType(){
    SuperType.call(this); // apply也可以
}
var instance1 = new SubType();
instance1.colors.push(4);
alert(instance1.colors);// [1,2,3,4]

var instance2 = new SubType();
alert(instance2.colors);// [1,2,3]
&lt;/pre&gt;

&lt;p&gt;在SubType通过&lt;strong&gt;call/apply&lt;/strong&gt;来执行SuperType方法，相当于是在当前的实例中产生了SuperType的备份，个人觉得把这种也算作继承有点牵强。最后，错误处理（try-catch-finally）和Java里面几乎一样，常见的错误类型有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;类型转换错误&lt;/li&gt;
  &lt;li&gt;数据类型错误&lt;/li&gt;
  &lt;li&gt;通信错误&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在写代码的时候要注意不要因为这些问题把程序搞挂了~&lt;/p&gt;

&lt;h2 id=&quot;dombom&quot;&gt;DOM与BOM&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;BOM&lt;/strong&gt;(浏览器对象模型)中提供了对象用来访问浏览器的功能：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;对象&lt;/th&gt;
      &lt;th&gt;功能&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;window&lt;/td&gt;
      &lt;td&gt;提供浏览器大小、位置以及很多基础方法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;localtion&lt;/td&gt;
      &lt;td&gt;加载文档的信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;navigator&lt;/td&gt;
      &lt;td&gt;用来识别浏览器、检测插件、注册处理程序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;screen&lt;/td&gt;
      &lt;td&gt;显示器像素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;history&lt;/td&gt;
      &lt;td&gt;浏览器历史&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;浏览器就是JavaScript的运行环境，不同的浏览器实现的不同到时运行会有意想不到的结果，在做兼容性时需要写逻辑代码来测试浏览器对需要的功能是否支持！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM&lt;/strong&gt;(文档对象模型)是针对HTML和XML文档的一个API，将它们描绘成一个由多层节点构成的结构，节点的类型包括：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Node&lt;/td&gt;
      &lt;td&gt;基类，统一维护了节点的层次结构&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Document&lt;/td&gt;
      &lt;td&gt;文档，提供读、写元素的操作，在JavaScript操作文档时经常用到&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Element&lt;/td&gt;
      &lt;td&gt;元素&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Text&lt;/td&gt;
      &lt;td&gt;文本&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Comment&lt;/td&gt;
      &lt;td&gt;注释&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CDATASection&lt;/td&gt;
      &lt;td&gt;XML中的CDATA(这个就不用多说了)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DocumentType&lt;/td&gt;
      &lt;td&gt;文档类型，能够影响到浏览器渲染时的行为(一个热乎的坑)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Attr&lt;/td&gt;
      &lt;td&gt;元素的特性&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;写JavaScript比较爽的就是随时运行随时生效，具体操作DOM的API还是很简单的，打开&lt;strong&gt;console&lt;/strong&gt;尝试一下吧:)&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事件&lt;/h2&gt;

&lt;p&gt;JavaScript与HTML之间的交互是通过事件来实现的，而事件则是文档或者浏览器窗口中发生的一些特定的&lt;strong&gt;交互瞬间&lt;/strong&gt;。事件流的方式有两种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;事件冒泡&lt;/strong&gt;：由最具体的元素接收，然后逐级上传&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;事件捕获&lt;/strong&gt;：上层节点更早接收到事件，而最具体的节点最后收到&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种监听事件的方式为直接绑定属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var btn = document.getElementById(&quot;myBtn&quot;);
btn.onclick = function(){
    alert(&quot;Clicked&quot;);
}
&lt;/pre&gt;

&lt;p&gt;另一种方法为增加监听器，用这种方法可以为同一个时间添加多个监听器（虽然没啥用）&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var btn = document.getElementById(&quot;myBtn&quot;);
btn.addEventListener(&quot;click&quot;, function(){
    alert(this.id);
}, false);
&lt;/pre&gt;

&lt;p&gt;不同浏览器的API有所不同，可以统一封装掉提供一个EventUtil来操作事件监听，在事件对象（event）中包含了相关的信息，细节就不讲了，常见的事件类型有下面几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;UI事件&lt;/li&gt;
  &lt;li&gt;焦点事件&lt;/li&gt;
  &lt;li&gt;鼠标与滚轮事件&lt;/li&gt;
  &lt;li&gt;键盘与文本事件&lt;/li&gt;
  &lt;li&gt;复合事件&lt;/li&gt;
  &lt;li&gt;变动事件&lt;/li&gt;
  &lt;li&gt;HTML5事件&lt;/li&gt;
  &lt;li&gt;设备事件&lt;/li&gt;
  &lt;li&gt;触摸与手势事件&lt;/li&gt;
  &lt;li&gt;拖放事件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;事件也是要消耗内存的，使用需谨慎！&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;通信&lt;/h2&gt;

&lt;p&gt;既然是浏览器脚本语言，和服务器通信自然是少不了的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(){ // 监听状态发生变化
    if(xhr.readyState == 4){// 完成
        if((xhr.status &amp;gt;= 200 &amp;amp;&amp;amp; xhr.status &amp;lt; 300) || xhr.status == 304){
            alert(xhr.responseText);
        } else{
            alert(xhr.status);
        }
    }
}
xhr.open(&quot;get&quot;, &quot;xxx.xxx.com&quot;, true);
xhr.send(null);
&lt;/pre&gt;

&lt;p&gt;现代Web应用中频繁使用的一项功能就是表单数据序列化，XMLHttpRequest2级为此定义了&lt;strong&gt;FormData&lt;/strong&gt;类型。使用Ajax进行跨域是比较常见的需求，之前都是利用一些浏览器允许跨域的请求来做：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;图像Ping&lt;/li&gt;
  &lt;li&gt;JSONP&lt;/li&gt;
  &lt;li&gt;Comet&lt;/li&gt;
  &lt;li&gt;服务器发送事件（SSE）&lt;/li&gt;
  &lt;li&gt;Web Scokets&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;既然大家这么需要跨域，而且浏览器禁止不住，那干脆就提供一套好用的协议出来，于是有了CORS（跨域资源共享）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;发请求时将请求页面的源信息设置到Origin中，服务器根据Origin来判断是否允许访问，如果运行返回的头中设置Access-Control-Allow-Origin:*。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果没有这个头部或者不匹配，浏览器就会驳回请求。多种浏览器在实现时都会做些限制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cookie不会随请求发送，也不会随响应返回&lt;/li&gt;
  &lt;li&gt;不能访问响应的头部信息&lt;/li&gt;
  &lt;li&gt;限制对头部信息的设置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;和上面的方案相比都是跨域，但是区别还是挺大的。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;操作JSON、XML等数据，这里就记了，都是API~&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;前端需要学的东西太多了，虽然这两天花把JavaScript的基础过了一遍，但是要想在实际中真正的用起来，还是有很多规范、工具要去学的，加油！！！&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/09/JavaScript-Basic.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/09/JavaScript-Basic.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>解决运行Groovy脚本中的问题</title>
        <description>&lt;p&gt;在需要灵活配置时Groovy通常时一个不错的选择，但是问题比较多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;效率&lt;/li&gt;
  &lt;li&gt;垃圾回收&lt;/li&gt;
  &lt;li&gt;死循环&lt;/li&gt;
  &lt;li&gt;调用System.exit()等不安全的方法&lt;/li&gt;
  &lt;li&gt;拼命申请内存导致OOM：现在没有想到方案&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一、二中已经有比较成熟的方案，但是后面的两个问题就不那么好解决了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;死循环&lt;/h2&gt;

&lt;p&gt;执行Groovy脚本的时候我用的是下面的方法：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Class clazz = new GroovyClassLoader().parseClass(&quot;your code&quot;);
Method method = clazz.getMethod(&quot;xxxx&quot;);
method.invoke(null);
&lt;/pre&gt;

&lt;p&gt;如果用户编写的脚本是（能用技术解决的东西最好不要用价值观来保证）：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
while(true){
	// do nothing.
}
&lt;/pre&gt;

&lt;p&gt;机器的CPU马上会飚的很高，可能你会想到用&lt;strong&gt;Thread.stop()&lt;/strong&gt;来终止这个罪恶的脚本，但是对于这个脚本：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
while(true){
	try{/* your code */}
    catch(Exception e){ }
}
&lt;/pre&gt;

&lt;p&gt;只能说根本停不下来。因为：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thread.stop()仅仅是在线程的任意位置抛出ThreadDeath异常。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;况且Thread.stop很早就不建议使用了，而是用&lt;strong&gt;Thread.interrupt()&lt;/strong&gt;，但是简单来说中断仅仅是去通知一下目标线程，而不是真的去停掉它。&lt;/p&gt;

&lt;p&gt;那么，现在的目标就是如何将中断检查的代码插入到用户编写的脚本中：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static void checkInterrupted() {
    if (Thread.currentThread().isInterrupted()) {
        throw new RuntimeException(&quot;task is interrupted!&quot;);
    }
}
&lt;/pre&gt;

&lt;p&gt;将输入的脚本作为字符串来处理，估计会累到吐血！接着自然想到先将源码结构化，那么自然想到在编译的过程中对语法树进行操作即可达到目的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public static class SafeGroovyClassLoader extends GroovyClassLoader {
    protected CompilationUnit createCompilationUnit(CompilerConfiguration config, CodeSource source) {
    CompilationUnit compilationUnit = super.createCompilationUnit(config, source);
    compilationUnit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() {
        public void call(SourceUnit source) throws CompilationFailedException {
            ModuleNode ast = source.getAST();
            // 自定义visitor来操作
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;遍历时我们需要处理的节点包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;FOR&lt;/li&gt;
  &lt;li&gt;WHILE&lt;/li&gt;
  &lt;li&gt;DOWHILE&lt;/li&gt;
  &lt;li&gt;CATCH&lt;/li&gt;
  &lt;li&gt;FINALLY&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在这些块的开始位置插入&lt;strong&gt;checkInterrupted&lt;/strong&gt;方法的调用：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
private BlockStatement createCheckBlock(Statement statement) {
    if (statement instanceof BlockStatement) {
        BlockStatement blockStatement = (BlockStatement) statement;
        blockStatement.getStatements().add(0, checkInterruptedStatement);
        return blockStatement;
    } else if (statement instanceof EmptyStatement) {
        BlockStatement blockStatement = new BlockStatement();
        blockStatement.getStatements().add(checkInterruptedStatement);
        return blockStatement;
    } else {
        BlockStatement blockStatement = new BlockStatement();
        blockStatement.getStatements().add(checkInterruptedStatement);
        blockStatement.getStatements().add(statement);
        return blockStatement;
    }
}

public void visitCatchStatement(CatchStatement catchStatement) {
    catchStatement.getCode().visit(this);
    catchStatement.setCode(createCheckBlock(catchStatement.getCode()));
}
&lt;/pre&gt;

&lt;p&gt;你想的话可以在checkInterrupted中加入循环次数统计。现在线程可以中断，貌似问题已经解决了，但是谁来中断他？有三种方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用线程池来运行脚本，在外面用Future.get来等待（超时中断）&lt;/li&gt;
  &lt;li&gt;创建一个线程来join当前线程（超时中断）&lt;/li&gt;
  &lt;li&gt;执行任务前将当前线程插入到map中，然后用一个定时任务来扫描并将超时的中断&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一、二种方案每个请求都会创建多余一个线程（不划算），那就来看看第三种方案的实现方式：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 保存线程开始时间
Map&amp;lt;Thread, Long&amp;gt; threadCache = Maps.newHashMap();
// 执行前将线程插入
threadCache.put(Thread.currentThread(), System.currentTimeMillis());
// 遍历threadCache根据时间判断是否中断
&lt;/pre&gt;

&lt;p&gt;这种方案实现起来要好好考虑一下同步的问题！&lt;/p&gt;

&lt;h2 id=&quot;systemexit&quot;&gt;System.exit&lt;/h2&gt;

&lt;p&gt;在不做限制的情况下，执行上面方法系统直接就停止了，怎么办？办法很简单（当然不是靠价值观）：建立黑名单，在遍历语法树时是否调用了黑名单中的方法。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;应用这么多，可能大家都需要用到一些脚本的功能，但是能也没有比较把这些都再各个系统里面去实现一把（没啥意义），如果有这么一个打通脚本与应用、数据的平台也不错！&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/08/Groovy.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/08/Groovy.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>编程语言实现模式</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://img4.douban.com/mpic/s7661036.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;很久之前已经把这本书看过一遍了，但是一直没有实践过!于是，拿出来再复习一遍，顺便记录笔记。关于这本书有几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;ANTLR贯穿全书：作者是&lt;strong&gt;Terence Parr&lt;/strong&gt;，这点也就不奇怪了&lt;/li&gt;
  &lt;li&gt;ANTLR生成的代码是LL(K)的&lt;/li&gt;
  &lt;li&gt;偏重实践，原理很少，想看原理要去看&lt;a href=&quot;http://img3.douban.com/mpic/s3392161.jpg&quot;&gt;龙书&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外，你应该先知道编译的过程大概分成哪几步骤以及为什么这样划分！废话少说，来看这本书的内容。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;解析输入&lt;/h2&gt;

&lt;p&gt;词法分析和语法分析很多地方都是相同的，解析器结构如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class G extends Parser {
    // 类型定义
    // 合适的构造函数
    // 规则对应的方法
}
&lt;/pre&gt;

&lt;p&gt;在一个规则中包含很多子规则时，根据向前看符号来决定使用哪个，这个逻辑的代码描述可以用if-else来做：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
if(向前看到alt1){
    // 匹配alt1
} else if(向前看到alt2){
    // 匹配alt1
}....
&lt;/pre&gt;

&lt;p&gt;当然这里也可以用switch做，在规则上定义的一些常见操作有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;(T)?：T可有可无&lt;/li&gt;
  &lt;li&gt;(T)+：多个T&lt;/li&gt;
  &lt;li&gt;(T)*：零个或多个T&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些操作的代码描述：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// (T)?
if(向前看到T){ match(T);}
// (T)+
do{
    match(T);
} while(向前看到T)
// (T)*
while(向前看到T){
    match(T);
}
&lt;/pre&gt;

&lt;p&gt;能利用好这三个操作大部分的规则都可以搞定了！词法分析相对语法分析了来说简单很多，Lexer会提供&lt;strong&gt;nextToken()&lt;/strong&gt;来供Parser使用来不断地获取TOKEN：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public Token nextToken(){
    while(lookahead-char != EOF) {
        switch(lookahead-char){
            case 空白字符: { consume(); continue; }
            case 字符后面可能是T1: return T1();
            case 字符后面可能是T2: return T2();
			// ...
            default:
                出错;
        }
    }
    return EOF;
}
&lt;/pre&gt;

&lt;p&gt;直观上来看用switch进行预测，相当于构造了一个状态机吧，其中&lt;strong&gt;consume()&lt;/strong&gt;方法自增下标并将下一个字符当做向前看字符（消费字符）。在仅使用一个向前看符来进行语法分析时，也就是LL(1)，对于下面语法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;list : ‘[’ elements ‘]’;&lt;/li&gt;
    &lt;li&gt;elements : element (‘,’ element);&lt;/li&gt;
    &lt;li&gt;element : NAME | list;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;生成的Paser如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class ListParser extends Parser {
    public void list(){
        match(ListLexer.LBRACK); // 匹配并消耗词法单元
        elements();
        match(ListLexer.RBRACK);
    }
    public void elements(){
        element();
        while(lookahead.type == ListLexer.COMMA) {
            match(ListLexer.COMMA);
            element();
        }
    }
    public void element(){
        if(lookahead.type == ListLexer.NAME) match(ListLexer.NAME);
        else if(lookahead.type == ListLexer.LBRACK) list();
        else throw new Error(&quot;语法错误&quot;);
    }
}
&lt;/pre&gt;

&lt;p&gt;很简单的语法用LL(1)是没有问题的，对于稍微复杂一点的其预测能力差就暴露出来了，怎么办？当然是多拿几个进行预测！可以构造环形缓冲区来存放用来预测的TOKEN，另外增加两个方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;LA&lt;/strong&gt;：返回第k个向前看词法单元的类型&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;LT&lt;/strong&gt;：返回第k个词法单元&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那么文法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;element : NAME ‘=’ NAME : NAME : list ;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对应的程序描述就变为：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void element(){
    if(LA(1) == LookaheadLexer.NAME &amp;amp;&amp;amp; LA(2) == LookaheadLexer.EQUALS) {
        match(LookaheadLexer.NAME);
        match(LookaheadLexer.EQUALS);
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.NAME) {
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.LBACK) {
        list();
    } else {
        throw new Error(&quot;语法错误!&quot;);
    }
}
&lt;/pre&gt;

&lt;p&gt;但是LL(K)也不是万能的，如果向前看k个解决不了问题，那么向前无限个总应该可以搞定了吧？回溯解析中使用递归尝试不同的规则，在发现无法匹配时把消费掉的TOKEN吐出来：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void rule() {
    if(speculate_alt1()){
        // 匹配alt1
    } else if(speculate_alt2()){
        // 匹配alt2
    } else { throw new Error(&quot;语法错误！&quot;); }
}
public boolean speculate_alt1() {
    boolean success = true;
    mark();// 标记当前位置，供release使用
    try{
        // 匹配alt1
    } catch(Exception e){ success = false; }
    release();// 将消费掉的TOKEN重新放回去
    return success;
}
&lt;/pre&gt;

&lt;p&gt;回溯解析最大的缺陷就是性能低，而其中一个原因则是做了不少重复工作，对于语法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;s : expr ‘:’ | expr ‘;’;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在尝试第一个子规则失败时会去尝试第二个，那么expr就会被匹配两次！如果能把之前匹配过的结果记住就好了（参考&lt;a href=&quot;http://www.cnblogs.com/kedebug/archive/2013/04/07/3006493.html&quot;&gt;记忆化搜索&lt;/a&gt;），此时仅需要做一些很小的修改：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 每个规则有一个Map来保存结果
Map&amp;lt;Integer, Integer&amp;gt; list_memo = new HashMap&amp;lt;Integer, Integer&amp;gt;;
public void list(){
    boolean failed = false;
    int startTokenIndex = index();
    if(isSpeculating() &amp;amp;&amp;amp; aleadyParsedRule(list_memo)) return;
	try{_list();}
    catch(Exception e) {failed = true; throw e; }
    finally{
         if(isSpeculating())
             memoize(list_memo, startTokenIndex, failed);
    }
}
public void _list(){
    match(XXX);
    elements();
    match(XXX);
}
&lt;/pre&gt;

&lt;p&gt;简单说明下上面用到的几个方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;aleadyParsedRule&lt;/strong&gt;：使用缓存的结果：成功返回TRUE、失败抛异常、未处理过返回FALSE&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;memoize&lt;/strong&gt;：回溯时将结果记录到缓存&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外需要清楚一个细节：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;推演时没有通过的try-catch逻辑在非推演时更不可能走到！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最后，在遇到上下文相关的语法时使用谓词是个不错的选择，用代码描述就是增加条件：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void rule(){
    if(向前看符号测试alt1 &amp;amp;&amp;amp; 谓词1) {
        // 匹配alt1
    } else if(向前看符号测试alt2 &amp;amp;&amp;amp; 谓词2) {
        // 匹配alt2
    } ...
}
while(对循环的alt进行向前看符号判断 &amp;amp;&amp;amp; 谓词判断) {
    子规则的代码用来匹配alt
}
&lt;/pre&gt;

&lt;p&gt;到这里解析输入的逻辑基本上就看完了，简单来说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Lexer产出Token流&lt;/li&gt;
  &lt;li&gt;Parser产出方法执行流&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;接下来我们就需要在Parser产出的方法执行流上面来进行分析。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;分析输入&lt;/h2&gt;

&lt;p&gt;将源码结构化时一般用到两种方式：&lt;strong&gt;语法分析树&lt;/strong&gt;和&lt;strong&gt;抽象语法树&lt;/strong&gt;，从三个方面来看：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;紧凑：不含无用节点&lt;/li&gt;
  &lt;li&gt;易用：很容易遍历&lt;/li&gt;
  &lt;li&gt;显意：突出操作符、操作对象，以及它们互相间的关系，不再拘泥于文法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;抽象语法树都要更优秀一些！程序实现时，我们在Parser匹配的过程中向方法中插入一些代码即可得到想要的树形结构：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public void rule(){
    RuleNode r = new RuleNode(&quot;规则名&quot;);
    if(root == null) root = r;
    else currentNode.addChild(r);
    ParseTree _save = currentNode;
    // 原始的规则代码
    currentNode = _save;
}
&lt;/pre&gt;

&lt;p&gt;要比想象的简单很多，因为在LL的解析中：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;解析过程就可以看做是在语法分析树上做DFS，任意当前树节点的父亲必然是前面遍历过的某个节点！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同实现节点的方式后续树的遍历等都是有影响的，有如下方式：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;同型AST&lt;/td&gt;
      &lt;td&gt;只有一种节点类型AST，要依据TOKEN来区分不同类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;规范异型AST&lt;/td&gt;
      &lt;td&gt;从基类AST派生不同的节点类型，子节点列表统一&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;不规范异型AST&lt;/td&gt;
      &lt;td&gt;可以添加不同的子节点属性，能够让代码的可读性更高&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;好不容易拿到树形结构了，遍历它也不是一个轻松的活。回想大学用Java写二叉树遍历的时候通常是这样：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class Node {
    Node left, right;
    void visit(){
        left.visit();
        right.visit();
    }
}
&lt;/pre&gt;

&lt;p&gt;把遍历操作嵌入节点内部最明显的缺点是：&lt;strong&gt;逻辑散落在各节点中操作起来很麻烦&lt;/strong&gt;，可以将遍历操作统一放到一个地方：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public abstract class VecMathNode extends HeteroAST {
    public abstract void visit(VecMathVisitor visitor);
}
public interface VecMathVisitor {
    void visit(AssignNode n);
    void visit(PrintNode n);
    void visit(StatListNode n);
    void visit(VarNode n);
    // ...
}
&lt;/pre&gt;

&lt;p&gt;在实现的时候在Visitor中将&lt;strong&gt;this&lt;/strong&gt;传递就可以达到遍历的目的了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class PrintVisitor implements VecMathVisitor {
    public void visit(AssignNode n){
        n.id.visit(this);// 看这里
        System.out.print(&quot;=&quot;);
        n.value.visit(this);
    }
}
&lt;/pre&gt;

&lt;p&gt;提到外面代码量并没有减少，但是这种代码很有规律，ANTLR可以大幅度地减少你的工作量！当然还有其他的方式来实现相同的目的，这里就不啰嗦了。&lt;/p&gt;

&lt;p&gt;遍历语法树的过程中要和两个东西打交道：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;操作&lt;/li&gt;
  &lt;li&gt;符号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;操作很简单，把子节点收集起来进行计算、处理就行了，但是符号就没那么随意，关键就是&lt;strong&gt;作用域&lt;/strong&gt;：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 1
int x;
void f(){ // 2
    int y;
    { int i; } // 3
    { int j; } // 4
}
void g(){ // 5
    int i;
}
&lt;/pre&gt;

&lt;p&gt;嵌套的作用域更加容易理解，嵌套关系可以用树形结构来表示（这种作用域的特点是只有一个父节点），上面这段代码生成的作用域如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-1.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在遍历树的时候用一个栈来保存能访问到的作用域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-2.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这个过程中用到的操作有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;push&lt;/td&gt;
      &lt;td&gt;向栈中压入作用域&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pop&lt;/td&gt;
      &lt;td&gt;作用域结束后，要将当前的作用域弹出栈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;def&lt;/td&gt;
      &lt;td&gt;在当前作用域中定义符号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;resolve&lt;/td&gt;
      &lt;td&gt;解析符号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;面向过程的变成语言很简单，这些已经够了，但是在面向对象编程的时候就不行了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// 1 全局
class A {// 2
public :
    int x;
    void foo()// 3
    { ; } // 4
}
class B : public A {// 5
    int y;
    void foo()// 6
    {// 7
        int z =  x + y;
    }
}
&lt;/pre&gt;

&lt;p&gt;由于继承关系的存在，在查找符号的时候不仅是要在当前类中找，而且要去父类中找，也就是说此时的父节点就不止一个了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xiz10.com1.z0.glb.clouddn.com/Language-Implementation-Patterns-3.PNG&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于像&lt;strong&gt;a.x = 3&lt;/strong&gt;这种访问对象属性的行为就不能按照上面套路来了，需要增加一个操作：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;操作&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;resolveMemeber&lt;/td&gt;
      &lt;td&gt;解析成员，只会根据superClass递归查找&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;到这里还没完，Java中的Class的定义可以在使用之前，那么在上面的处理属性引用时发现还没定义！直观的解决方法：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;预先遍历一次来定义类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里要小心处理好符号和作用域的关系。&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Sep 2015 00:00:00 +0800</pubDate>
        <link>/dsl/2015/09/06/Language-Implementation-Patterns.html</link>
        <guid isPermaLink="true">/dsl/2015/09/06/Language-Implementation-Patterns.html</guid>
        
        
        <category>dsl</category>
        
      </item>
    
      <item>
        <title>JavaScript模块化及SEA.JS的使用</title>
        <description>&lt;p&gt;最近因为缺前端，不得已要自学一下，囧~ 偶然在看到阮一峰很久之前关于模块化的文章：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/javascript_module.html&quot;&gt;模块的写法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html&quot;&gt;AMD规范&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/11/require_js.html&quot;&gt;require.js的用法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看完之后用来下玉伯的sea.js，感觉比较给力。&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;WHY&lt;/h2&gt;

&lt;p&gt;工程中前端开发的代码量早已与后端代码量差不了太多，如果将所有代码放到单个文件中是个头疼的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;全局变量互相影响&lt;/li&gt;
  &lt;li&gt;JS文件变大影响加载速度&lt;/li&gt;
  &lt;li&gt;结构混乱&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是比较悲剧：在JavaScript中并没有提供类、模块等封装的方法，那么就需要我们想办法利用现有的东西来做模块化。2009年Ryan Dahl创建了&lt;strong&gt;node.js&lt;/strong&gt;项目，将javascript用于服务器端编程，这标志”Javascript模块化编程”正式诞生。&lt;/p&gt;

&lt;h2 id=&quot;how&quot;&gt;HOW&lt;/h2&gt;

&lt;p&gt;为了避免上面的缺点以及为了不暴露私有成员，通常用&lt;a href=&quot;http://blog.csdn.net/qq838419230/article/details/8030078&quot;&gt;立即执行函数&lt;/a&gt;来搞定模块化的定义模块：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var module1 = (function(){
    var _count = 0;
    var m1 = function(){
        //...
    };
    var m2 = function(){
        //...
    };
    return {
        m1 : m1, m2 : m2
    };
})();
&lt;/pre&gt;

&lt;p&gt;大家定义出来的模块可能五花八门，如果都用统一的形式来定义那就可以很方便的引用了。目前常用规范有两种：&lt;strong&gt;CommonJS&lt;/strong&gt;和&lt;strong&gt;AMD&lt;/strong&gt;，node.js的模块系统就是参照CommonJS来实现的：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
var math = require('math');// 全局的require方法用来加载模块
math.add(2,3);
&lt;/pre&gt;

&lt;p&gt;其中math.add(2,3)要等到require完成之后才能执行，也就是说这是一个&lt;strong&gt;同步&lt;/strong&gt;的过程，在网络不好的环境中浏览器就会进入假死状态，体验极差，为了解决这个问题我们来看&lt;strong&gt;异步&lt;/strong&gt;的AMD规范(require.js)：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
require(['math'], function (math) {// require([module], callback);
    math.add(2, 3);
});
&lt;/pre&gt;

&lt;p&gt;参数module是要加载模块的列表，callback则是加载成功之后回调函数。AMD规范中模块的写法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
// math.js
define(function (){
    var add = function (x,y){
        return x+y;
    };
    return { add: add };
});
&lt;/pre&gt;

&lt;p&gt;另外可以用require.js来加载非规范AMD模块、文本、图片等，感觉略强大。&lt;/p&gt;

&lt;h2 id=&quot;seajs&quot;&gt;SEA.JS&lt;/h2&gt;

&lt;p&gt;CMD是sea.js使用的规范(所以这个术语貌似只有国人知道)，模块定义如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
define(function(require, exports, module) {
    var a = require('./a');
    a.doSomething();
    var b = require('./b');
    b.doSomething();
});
&lt;/pre&gt;

&lt;p&gt;是不是和AMD很像？通过&lt;strong&gt;require&lt;/strong&gt;在需要的时候引入依赖，通过&lt;strong&gt;exports&lt;/strong&gt;来暴露接口。AMD和CMD的区别可以看&lt;a href=&quot;http://www.zhihu.com/question/20351507/answer/14859415&quot;&gt;这里&lt;/a&gt;，还有&lt;a href=&quot;http://blog.chinaunix.net/uid-26672038-id-4112229.html&quot;&gt;这里&lt;/a&gt;。sea.js中常用的API有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/262&quot;&gt;seajs.config&lt;/a&gt;：配制&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/260&quot;&gt;seajs.use&lt;/a&gt;：在页面上加载模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;define&lt;/a&gt;：定义模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/259&quot;&gt;require&lt;/a&gt;：获取指定模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;require.async&lt;/a&gt;：在模块内部异步加载一个或多个模块&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;exports&lt;/a&gt;：在模块内部对外提供接口&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/242&quot;&gt;module.exports&lt;/a&gt;：在模块内部对外提供接口&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些API已经定义的足够简单，因此，例子就忽略了（你可以看&lt;a href=&quot;http://&quot;&gt;这里&lt;/a&gt;）。。。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;简单看下来，感觉很受用！不过…模块化的趋势貌似是&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/intro&quot;&gt;ECMAScript 6&lt;/a&gt;，ES6的目标是让JavaScript可以用来编写大型、复杂的应用程序，成为企业级开发语言！&lt;/p&gt;

&lt;p&gt;不过…&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;浏览器的支持程度&lt;/a&gt;比较堪忧。。。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/05/JavaScript-Sea.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/05/JavaScript-Sea.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>junit</title>
        <description>&lt;p&gt;打算定期看一个开源代码，听之前同事的建议于是从junit开始：&lt;/p&gt;

&lt;p&gt;TestRunner加载和运行测试，入口类。
TestDecorator对Test进行包装。
TestSetup对Test进行包装，增加初始化、清理接口。&lt;/p&gt;

&lt;p&gt;TestListener监听器，在发生对应的动作的时候进行调用：&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
public interface TestListener {
    public void addError(Test test, Throwable t);
    public void addFailure(Test test, AssertionFailedError t);
    public void endTest(Test test);
    public void startTest(Test test);
}
&lt;/pre&gt;

&lt;p&gt;TestSuite是TestCase的组合：
ActiveTestSuite创建一个新的线程来执行：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestSuite {
    private Vector&lt;test&gt; fTests = new Vector&lt;test&gt;(10);
}



TestResult
&lt;pre class=&quot;prettyprint&quot;&gt;
public class TestResult{
    protected List&lt;testfailure&gt; fFailures;
    protected List&lt;testfailure&gt; fErrors;
    protected List&lt;testlistener&gt; fListeners;
}



TestCase
&lt;pre class=&quot;prettyprint&quot;&gt;
public void runBare() throws Throwable {
    setUp(); // 初始化
    try {
        runTest(); // 通过反射调用方法
    } finally {
        tearDown(); // 清理
    }
}
&lt;/pre&gt;
&lt;/testlistener&gt;&lt;/testfailure&gt;&lt;/testfailure&gt;&lt;/pre&gt;&lt;/test&gt;&lt;/test&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 02 Sep 2015 00:00:00 +0800</pubDate>
        <link>/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/02/Junit.html</link>
        <guid isPermaLink="true">/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/09/02/Junit.html</guid>
        
        
        <category>编程技术</category>
        
      </item>
    
      <item>
        <title>页面配置</title>
        <description>&lt;p&gt;用MVC框架来开发WEB页面已经是非常成熟的一个事情，那为什么还需要用配置的方式来做页面？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;不需要应用发布、重启即可生效&lt;/li&gt;
  &lt;li&gt;可以跨应用重复使用模块&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在做的比较完善的情况下，产品跟你说一个需求，可能等他回到座位上的时候你已经做好了。当然并不是所有的页面都可以用配置来做，不然配置的方式会巨复杂无比：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;页面布局足够简单&lt;/li&gt;
  &lt;li&gt;组件足够通用，能够重复利用&lt;/li&gt;
  &lt;li&gt;数量足够多&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;报表是一个非常典型的场景，大家可能对&lt;a href=&quot;http://www.umeng.com/apps/4100008dd65107258db11ef4/reports/realtime_summary&quot;&gt;报表&lt;/a&gt;这样的页面见到不是特别多，其实在运营后台、仓库管理系统页面非常非常非常多，如果配置能做够灵活，那么这部分的工作量就都可以省下来了。&lt;/p&gt;

&lt;p&gt;那么，要实现一个页面配置需要解决哪些问题？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;布局&lt;/li&gt;
  &lt;li&gt;组件重复使用&lt;/li&gt;
  &lt;li&gt;交互&lt;/li&gt;
  &lt;li&gt;预览&lt;/li&gt;
  &lt;li&gt;业务应用接入&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面依次来看：&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;布局&lt;/h2&gt;

&lt;p&gt;经典的布局解决方案是栅格系统（bootstrap），其中的角色包括：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;container&lt;/li&gt;
  &lt;li&gt;row&lt;/li&gt;
  &lt;li&gt;cloumn&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比较牛逼的是可以嵌套，用到的技巧可以看&lt;a href=&quot;http://segmentfault.com/a/1190000000743553&quot;&gt;这里&lt;/a&gt;，这样我们用这种方式实现比较复杂的表头的时候还是比较容易的! 让开发去写一大堆的class、div来做页面现在比较头大，那么现在的办法是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;用简洁的语法把页面需要展示的东西表达清楚，然后将其翻译成HTML+JS。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;自己YY的一个语法如下：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@layout
    @layout
        @CompA // 条件
        @CompB // 条件
    @CompC // 查询
    @CompD // 导出
@CompE // 列表展示
@CompF // 分页
&lt;/pre&gt;

&lt;p&gt;通过缩进来控制层次（或者归属）关系，通过@layout来统一控制一组组件的排列展示。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;组件的重复利用&lt;/h2&gt;

&lt;p&gt;能够复用的组件可以是：展示+数据，在重复利用时只需要将其引入那么基本上什么都不用管了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@import:easydt/warehouse_list // 引入仓库列表组件
&lt;/pre&gt;

&lt;p&gt;引入之后展示就没有问题了，只需要考虑该组件如何与页面上其他的组件互动。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;交互&lt;/h2&gt;

&lt;p&gt;我们要做的是一个动态的页面，静态页面的解决方案现在已经很多了，相比较动态页面要复杂很多：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;响应用户操作&lt;/li&gt;
  &lt;li&gt;组件之间交互&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用户的响应还比较简单，对于不同的控件可以预先实现不同的事件，在事件发生时触发对应的代码：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@CompA
    @on(click)
        alert(&quot;用户点击了按钮&quot;)
&lt;/pre&gt;

&lt;p&gt;组件之间的交互有两种实现方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;暴露接口供其他组件调用&lt;/li&gt;
  &lt;li&gt;事件驱动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式在MFC、Swing等编写的时候基本上都属于这种，感觉写起来太消耗脑细胞! 而且HTML的页面上各部分的交互数据居多，那么可以参考Actor模型来设计：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
@channel(param)

@CompA(to = &quot;param&quot;)
@CompB(to = &quot;param&quot;)
@CompC(to = &quot;param&quot;)

@CompD(from = &quot;param&quot;)
    @on(click) // 响应点击事件
        // do sth.
&lt;/pre&gt;

&lt;p&gt;在查询条件A、B、C发生变化时将结果发送消息给D，然后在D本地将其保存起来方便后面使用（比如发送请求）。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;预览&lt;/h2&gt;

&lt;p&gt;在一个独立的页面配置应用上配置完成之后预览时，需要的数据要到业务应用中获取，用ajax的话就遇到了跨域问题。两种解决办法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有的接口使用JSONP格式&lt;/li&gt;
  &lt;li&gt;在业务系统中提供一个页面专门用来做预览&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用JSONP的主要缺点就是只能用GET方式，也就是说：&lt;strong&gt;GET的限制JSONP全都有&lt;/strong&gt;。第二种方法则有点像开个后门，直接看到的效果和在应用中看到的效果已经是一致的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;业务应用接入&lt;/h2&gt;

&lt;p&gt;接入的方式是由配置的产出的结果有关系的，现在有两种产出的方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;提供JSON接口来输出展示需要的数据&lt;/li&gt;
  &lt;li&gt;根据配置动态生成JS文件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;第一种方式比较直观，做起来也很简单，业务方执行的流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;开发写个页面将CODE设置进去&lt;/li&gt;
  &lt;li&gt;渲染HTML页面，然后运行JS根据CODE去获取展示所需的数据&lt;/li&gt;
  &lt;li&gt;渲染页面&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;该方式有个小小的问题：&lt;strong&gt;在根据CODE获取页面时页面会出现空白&lt;/strong&gt;。用第二种方式将生成的JS引入对应的页面即可，具体页面长什么样子都在该JS文件中保存。这样做的好处是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;可以在JS文件中定义更加复杂的操作&lt;/li&gt;
  &lt;li&gt;JS代码在浏览器做缓存，从第二次操作开始就不需要请求页面展示的数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外在产出JS时基本上就没有搞不定的事情了。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;其实这个还没开始做，想法也在UPDATING，做完再来总结:)&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Aug 2015 00:00:00 +0800</pubDate>
        <link>/dsl/2015/08/28/Easydt-Page-Solution.html</link>
        <guid isPermaLink="true">/dsl/2015/08/28/Easydt-Page-Solution.html</guid>
        
        
        <category>dsl</category>
        
      </item>
    
      <item>
        <title>Java并发编程实战</title>
        <description>&lt;p&gt;看完之后感觉Doug Lea写的书都是精品，不过有些地方翻译的确实不怎么样…&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;线程&lt;/h2&gt;

&lt;p&gt;线程比进程更轻，更易于共享数据，关于Java中的线程要了解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;线程安全&lt;/li&gt;
  &lt;li&gt;可见性&lt;/li&gt;
  &lt;li&gt;中断&lt;/li&gt;
  &lt;li&gt;关闭钩子&lt;/li&gt;
  &lt;li&gt;守护线程&lt;/li&gt;
  &lt;li&gt;ThreadLocal&lt;/li&gt;
  &lt;li&gt;线程的开销&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;很长一段时间对线程安全的定义比较迷糊，下面这个定义感觉是比较准确的：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当多个线程访问某个类时，不管运行时环境采用何种调度方式，该类都能表现出正确的行为，那么就称这个类是线程安全的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;或者更简单地描述：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;结果与调度的方式无关。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看似简单但坑却不少，比如多线程中可见性这种反直觉的东西：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
private static boolean ready;
private static int number;
static class ReaderThread extends Thread {
	public void run() {
    	while(!ready){
        	Thread.yield();
        }
        System.out.println(number);
    }
}
public static void main(String[] args){
	new ReaderThread().start();
    number = 42;
    ready = true;
}
&lt;/pre&gt;

&lt;p&gt;这里程序可能持续运行下去，因为ReaderThread可能永远看不到ready的值；程序也可能输出0，因为ReadyThread可能只看到写入ready的值：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在没有同步的情况下编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;开启线程只需要一个start，而想让它停下来就没那么简单了，因为stop已经不建议再使用，原因是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在任意位置抛出ThreadDeath&lt;/li&gt;
  &lt;li&gt;释放锁&lt;/li&gt;
  &lt;li&gt;关闭时需要同步，如果run是同步的那就永远都无法关闭&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;取而代之的是中断，但是中断并不代表停止，而是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;调用interrupt并不意味着立即停止目标线程的执行，而只是传递请求中断的消息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但是比较靠谱的是在很多库中已经对中断做了处理：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在调用join、sleep、wai等阻塞返回后会抛出异常并擦除中断状态&lt;/li&gt;
  &lt;li&gt;在IO操作上阻塞时也会抛出异常并关闭流&lt;/li&gt;
  &lt;li&gt;在java.nio.channel.Selector上等待时也会立即返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果没有上面这些情况的话，调用中断不会对线程的执行造成半毛钱影响，如果你需要你的线程去响应中断，需要在合适的地方增加代码去判断并处理。&lt;/p&gt;

&lt;p&gt;想让线程按照我们的意愿停止已经很麻烦了，但是如果它运行的时候还抛出莫名其妙的异常就更加恼火了，不过幸好还有：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface UncaughtExceptionHandler {
	void uncaughtException(Thread t, Throwable e);
}
&lt;/pre&gt;

&lt;p&gt;有时候我们需要在程序运行完成的时候做一些扫尾的工作，可以用关闭钩子来实现：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
Runtime.getRuntime().addShutdownHook(new Thread(){
	public void run(){
    	// your code
    }
})
&lt;/pre&gt;

&lt;p&gt;只有JVM是正常结束的时候才会运行钩子，被暴力kill掉的时候就没机会执行了。既然讲到JVM的退出刚好可以看下Daemon和正常线程的区别：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当线程退出时，JVM会检查其他正在运行的线程，如果这些线程都是守护线程，那么JVM将退出。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;类似垃圾回收这些线程就得设置成守护线程，不能让他们影响了JVM的正常退出。在开启多线程的时候ThreadLocal真是一个神器，可以让很多信息的传递变得非常简单，具体可以看&lt;a href=&quot;http://wsztrush.github.io/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/2015/05/14/Java-ThreadLocal.html&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最后，线程不仅在效率还是体验方面都带来了巨大的提升，单并非多多益善，增加线程也同时会增加一些开销：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;上下文切换&lt;/li&gt;
  &lt;li&gt;内存同步（这个影响很小）&lt;/li&gt;
  &lt;li&gt;阻塞（竞争的同步可能需要操作系统的介入）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;现在大家已经很少new Thread().start();这么玩了，大部分都会用线程池来管理，下面接着看：&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;线程池&lt;/h2&gt;

&lt;p&gt;创建新线程也是有开销了，所以可以将线程缓存下来重复利用，在使用线程池时需要注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;阀值&lt;/li&gt;
  &lt;li&gt;饱和策略&lt;/li&gt;
  &lt;li&gt;ThreadFactory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;平时用到的大部分线程池的底层都是ThreadPoolExecutor，在初始化时有几个关键的阀值需要注意：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;阀值&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;corePoolSize&lt;/td&gt;
      &lt;td&gt;在execute时如果当先线程数小于该值则直接创建新线程来运行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;maximumPoolSize&lt;/td&gt;
      &lt;td&gt;最大线程数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;keepAliveTime&lt;/td&gt;
      &lt;td&gt;Worker取任务的等待时长，超时后Worker就退出了&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果在execute的时候线程池已经满了，同时任务队列也满了，那么此时任务怎么办？这时候就饱和策略就要上场了：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
&lt;/pre&gt;

&lt;p&gt;同时提供四种实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;AbortPolicy：抛异常&lt;/li&gt;
  &lt;li&gt;CallerRunsPolicy：退回到调用者线程处理任务&lt;/li&gt;
  &lt;li&gt;DiscardOldestPolicy：抛弃最老任务&lt;/li&gt;
  &lt;li&gt;DiscardPolicy：抛弃&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后可以通过ThreadFactory来设置线程池中线程的属性：&lt;/p&gt;

&lt;pre class=&quot;prettyprint&quot;&gt;
public interfact ThreadFactory{
    Thread newThread(Runnable r);
}
&lt;/pre&gt;

&lt;p&gt;在execute时如果需要创建新的线程就会调用该方法。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;锁&lt;/h2&gt;

&lt;p&gt;多个线程同时跑为了保证结果的准确锁是少不了的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁的实现&lt;/li&gt;
  &lt;li&gt;死锁&lt;/li&gt;
  &lt;li&gt;活锁&lt;/li&gt;
  &lt;li&gt;减少锁竞争&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;常用的锁有两种实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;synchronized&lt;/li&gt;
  &lt;li&gt;concurrent&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在之前concurrent要比synchronized快很多，但这个已经是很久之前的事情了，在synchronized的实现中通过偏向锁、轻量级锁优化了性能，而concurrent则是Doug Lea的作品。&lt;/p&gt;

&lt;p&gt;相比较来说各有优劣：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;synchronized缺点是不够灵活，但是你不需要费心释放锁；而concurrent使用很灵活，可以分别在不同的地方加锁、解锁，但是如果忘记解锁就悲剧了，一般用try-finally来做。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;另外concurrent中实现了各种策略的锁：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;锁&lt;/th&gt;
      &lt;th&gt;作用&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ReentrantLock&lt;/td&gt;
      &lt;td&gt;可重入独占锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ReentrantReadWriteLock&lt;/td&gt;
      &lt;td&gt;可重入读写锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Condition&lt;/td&gt;
      &lt;td&gt;条件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CountDownLatch&lt;/td&gt;
      &lt;td&gt;向下递减，到0时线程被唤醒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CyclicBarrier&lt;/td&gt;
      &lt;td&gt;有指定书目的线程await之后，一起开始执行&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FutureTask&lt;/td&gt;
      &lt;td&gt;先提交任务，在get时阻塞&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Semaphore&lt;/td&gt;
      &lt;td&gt;信号量&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其实concurrent中核心是AQS框架，它将等待队列等操作都进行了封装，你只需要实现下面四个方法即可实现需要的锁：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;tryAcquire&lt;/li&gt;
  &lt;li&gt;tryAcquireShared&lt;/li&gt;
  &lt;li&gt;tryRelease&lt;/li&gt;
  &lt;li&gt;tryReleaseShared&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;锁用的比较多的时候就容易产生死锁，一般原因分为下面几类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;锁顺序死锁&lt;/li&gt;
  &lt;li&gt;资源死锁&lt;/li&gt;
  &lt;li&gt;线程饥饿死锁：在同一个线程池中执行有互相依赖的任务时需要注意&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以用&lt;strong&gt;jstack –l pid&lt;/strong&gt;来检测死锁。既然看到到了死锁，那就顺便看一下活锁：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;不停地取出第一个任务，但是每次都会失败。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实活锁看起来就是代码写的太挫了…用锁的时候除了导致程序的活跃性问题，还可能导致性能问题，减少锁开销的一般方法为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;缩小同步的范围，快进快出&lt;/li&gt;
  &lt;li&gt;减少锁的粒度&lt;/li&gt;
  &lt;li&gt;锁分段&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用锁一定要慎重。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;多线程编程中还需要看看&lt;strong&gt;非阻塞算法&lt;/strong&gt;、&lt;strong&gt;Java内存模型&lt;/strong&gt;，而真正在写代码的时候能写好确实是一件非常不容易的事情，通常需要通过很多代码的磨练总结在使用各个工具时候的一些基本原则，才能慢慢顺手一些。&lt;/p&gt;
</description>
        <pubDate>Wed, 19 Aug 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Java-Concurrency-In-Practice.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Java-Concurrency-In-Practice.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>代码简洁之道</title>
        <description>
</description>
        <pubDate>Wed, 19 Aug 2015 00:00:00 +0800</pubDate>
        <link>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Clean-Code.html</link>
        <guid isPermaLink="true">/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2015/08/19/Clean-Code.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
  </channel>
</rss>
