<!DOCTYPEhtmlPUBLIC"-//W3C//DTDXHTML1.0Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html>
	<!-- 引入CSS/JS -->
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="/assets/css/main.css"/>
	<script type="text/javascript" src="/assets/javascripts/main.js"></script>

	<!-- pygments代码高亮 -->
	<!-- <link rel="stylesheet" type="text/css" href="/assets/css/pygments.css"/> -->
	<!-- google代码高亮 -->
	<script src="/assets/css/prettify.js"></script>
	<link href="/assets/css/prettify.css" rel="stylesheet">
	<title>模板语言设计</title>
</head>

	<body onload="prettyPrint()">
		<div class="tool">
	<span><b>WsztRush</b></span>
	<div class="links">
		<a href="/index.html">Blog</a>
		<a href="/categories.html">Categories</a>
		<a href="/about/">About</a>		
	</div>
</div>

		<div class="post-container">
			<h1>模板语言设计</h1>
			<p>模板语言技术极大的减少了苦逼码农的工作量，使我们从大量的字符串拼接中脱离出来：</p>

<ol>
  <li>
    <p>有自己的语法控制结构</p>
  </li>
  <li>
    <p>将两种语法分割</p>
  </li>
</ol>

<p>作为一种语言运行的方式无非下面几种：</p>

<ol>
  <li>
    <p>边处理源码边渲染，和很多的脚本语言类似</p>
  </li>
  <li>
    <p>生成AST存到内存里面，每次渲染则是在AST上遍历完成</p>
  </li>
  <li>
    <p>生成目标语言或者字节码等</p>
  </li>
</ol>

<p>这篇文章的重点是比较各个模板语言，看看大家设计的思虑~ 具体如何解析、运行看看<a href="http://wsztrush.github.io/dsl/2015/09/06/Language-Implementation-Patterns.html">《编程语言实现模式》</a>基本可以很快搞出来。</p>

<h2 id="section">有控制结构</h2>

<p>从实习就开始用<strong>Velocity</strong>来渲染HTML，感觉好用以至于现在都用它来渲染SQL语句：</p>

<pre class="prettyprint">

#foreach($info in $list)

    $info.someList

#end

</pre>

<p>所有的控制结构都是<code>#</code>开头的，而取数据则是<code>$</code>开头，剩下普通的字符串就直接向结果中拼接，因为#$在HTML中很少用到，所以这样设计还是非常好用的~</p>

<p>对应的，在前端世界里<strong>EmberJS</strong>与它很像：</p>

<pre class="prettyrpint">



    Welcome back, &lt;b&gt; &lt;/b&gt;!



    Please log in.



</pre>

<p>这两年非常火的<strong>Angular</strong>基本上也是这种思路，用``来取数据（双向绑定）：</p>

<pre class="prettyprint">

&lt;div ng-if="person != null"&gt;

    Welcome back, &lt;b&gt; &lt;/b&gt;!

&lt;/div&gt;

&lt;div ng-if="person == null"&gt;

    Please log in.

&lt;/div&gt;

</pre>

<p>由于Angular想做的事情是根据数据的变化来修改页面的展示，用Velocity这种有自己的控制语句来做还是非常困难的，那么更好的思路就是把控制结构与DOM结构绑定，比如<code>ng-if</code>，<code>ng-repeat</code>等。</p>

<h2 id="section-1">无控制结构</h2>

<h2 id="react">React</h2>

<p>最近两年React红的发紫，不仅仅因为有个好爹，体验了一下感觉JSX还是不错的：</p>

<pre class="prettyprint">

var root =(

    &lt;ul className="my-list"&gt;

        &lt;li&gt;First Text Content&lt;/li&gt;

        &lt;li&gt;Second Text Content&lt;/li&gt;

    &lt;/ul&gt;

);

</pre>

<p>这种JS和XML混排的方式看着有点头大，但是仔细看下还是挺直观的！在遇到<code>&lt;xxx&gt;</code>的时候创建元素，在遇到<code>{xxx}</code>的时候当做JS解析，而最终是将其翻译成JS代码来执行：</p>

<pre class="prettyprint">

var child1 = React.createElement('li', null, 'First Text Content');

var child2 = React.createElement('li', null, 'Second Text Content');

var root = React.createElement('ul', { className: 'my-list' }, child1, child2);

</pre>

<p>让JS参与到模板渲染的过程中能极大地提高模板的能力，但是问题是太灵活了以至于数据变化的时候都不知道该怎么修改DOM了，这么看来虚拟DOM的<strong>Diff</strong>算法其实也是无奈之举~~~</p>

<h2 id="emberjs">EmberJS</h2>

<p>在绑定数据的同时可以进行一些简单的逻辑控制：</p>

<p>看起来有点像是Angular和Velocity的结合体！越是这么搞越像是在搞静态页面，对于动态页面来说基本是不行的~~</p>

<h2 id="mustache">Mustache</h2>

<p>Mustache通常被称为JavaScript模板的基础：</p>

<pre class="prettyprint">

Mustache.render("Hello, ", { name: "Jack" });

</pre>

<p>用来渲染字符串（或者静态HTML）还是可以的！</p>


			<!-- 评论组件 -->
			<div id="disqus_thread"/>
		</div>
	</body>
</html>
<!-- 评论组件 -->
<script type="text/javascript">
	var disqus_shortname = 'wsztrush';
	(function() {
		var dsq = document.createElement('script');
		dsq.type = 'text/javascript';
		dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<!-- 百度访问统计 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?08a976e8d7e5a20acfcb566bd22a1db1";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script type="text/javascript">
	document.getElementById("barClick").onclick = click;
</script>

