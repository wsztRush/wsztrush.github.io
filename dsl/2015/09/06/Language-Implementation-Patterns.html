<!DOCTYPEhtmlPUBLIC"-//W3C//DTDXHTML1.0Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
<html>
	<!-- 引入CSS/JS -->
<head>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="/assets/css/main.css"/>
	<script type="text/javascript" src="/assets/javascripts/main.js"></script>

	<!-- pygments代码高亮 -->
	<!-- <link rel="stylesheet" type="text/css" href="/assets/css/pygments.css"/> -->
	<!-- google代码高亮 -->
	<script src="/assets/css/prettify.js"></script>
	<link href="/assets/css/prettify.css" rel="stylesheet">
	<title>编程语言实现模式</title>
</head>

	<body onload="prettyPrint()">
		<div class="post-container">
			<h1>编程语言实现模式</h1>
			<p><img src="http://img4.douban.com/mpic/s7661036.jpg" alt="" /></p>

<p>很久之前已经把这本书看过一遍了，但是一直没有实践过!于是，拿出来再复习一遍，顺便记录笔记。关于这本书有几点：</p>

<ol>
  <li>ANTLR贯穿全书：作者是<strong>Terence Parr</strong>，这点也就不奇怪了</li>
  <li>ANTLR生成的代码是LL(K)的</li>
  <li>偏重实践，原理很少，想看原理要去看<a href="http://img3.douban.com/mpic/s3392161.jpg">龙书</a></li>
</ol>

<p>另外，你应该先知道编译的过程大概分成哪几步骤以及为什么这样划分！废话少说，来看这本书的内容。</p>

<h2 id="section">解析模式</h2>

<p>词法分析和语法分析很多地方都是相同的，解析器结构如下：</p>

<pre class="prettyprint">
public class G extends Parser {
    // 类型定义
    // 合适的构造函数
    // 规则对应的方法
}
</pre>

<p>在一个规则中包含很多子规则时，根据向前看符号来决定使用哪个，这个逻辑的代码描述可以用if-else来做：</p>

<pre class="prettyprint">
if(向前看到alt1){
    // 匹配alt1
} else if(向前看到alt2){
    // 匹配alt1
}....
</pre>

<p>当然这里也可以用switch做，在规则上定义的一些常见操作有：</p>

<ol>
  <li>(T)?：T可有可无</li>
  <li>(T)+：多个T</li>
  <li>(T)*：零个或多个T</li>
</ol>

<p>这些操作的代码描述：</p>

<pre class="prettyprint">
// (T)?
if(向前看到T){ match(T);}
// (T)+
do{
    match(T);
} while(向前看到T)
// (T)*
while(向前看到T){
    match(T);
}
</pre>

<p>能利用好这三个操作大部分的规则都可以搞定了！词法分析相对语法分析了来说简单很多，Lexer会提供<strong>nextToken()</strong>来供Parser使用来不断地获取TOKEN：</p>

<pre class="prettyprint">
public Token nextToken(){
    while(lookahead-char != EOF) {
        switch(lookahead-char){
            case 空白字符: { consume(); continue; }
            case 字符后面可能是T1: return T1();
            case 字符后面可能是T2: return T2();
			// ...
            default:
                出错;
        }
    }
    return EOF;
}
</pre>

<p>直观上来看用switch进行预测，相当于构造了一个状态机吧，其中<strong>consume()</strong>方法自增下标并将下一个字符当做向前看字符（消费字符）。在仅使用一个向前看符来进行语法分析时，也就是LL(1)，对于下面语法：</p>

<blockquote>
  <ul>
    <li>list : ‘[’ elements ‘]’;</li>
    <li>elements : element (‘,’ element);</li>
    <li>
      <table>
        <tbody>
          <tr>
            <td>element : NAME</td>
            <td>list;</td>
          </tr>
        </tbody>
      </table>
    </li>
  </ul>
</blockquote>

<p>生成的Paser如下：</p>

<pre class="prettyprint">
public class ListParser extends Parser {
    public void list(){
        match(ListLexer.LBRACK); // 匹配并消耗词法单元
        elements();
        match(ListLexer.RBRACK);
    }
    public void elements(){
        element();
        while(lookahead.type == ListLexer.COMMA) {
            match(ListLexer.COMMA);
            element();
        }
    }
    public void element(){
        if(lookahead.type == ListLexer.NAME) match(ListLexer.NAME);
        else if(lookahead.type == ListLexer.LBRACK) list();
        else throw new Error("语法错误");
    }
}
</pre>

<p>很简单的语法用LL(1)是没有问题的，对于稍微复杂一点的其预测能力差就暴露出来了，怎么办？当然是多拿几个进行预测！可以构造环形缓冲区来存放用来预测的TOKEN，另外增加两个方法：</p>

<ol>
  <li><strong>LA</strong>：返回第k个向前看词法单元的类型</li>
  <li><strong>LT</strong>：返回第k个词法单元</li>
</ol>

<p>那么文法：</p>

<blockquote>
  <p>element : NAME ‘=’ NAME : NAME : list ;</p>
</blockquote>

<p>对应的程序描述就变为：</p>

<pre class="prettyprint">
public void element(){
    if(LA(1) == LookaheadLexer.NAME &amp;&amp; LA(2) == LookaheadLexer.EQUALS) {
        match(LookaheadLexer.NAME);
        match(LookaheadLexer.EQUALS);
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.NAME) {
        match(LookaheadLexer.NAME);
    } else if(LA(1) == LookaheadLexer.LBACK) {
        list();
    } else {
        throw new Error("语法错误!");
    }
}
</pre>

<h2 id="section-1">分析输入</h2>


			<!-- 评论组件 -->
			<div id="disqus_thread"/>
		</div>
		<div id="bar" class="category" style="left:-165px;">
	<div class="icon"><a href="/about/"><img src="http://7xiz10.com1.z0.glb.clouddn.com/me.png"/></a></div>
	<div class="icon"><a href="/categories.html"><img src="http://7xiz10.com1.z0.glb.clouddn.com/list.png"/></a></div>
	<div class="icon"><a href="https://github.com/wsztrush"><img src="http://7xiz10.com1.z0.glb.clouddn.com/github.png"/></a></div>
	<div class="icon"><a href="http://weibo.com/wsztrush"><img src="http://7xiz10.com1.z0.glb.clouddn.com/weibo.png"/></a></div>
	<div class="icon"><img id="barClick" src="http://7xiz10.com1.z0.glb.clouddn.com/right.png"/></div>
</div>

	</body>
</html>
<!-- 评论组件 -->
<script type="text/javascript">
	var disqus_shortname = 'wsztrush';
	(function() {
		var dsq = document.createElement('script');
		dsq.type = 'text/javascript';
		dsq.async = true;
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<!-- 百度访问统计 -->
<script>
  var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?08a976e8d7e5a20acfcb566bd22a1db1";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script type="text/javascript">
	document.getElementById("barClick").onclick = click;
</script>

